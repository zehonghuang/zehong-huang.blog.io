<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【JRaft源码分析03】成员变化</title>
      <link href="/2020/04/10/20200410-%E3%80%90JRaft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003%E3%80%91%E6%88%90%E5%91%98%E5%8F%98%E5%8C%96/"/>
      <url>/2020/04/10/20200410-%E3%80%90JRaft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003%E3%80%91%E6%88%90%E5%91%98%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>第三篇说成员变化，有了对选举和日志复制的认识，这个模块就很轻松简单了。</p><hr><p>成员变化就两种情况，增加删除更换节点，和转移领导人。</p><h3 id="1、更改一般节点"><a href="#1、更改一般节点" class="headerlink" title="1、更改一般节点"></a>1、更改一般节点</h3><p><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/%E4%B8%80%E8%88%AC%E8%8A%82%E7%82%B9%E6%88%90%E5%91%98%E5%8F%98%E5%8C%96.png" alt="一般成员节点变化"></p><p>这张图看起来很复杂，但整体流程其实很简单，非常清晰明了的。下面的方法就是修改配置的统一入口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsafeRegisterConfChange</span><span class="params">(<span class="keyword">final</span> Configuration oldConf, <span class="keyword">final</span> Configuration newConf, <span class="keyword">final</span> Closure done)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Requires.requireTrue(newConf.isValid(), <span class="string">"Invalid new conf: %s"</span>, newConf);</span><br><span class="line">    <span class="comment">// The new conf entry(will be stored in log manager) should be valid</span></span><br><span class="line">    Requires.requireTrue(<span class="keyword">new</span> ConfigurationEntry(<span class="keyword">null</span>, newConf, oldConf).isValid(), <span class="string">"Invalid conf entry: %s"</span>,</span><br><span class="line">        newConf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state != State.STATE_LEADER) &#123;</span><br><span class="line">        <span class="comment">// error</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置正在更改中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.confCtx.isBusy()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (done != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Utils.runClosureInThread(done, <span class="keyword">new</span> Status(RaftError.EBUSY, <span class="string">"Doing another configuration change."</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conf.getConf().equals(newConf)) &#123;</span><br><span class="line">        Utils.runClosureInThread(done);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.confCtx.start(oldConf, newConf, done);<span class="comment">//ConfigurationCtx，启动更新配置流程。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JRaft把更新配置拆解为四个步骤：</p><ul><li>1、STAGE_CATCHING_UP<ul><li>如果有追加或更换新节点，需要使新节点日志跟集群同步，复制完成日志后，调用catchUpClosure，下一步</li></ul></li><li>2、STAGE_JOINT<ul><li>将新旧配置复制到Follower，收到大部分回应后，下一步</li></ul></li><li>3、STAGE_STABLE<ul><li>通知Follower删除旧配置，收到大部分回应后，下一步</li></ul></li><li>4、STAGE_NONE<ul><li>✅</li></ul></li></ul><h4 id="1-1、日志追赶-STAGE-CATCHING-UP"><a href="#1-1、日志追赶-STAGE-CATCHING-UP" class="headerlink" title="1.1、日志追赶(STAGE_CATCHING_UP)"></a>1.1、日志追赶(STAGE_CATCHING_UP)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> Configuration oldConf, <span class="keyword">final</span> Configuration newConf, <span class="keyword">final</span> Closure done)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.done = done;</span><br><span class="line">    <span class="keyword">this</span>.stage = Stage.STAGE_CATCHING_UP;</span><br><span class="line">    <span class="keyword">this</span>.oldPeers = oldConf.listPeers();</span><br><span class="line">    <span class="keyword">this</span>.newPeers = newConf.listPeers();</span><br><span class="line">    <span class="keyword">this</span>.oldLearners = oldConf.listLearners();</span><br><span class="line">    <span class="keyword">this</span>.newLearners = newConf.listLearners();</span><br><span class="line">    <span class="keyword">final</span> Configuration adding = <span class="keyword">new</span> Configuration();</span><br><span class="line">    <span class="keyword">final</span> Configuration removing = <span class="keyword">new</span> Configuration();</span><br><span class="line">    newConf.diff(oldConf, adding, removing);</span><br><span class="line">    <span class="keyword">this</span>.nchanges = adding.size() + removing.size();</span><br><span class="line"></span><br><span class="line">    addNewLearners();</span><br><span class="line">    <span class="keyword">if</span> (adding.isEmpty()) &#123;<span class="comment">//只删不增</span></span><br><span class="line">        nextStage();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    addNewPeers(adding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNewPeers</span><span class="params">(<span class="keyword">final</span> Configuration adding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.addingPeers = adding.listPeers();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> PeerId newPeer : <span class="keyword">this</span>.addingPeers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.node.replicatorGroup.addReplicator(newPeer)) &#123;</span><br><span class="line">            onCaughtUp(<span class="keyword">this</span>.version, newPeer, <span class="keyword">false</span>);<span class="comment">//复制器启动异常，立即放弃追赶</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> OnCaughtUp caughtUp = <span class="keyword">new</span> OnCaughtUp(<span class="keyword">this</span>.node, <span class="keyword">this</span>.node.currTerm, newPeer, <span class="keyword">this</span>.version);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = Utils.nowMs() + <span class="keyword">this</span>.node.options.getElectionTimeoutMs();</span><br><span class="line">        <span class="comment">//设置caughtUp回调，等待replicator完成复制工作</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.node.replicatorGroup.waitCaughtUp(newPeer, <span class="keyword">this</span>.node.options.getCatchupMargin(), dueTime, caughtUp)) &#123;</span><br><span class="line">            onCaughtUp(<span class="keyword">this</span>.version, newPeer, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Replicator</code>启动后依旧做日常工作，<code>onAppendEntriesReturned</code>每次复制成功都会执行<code>r.notifyOnCaughtUp(RaftError.SUCCESS.getNumber(), false)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyOnCaughtUp</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> code, <span class="keyword">final</span> <span class="keyword">boolean</span> beforeDestroy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.catchUpClosure == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里有一大段关于waitCaughtUp定时器的，不说了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> CatchUpClosure savedClosure = <span class="keyword">this</span>.catchUpClosure;</span><br><span class="line">    <span class="keyword">this</span>.catchUpClosure = <span class="keyword">null</span>;</span><br><span class="line">    Utils.runClosureInThread(savedClosure, savedClosure.getStatus());<span class="comment">//执行上面说到的OnCaughtUp</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onCaughtUp</span><span class="params">(<span class="keyword">final</span> PeerId peer, <span class="keyword">final</span> <span class="keyword">long</span> term, <span class="keyword">final</span> <span class="keyword">long</span> version, <span class="keyword">final</span> Status st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 被选下去</span></span><br><span class="line">        <span class="keyword">if</span> (term != <span class="keyword">this</span>.currTerm &amp;&amp; <span class="keyword">this</span>.state != State.STATE_LEADER) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st.isOk()) &#123;</span><br><span class="line">            <span class="comment">// Caught up successfully</span></span><br><span class="line">            <span class="keyword">this</span>.confCtx.onCaughtUp(version, peer, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 超时继续等待</span></span><br><span class="line">        <span class="keyword">if</span> (st.getCode() == RaftError.ETIMEDOUT.getNumber()</span><br><span class="line">            &amp;&amp; Utils.monotonicMs() - <span class="keyword">this</span>.replicatorGroup.getLastRpcSendTimestamp(peer) &lt;= <span class="keyword">this</span>.options</span><br><span class="line">                .getElectionTimeoutMs()) &#123;</span><br><span class="line">            <span class="comment">// ...return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.confCtx.onCaughtUp(version, peer, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void com.alipay.sofa.jraft.core.NodeImpl.ConfigurationCtx#onCaughtUp</span><br><span class="line">        (<span class="keyword">final</span> <span class="keyword">long</span> version, <span class="keyword">final</span> PeerId peer, <span class="keyword">final</span> <span class="keyword">boolean</span> success) &#123;</span><br><span class="line">    </span><br><span class="line">    Requires.requireTrue(<span class="keyword">this</span>.stage == Stage.STAGE_CATCHING_UP, <span class="string">"Stage is not in STAGE_CATCHING_UP"</span>);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="keyword">this</span>.addingPeers.remove(peer);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.addingPeers.isEmpty()) &#123;</span><br><span class="line">            nextStage();<span class="comment">//下一步，STAGE_JOINT</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reset(<span class="keyword">new</span> Status(RaftError.ECATCHUP, <span class="string">"Peer %s failed to catch up."</span>, peer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2、同步配置信息-STAGE-JOINT-amp-STAGE-STABLE"><a href="#1-2、同步配置信息-STAGE-JOINT-amp-STAGE-STABLE" class="headerlink" title="1.2、同步配置信息(STAGE_JOINT &amp; STAGE_STABLE)"></a>1.2、同步配置信息(STAGE_JOINT &amp; STAGE_STABLE)</h4><p>这个过程有两个步骤，第一步同步新旧配置，所有写入操作兼容两种配置，第二步则是通知Follwer删除旧配置。</p><p>在过渡到第二步之前，Leader需要new &amp; old quonum &lt;=0，才能提交数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.alipay.sofa.jraft.core.NodeImpl.ConfigurationCtx</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextStage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Requires.requireTrue(isBusy(), <span class="string">"Not in busy stage"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.stage) &#123;</span><br><span class="line">        <span class="keyword">case</span> STAGE_CATCHING_UP:</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.nchanges &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.stage = Stage.STAGE_JOINT;</span><br><span class="line">                <span class="keyword">this</span>.node.unsafeApplyConfiguration(<span class="keyword">new</span> Configuration(<span class="keyword">this</span>.newPeers, <span class="keyword">this</span>.newLearners),</span><br><span class="line">                    <span class="keyword">new</span> Configuration(<span class="keyword">this</span>.oldPeers), <span class="keyword">false</span>);<span class="comment">// new and old</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果只更改一个节点，网络出现故障的情况下，新增节点要么被孤立要么融入</span></span><br><span class="line">            <span class="comment">// 删除节点要么成功要么被孤立，不影响系统可用性</span></span><br><span class="line">            <span class="comment">// 可以跳过同时保留新旧配置</span></span><br><span class="line">        <span class="keyword">case</span> STAGE_JOINT:</span><br><span class="line">            <span class="keyword">this</span>.stage = Stage.STAGE_STABLE;</span><br><span class="line">            <span class="keyword">this</span>.node.unsafeApplyConfiguration(<span class="keyword">new</span> Configuration(<span class="keyword">this</span>.newPeers, <span class="keyword">this</span>.newLearners), <span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// only new</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STAGE_STABLE:</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> shouldStepDown = !<span class="keyword">this</span>.newPeers.contains(<span class="keyword">this</span>.node.serverId);</span><br><span class="line">            reset(<span class="keyword">new</span> Status());</span><br><span class="line">            <span class="keyword">if</span> (shouldStepDown) &#123;</span><br><span class="line">                <span class="keyword">this</span>.node.stepDown(<span class="keyword">this</span>.node.currTerm, <span class="keyword">true</span>, <span class="keyword">new</span> Status(RaftError.ELEADERREMOVED,</span><br><span class="line">                    <span class="string">"This node was removed."</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STAGE_NONE:</span><br><span class="line">            <span class="comment">// noinspection ConstantConditions</span></span><br><span class="line">            Requires.requireTrue(<span class="keyword">false</span>, <span class="string">"Can't reach here"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写日志，等复制给Follower后，调用configurationChangeDone，进入下一步STAGE_STABLE</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsafeApplyConfiguration</span><span class="params">(<span class="keyword">final</span> Configuration newConf, <span class="keyword">final</span> Configuration oldConf,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">final</span> <span class="keyword">boolean</span> leaderStart)</span> </span>&#123;</span><br><span class="line">    Requires.requireTrue(<span class="keyword">this</span>.confCtx.isBusy(), <span class="string">"ConfigurationContext is not busy"</span>);</span><br><span class="line">    <span class="keyword">final</span> LogEntry entry = <span class="keyword">new</span> LogEntry(EnumOutter.EntryType.ENTRY_TYPE_CONFIGURATION);</span><br><span class="line">    entry.setId(<span class="keyword">new</span> LogId(<span class="number">0</span>, <span class="keyword">this</span>.currTerm));</span><br><span class="line">    entry.setPeers(newConf.listPeers());</span><br><span class="line">    entry.setLearners(newConf.listLearners());</span><br><span class="line">    <span class="keyword">if</span> (oldConf != <span class="keyword">null</span>) &#123;</span><br><span class="line">        entry.setOldPeers(oldConf.listPeers());</span><br><span class="line">        entry.setOldLearners(oldConf.listLearners());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ConfigurationChangeDone configurationChangeDone = <span class="keyword">new</span> ConfigurationChangeDone(<span class="keyword">this</span>.currTerm, leaderStart);</span><br><span class="line">    <span class="comment">// Use the new_conf to deal the quorum of this very log</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.ballotBox.appendPendingTask(newConf, oldConf, configurationChangeDone)) &#123;</span><br><span class="line">        Utils.runClosureInThread(configurationChangeDone, <span class="keyword">new</span> Status(RaftError.EINTERNAL, <span class="string">"Fail to append task."</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> List&lt;LogEntry&gt; entries = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    entries.add(entry);</span><br><span class="line">    <span class="keyword">this</span>.logManager.appendEntries(entries, <span class="keyword">new</span> LeaderStableClosure(entries));</span><br><span class="line">    checkAndSetConfiguration(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color=#f28080><p>但是STAGE_JOINT存在一个隐患，如果Leader没来得及把<code>new&amp;old</code>配置复制到所有Follwer就崩溃了，那么会出现一批只有<code>old</code>和一批<code>new&amp;old</code>的节点，极有可能分别选举出term相同的Leader，一个同时存在于<code>new&amp;old</code>配置的Follwer会收到来自不同Leader的消息。</p><p>之前看到handleAppendEntriesRequest的处理，就是直接<code>currTerm+1</code>强制让两个Leader下台并发起选举，成为新任领导。</p><p>[1] 那么新Leader可以通过日志，向只有<code>old</code>的节点追加<code>new</code>，这样集群配置会长期处在一个unstable状态。发生下次成员变化时，会直接覆盖原来的<code>old</code>，直到步骤走到<code>STAGE_NONE</code>才会恢复到stable状态。</p><p>STAGE_STABLE阶段依然有风险，Leader崩溃后会出现一批只有<code>new</code>和一批<code>new&amp;old</code>的节点，同样会分别出现两个Leader，<code>new</code>和<code>new&amp;old</code>配置中的Follower都有可能收到来自不同Leader的消息。</p><p>同样在handleAppendEntriesRequest做处理，如果<code>new</code>受到，<code>currTerm+1</code>可以使new且删除old的配置复制到其他节点。反之，回带上面[1]的状态。</p></font>]]></content>
      
      
      <categories>
          
          <category> 分布式框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> CAP理论 </tag>
            
            <tag> RAFT算法 </tag>
            
            <tag> 分布式一致性 </tag>
            
            <tag> BRAFT </tag>
            
            <tag> JRaft </tag>
            
            <tag> 选举算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JRaft源码分析02】心跳机制以及日志复制</title>
      <link href="/2020/04/01/20200401-%E3%80%90JRaft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002%E3%80%91%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6/"/>
      <url>/2020/04/01/20200401-%E3%80%90JRaft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002%E3%80%91%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>日志复制是所有分布式共识算法最重要也是最复杂的部分，需要考虑各种各样安全性，比如机器挂了持久化没做、网络分区导致term&amp;logindex不一致、成员变化带来两个任期相同的leader、异步网络出现日志乱序等等。</p><p>很多个细节，我边看源码边照着论文理解，一个异常判断反复推敲它的作用，想象发生的场景。这是源码级熟悉raft的好处，多多少少能身临其境，获取更多的实战校验。</p><p>后面至少还有两篇，成员变化和日志压缩。</p><hr><p>花了点时间做张较为直观的简化流程图，红色箭头是日志复制的过程。还是挺复杂的，包括不限于Node、LogManager、Replicator、BallotBox、StateMachine之间的调用，其实还有快照，以后再讲。</p><p>本文会分为三部分讲，写请求日志落盘、日志复制、commit执行StateMachine。<br><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/jraft%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="日志复制状态机"></p><p>开始前，有几个全局变量需要说明一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下一个要发送的LogIndexId，Leader上任初始化为lastLogIndex + 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span>                    nextIndex;</span><br><span class="line"><span class="comment">//每次日志复制都把多个LogEntity封装进Inflight，一次发送</span></span><br><span class="line"><span class="keyword">private</span> Inflight                         rpcInFly;  <span class="comment">//这里记录最近要的一个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayDeque&lt;Inflight&gt;       inflights              = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"><span class="comment">//Raft不允许乱序日志复制，所以需要这两个字段限制某个inflight是否对应某个request和response</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>                              reqSeq                 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>                              requiredNextSeq        = <span class="number">0</span>;    <span class="comment">//限制顺序</span></span><br></pre></td></tr></table></figure><h3 id="1、什么时候写入日志的？"><a href="#1、什么时候写入日志的？" class="headerlink" title="1、什么时候写入日志的？"></a>1、什么时候写入日志的？</h3><p><a href="https://github.com/zehonghuang/sofa-jraft/tree/master/jraft-example" target="_blank" rel="noopener">jraft-example</a>里有<code>CounterServer</code>这个示例，<code>IncrementAndGetRequestProcessor</code>专门处理写入请求，可见调用了<code>com.alipay.sofa.jraft.example.counter.CounterServiceImpl#applyOperation</code>，然后是<code>com.alipay.sofa.jraft.Node#apply</code>，写入请求处理从<code>NodeImpl.apply</code>开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(<span class="keyword">final</span> Task task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.shutdownLatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Utils.runClosureInThread(task.getDone(), <span class="keyword">new</span> Status(RaftError.ENODESHUTDOWN, <span class="string">"Node is shutting down."</span>));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Node is shutting down"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> LogEntry entry = <span class="keyword">new</span> LogEntry();</span><br><span class="line">    entry.setData(task.getData()); <span class="comment">// 封装具体操作对象，ByteBuffer</span></span><br><span class="line">    <span class="keyword">int</span> retryTimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> EventTranslator&lt;LogEntryAndClosure&gt; translator = (event, sequence) -&gt; &#123;</span><br><span class="line">            event.reset();</span><br><span class="line">            event.done = task.getDone();</span><br><span class="line">            event.entry = entry;</span><br><span class="line">            event.expectedTerm = task.getExpectedTerm();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.applyQueue.tryPublishEvent(translator)) &#123;<span class="comment">//JRaft在处理请求也是采用了完全异步，apply直接把任务丢到applyQueue</span></span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">//在内部类LogEntryAndClosureHandler处理任务</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                retryTimes++;</span><br><span class="line">                <span class="keyword">if</span> (retryTimes &gt; MAX_APPLY_RETRY_TIMES) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;<span class="comment">//applyQueue超载</span></span><br><span class="line">                &#125;</span><br><span class="line">                ThreadHelper.onSpinWait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">        Utils.runClosureInThread(task.getDone(), <span class="keyword">new</span> Status(RaftError.EPERM, <span class="string">"Node is down."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class LogEntryAndClosureHandler</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;LogEntryAndClosure&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;(NodeImpl.<span class="keyword">this</span>.raftOptions.getApplyBatch());</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(<span class="keyword">final</span> LogEntryAndClosure event, <span class="keyword">final</span> <span class="keyword">long</span> sequence, <span class="keyword">final</span> <span class="keyword">boolean</span> endOfBatch)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//shutdownLatch balabala...</span></span><br><span class="line">    <span class="keyword">this</span>.tasks.add(event); <span class="comment">//32条消息以上成批处理，endOfBatch表示是否最后一个</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.tasks.size() &gt;= NodeImpl.<span class="keyword">this</span>.raftOptions.getApplyBatch() || endOfBatch) &#123;</span><br><span class="line">        executeApplyingTasks(<span class="keyword">this</span>.tasks);<span class="comment">// 开始执行task，先生成并写入日志</span></span><br><span class="line">        <span class="keyword">this</span>.tasks.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeApplyingTasks</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntryAndClosure&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = tasks.size();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state != State.STATE_LEADER) &#123;</span><br><span class="line">            <span class="comment">// 这段可以自行看源码，直接调用tasks.get(i).done.run()，返回给client</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> List&lt;LogEntry&gt; entries = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> LogEntryAndClosure task = tasks.get(i);</span><br><span class="line">            <span class="keyword">if</span> (task.expectedTerm != -<span class="number">1</span> &amp;&amp; task.expectedTerm != <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">                <span class="keyword">if</span> (task.done != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//Task指定expectedTerm不一致也是不行的，一般默认-1，因为用户代码是获取不到currTerm的</span></span><br><span class="line">                    Utils.runClosureInThread(task.done, st);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.ballotBox.appendPendingTask(<span class="keyword">this</span>.conf.getConf(),</span><br><span class="line">                <span class="keyword">this</span>.conf.isStable() ? <span class="keyword">null</span> : <span class="keyword">this</span>.conf.getOldConf(), task.done)) &#123;</span><br><span class="line">                <span class="comment">//这里是追加该任务的选票箱，后面再说</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// set task entry info before adding to list.</span></span><br><span class="line">            task.entry.getId().setTerm(<span class="keyword">this</span>.currTerm);</span><br><span class="line">            task.entry.setType(EnumOutter.EntryType.ENTRY_TYPE_DATA);</span><br><span class="line">            entries.add(task.entry);</span><br><span class="line">        &#125;<span class="comment">//这里将操作写入日志</span></span><br><span class="line">        <span class="comment">//落盘后调用LeaderStableClosure，给自己投一票</span></span><br><span class="line">        <span class="keyword">this</span>.logManager.appendEntries(entries, <span class="keyword">new</span> LeaderStableClosure(entries));</span><br><span class="line">        <span class="comment">// update conf.first</span></span><br><span class="line">        checkAndSetConfiguration(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一篇就说到jraft很多核心逻辑都实现在EventHandler子类里，上面的处理请求和下面的日志刷盘、复制也是一样。</p><h3 id="2、有多少个Follower就有多少个Replicator"><a href="#2、有多少个Follower就有多少个Replicator" class="headerlink" title="2、有多少个Follower就有多少个Replicator"></a>2、有多少个Follower就有多少个Replicator</h3><p><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/1564467683208-a49fc0e7-b538-4340-b4d6-9e1698f0e221.png" alt="Replicator"></p><p>在Node赢得选举时，调用执行<code>NodeImpl.becomeLeader()</code>就通过replicatorGroup为每个Follower分配一个Replicator。每一个都有独立的定时器发送heartbeat、logEntity、installSnapshot，所有Replicator并发执行。</p><h4 id="2-1-启动Replicator"><a href="#2-1-启动Replicator" class="headerlink" title="2.1 启动Replicator"></a>2.1 启动Replicator</h4><p>start的调用可以在<code>ReplicatorGroupImpl.addReplicator</code>看到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadId <span class="title">start</span><span class="params">(<span class="keyword">final</span> ReplicatorOptions opts, <span class="keyword">final</span> RaftOptions raftOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opts.getLogManager() == <span class="keyword">null</span> || opts.getBallotBox() == <span class="keyword">null</span> || opts.getNode() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid ReplicatorOptions."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Replicator r = <span class="keyword">new</span> Replicator(opts, raftOptions);</span><br><span class="line">    <span class="keyword">if</span> (!r.rpcService.connect(opts.getPeerId().getEndpoint())) &#123;</span><br><span class="line">        <span class="comment">//建立与Follower的连接哈</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register replicator metric set.</span></span><br><span class="line">    <span class="keyword">final</span> MetricRegistry metricRegistry = opts.getNode().getNodeMetrics().getMetricRegistry();</span><br><span class="line">    <span class="keyword">if</span> (metricRegistry != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> String replicatorMetricName = getReplicatorMetricName(opts);</span><br><span class="line">            <span class="keyword">if</span> (!metricRegistry.getNames().contains(replicatorMetricName)) &#123;</span><br><span class="line">                metricRegistry.register(replicatorMetricName, <span class="keyword">new</span> ReplicatorMetricSet(opts, r));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start replication</span></span><br><span class="line">    r.id = <span class="keyword">new</span> ThreadId(r, r);<span class="comment">//ThreadId本质上就是个锁</span></span><br><span class="line">    r.id.lock();</span><br><span class="line">    notifyReplicatorStatusListener(r, ReplicatorEvent.CREATED);<span class="comment">//监听器ReplicatorStateListener.onCreated|onError|onDestroyed</span></span><br><span class="line">    r.catchUpClosure = <span class="keyword">null</span>;</span><br><span class="line">    r.lastRpcSendTimestamp = Utils.monotonicMs();</span><br><span class="line">    r.startHeartbeatTimer(Utils.nowMs());<span class="comment">//正式启动heartbeat timer</span></span><br><span class="line">    <span class="comment">//这里应该是为了把becomeLeader()-&gt;this.confCtx.flush更新的配置日志同步出去，并unlock</span></span><br><span class="line">    r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> r.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2、发送心跳包"><a href="#2-2、发送心跳包" class="headerlink" title="2.2、发送心跳包"></a>2.2、发送心跳包</h4><p><code>Replicator</code>作为一个<code>ThreadId</code>，需要继承内部类<code>Thread.OnError</code>，心跳被作为一种超时异常处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeartbeatTimer</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> startMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> dueTime = startMs + <span class="keyword">this</span>.options.getDynamicHeartBeatTimeoutMs();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.heartbeatTimer = <span class="keyword">this</span>.timerManager.schedule(() -&gt; onTimeout(<span class="keyword">this</span>.id), dueTime - Utils.nowMs(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">        onTimeout(<span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onTimeout</span><span class="params">(<span class="keyword">final</span> ThreadId id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span>) &#123;</span><br><span class="line">        id.setError(RaftError.ETIMEDOUT.getNumber());<span class="comment">//调用r.onError()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;&#125;<span class="comment">//LOG</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> ThreadId id, <span class="keyword">final</span> Object data, <span class="keyword">final</span> <span class="keyword">int</span> errorCode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (errorCode == RaftError.ETIMEDOUT.getNumber()) &#123;</span><br><span class="line">            id.unlock();</span><br><span class="line">            Utils.runInThread(() -&gt; sendHeartbeat(id));</span><br><span class="line">    &#125;<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>raft算法把心跳包也作为AppendEntries行为，也就是Follower将它视为日志消息，但可以不做处理直接返回。上面<code>sendHeartbeat</code>调用的是与id对应的<code>sendEmptyEntries</code>。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendEmptyEntries</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isHeartbeat,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> RpcResponseClosure&lt;AppendEntriesResponse&gt; heartBeatClosure)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AppendEntriesRequest.Builder rb = AppendEntriesRequest.newBuilder();</span><br><span class="line">    <span class="keyword">if</span> (!fillCommonFields(rb, <span class="keyword">this</span>.nextIndex - <span class="number">1</span>, isHeartbeat)) &#123;<span class="comment">//填充term、groupId、lastCommittedIndex</span></span><br><span class="line">        <span class="comment">//心跳不需要installSnapshot，暂时不管</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> monotonicSendTimeMs = Utils.monotonicMs();<span class="comment">//最近一次发送时间</span></span><br><span class="line">        <span class="keyword">final</span> AppendEntriesRequest request = rb.build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isHeartbeat) &#123;</span><br><span class="line">            <span class="keyword">this</span>.heartbeatCounter++;</span><br><span class="line">            RpcResponseClosure&lt;AppendEntriesResponse&gt; heartbeatDone;</span><br><span class="line">            <span class="keyword">if</span> (heartBeatClosure != <span class="keyword">null</span>) &#123;</span><br><span class="line">                heartbeatDone = heartBeatClosure;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                heartbeatDone = <span class="keyword">new</span> RpcResponseClosureAdapter&lt;AppendEntriesResponse&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Status status)</span> </span>&#123;</span><br><span class="line">                        onHeartbeatReturned(Replicator.<span class="keyword">this</span>.id, status, request, getResponse(), monotonicSendTimeMs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.heartbeatInFly = <span class="keyword">this</span>.rpcService.appendEntries(<span class="keyword">this</span>.options.getPeerId().getEndpoint(), request,</span><br><span class="line">                <span class="keyword">this</span>.options.getElectionTimeoutMs() / <span class="number">2</span>, heartbeatDone);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送探测请求，后面说</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.id.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 回过头看Follower的<code>NodeImpl.handleAppendEntriesRequest</code>是如何处理heartbeat的。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">handleAppendEntriesRequest</span><span class="params">(<span class="keyword">final</span> AppendEntriesRequest request, <span class="keyword">final</span> RpcRequestClosure done)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startMs = Utils.monotonicMs();</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> entriesCount = request.getEntriesCount();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送heartbeat的Leader已经过时了</span></span><br><span class="line">        <span class="keyword">if</span> (request.getTerm() &lt; <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">            <span class="keyword">return</span> AppendEntriesResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                .setSuccess(<span class="keyword">false</span>) <span class="comment">//</span></span><br><span class="line">                .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">//</span></span><br><span class="line">                .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查heartbeat是否来自新上任Leader，如果是，则调用stepDown并重新设置new leader</span></span><br><span class="line">        checkStepDown(request.getTerm(), serverId);<span class="comment">//serverId.parse(request.getServerId())</span></span><br><span class="line">        <span class="keyword">if</span> (!serverId.equals(<span class="keyword">this</span>.leaderId)) &#123;</span><br><span class="line">            <span class="comment">//在成员变化时有可能出现两个同样任期的Leader，只需要term+1就可让两个leader下线，重新选举</span></span><br><span class="line">            stepDown(request.getTerm() + <span class="number">1</span>, <span class="keyword">false</span>, <span class="keyword">new</span> Status(RaftError.ELEADERCONFLICT,</span><br><span class="line">                <span class="string">"More than one leader in the same term."</span>));</span><br><span class="line">            <span class="keyword">return</span> AppendEntriesResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                .setSuccess(<span class="keyword">false</span>) <span class="comment">//</span></span><br><span class="line">                .setTerm(request.getTerm() + <span class="number">1</span>) <span class="comment">//</span></span><br><span class="line">                .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        updateLastLeaderTimestamp(Utils.monotonicMs());<span class="comment">//心跳成功更新时间</span></span><br><span class="line">        <span class="comment">//安装或加载快照会让follower阻塞日志复制，防止快照覆盖新的commit</span></span><br><span class="line">        <span class="keyword">if</span> (entriesCount &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.snapshotExecutor != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.snapshotExecutor.isInstallingSnapshot()) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcResponseFactory.newResponse(RaftError.EBUSY, <span class="string">"Node %s:%s is installing snapshot."</span>,</span><br><span class="line">                <span class="keyword">this</span>.groupId, <span class="keyword">this</span>.serverId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里证明follower日志落后于Leader</span></span><br><span class="line"><span class="comment">         * 因为走到这里只有request.getTerm() = this.currTerm</span></span><br><span class="line"><span class="comment">         * 所以localPrevLogTerm &lt;= this.currTerm</span></span><br><span class="line"><span class="comment">         * 如果prevLogIndex &gt; lastLogIndex, 说明localPrevLogTerm=0，RocksDB未把日志刷盘，机器挂了，丢失最近一部分数据</span></span><br><span class="line"><span class="comment">         * 如果prevLogIndex &lt; lastLogIndex，说明localPrevLogTerm!=0 &amp;&amp; localPrevLogTerm &lt; prevLogTerm，日志属于过期Leader，需要保证强一致性，每行日志的term&amp;logIndex必须一致</span></span><br><span class="line"><span class="comment">         * 第二种情况，会在长期网络分区后出现</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> prevLogIndex = request.getPrevLogIndex();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> prevLogTerm = request.getPrevLogTerm();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> localPrevLogTerm = <span class="keyword">this</span>.logManager.getTerm(prevLogIndex);</span><br><span class="line">        <span class="keyword">if</span> (localPrevLogTerm != prevLogTerm) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> lastLogIndex = <span class="keyword">this</span>.logManager.getLastLogIndex();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> AppendEntriesResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                .setSuccess(<span class="keyword">false</span>) <span class="comment">//</span></span><br><span class="line">                .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">//</span></span><br><span class="line">                .setLastLogIndex(lastLogIndex) <span class="comment">//</span></span><br><span class="line">                .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entriesCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// heartbeat</span></span><br><span class="line">            <span class="keyword">final</span> AppendEntriesResponse.Builder respBuilder = AppendEntriesResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                .setSuccess(<span class="keyword">true</span>) <span class="comment">//</span></span><br><span class="line">                .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">//</span></span><br><span class="line">                .setLastLogIndex(<span class="keyword">this</span>.logManager.getLastLogIndex());</span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">            <span class="comment">// see the comments at FollowerStableClosure#run()</span></span><br><span class="line">            <span class="keyword">this</span>.ballotBox.setLastCommittedIndex(Math.min(request.getCommittedIndex(), prevLogIndex));</span><br><span class="line">            <span class="keyword">return</span> respBuilder.build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里有balabala，跟日志复制有关的一堆代码下面再说</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 可以看到follower对心跳也做了一波处理。第一步，先校验对方或自己是否是合格Leader，否就让对方或自己下线；第二步，第一步正常就证明对方是一个合格的Leader以及自己是合格的Follower，那么校验双方的日志是否一致；前面一切正常了，再更新lastCommittedIndex，后面的日志同步会用到。</p><p> 来看看Leader收到heartbeat回复后怎么处理.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onHeartbeatReturned</span><span class="params">(<span class="keyword">final</span> ThreadId id, <span class="keyword">final</span> Status status, <span class="keyword">final</span> AppendEntriesRequest request, <span class="keyword">final</span> AppendEntriesResponse response, <span class="keyword">final</span> <span class="keyword">long</span> rpcSendTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTimeMs = Utils.nowMs();</span><br><span class="line">    Replicator r;</span><br><span class="line">    <span class="keyword">if</span> ((r = (Replicator) id.lock()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//网络通讯异常</span></span><br><span class="line">        <span class="keyword">if</span> (!status.isOk()) &#123;</span><br><span class="line">            r.state = State.Probe;</span><br><span class="line">            notifyReplicatorStatusListener(r, ReplicatorEvent.ERROR, status);</span><br><span class="line">            <span class="keyword">if</span> (++r.consecutiveErrorTimes % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            r.startHeartbeatTimer(startTimeMs);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r.consecutiveErrorTimes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (response.getTerm() &gt; r.options.getTerm()) &#123;</span><br><span class="line">            <span class="keyword">final</span> NodeImpl node = r.options.getNode();</span><br><span class="line">            r.notifyOnCaughtUp(RaftError.EPERM.getNumber(), <span class="keyword">true</span>);<span class="comment">//新节点追赶上集群，以后成员变化会说到</span></span><br><span class="line">            r.destroy();<span class="comment">//Leader不接受任期比自己大，increaseTermTo下线</span></span><br><span class="line">            node.increaseTermTo(response.getTerm(), <span class="keyword">new</span> Status(RaftError.EHIGHERTERMRESPONSE,</span><br><span class="line">                <span class="string">"Leader receives higher term heartbeat_response from peer:%s"</span>, r.options.getPeerId()));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!response.getSuccess() &amp;&amp; response.hasLastLogIndex()) &#123;</span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            r.sendEmptyEntries(<span class="keyword">false</span>);<span class="comment">//日志有异常，做AppendEntries的探测请求，对应上面Follower日志校验的逻辑</span></span><br><span class="line">            r.startHeartbeatTimer(startTimeMs);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpcSendTime &gt; r.lastRpcSendTimestamp) &#123;</span><br><span class="line">            <span class="comment">//如果Leader频繁写入，那么更新last send time多数在onAppendEntriesReturned</span></span><br><span class="line">            r.lastRpcSendTimestamp = rpcSendTime;</span><br><span class="line">        &#125;</span><br><span class="line">        r.startHeartbeatTimer(startTimeMs);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            id.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>心跳包的代码基本就这些，heartbeat为了不重复发送选择定时而非周期Timer，直到收到响应后再次计时发送。</p><h4 id="2-3、AppendEntries要开始了么？"><a href="#2-3、AppendEntries要开始了么？" class="headerlink" title="2.3、AppendEntries要开始了么？"></a>2.3、AppendEntries要开始了么？</h4><p>日志复制可以说是绕得一批，我刚开始想当然，后来发现不是那样，很是疯狂。完全理清后，画个图比较直观。<br><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E5%BE%AA%E7%8E%AF2.png" alt="日志复制请求响应循环"></p><p>日志复制是一个请求响应自循环，最开始有<code>start()</code>调用<code>sendEmptyEntries(false)</code>做一次探测请求后正式启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendEmptyEntries</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isHeartbeat)</span> </span>&#123;</span><br><span class="line">    sendEmptyEntries(isHeartbeat, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendEmptyEntries</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isHeartbeat,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> RpcResponseClosure&lt;AppendEntriesResponse&gt; heartBeatClosure)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AppendEntriesRequest.Builder rb = AppendEntriesRequest.newBuilder();</span><br><span class="line">    <span class="keyword">if</span> (!fillCommonFields(rb, <span class="keyword">this</span>.nextIndex - <span class="number">1</span>, isHeartbeat)) &#123;</span><br><span class="line">        <span class="comment">// id is unlock in installSnapshot</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> monotonicSendTimeMs = Utils.monotonicMs();</span><br><span class="line">        <span class="keyword">final</span> AppendEntriesRequest request = rb.build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isHeartbeat) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Sending a probe request.</span></span><br><span class="line">            <span class="keyword">this</span>.statInfo.runningState = RunningState.APPENDING_ENTRIES;</span><br><span class="line">            <span class="keyword">this</span>.statInfo.firstLogIndex = <span class="keyword">this</span>.nextIndex;</span><br><span class="line">            <span class="keyword">this</span>.statInfo.lastLogIndex = <span class="keyword">this</span>.nextIndex - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.appendEntriesCounter++;</span><br><span class="line">            <span class="keyword">this</span>.state = State.Probe;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> stateVersion = <span class="keyword">this</span>.version;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> seq = getAndIncrementReqSeq();<span class="comment">//currseq=seq; seq++; return currseq;</span></span><br><span class="line">            <span class="keyword">final</span> Future&lt;Message&gt; rpcFuture = <span class="keyword">this</span>.rpcService.appendEntries(<span class="keyword">this</span>.options.getPeerId().getEndpoint(),</span><br><span class="line">                request, -<span class="number">1</span>, <span class="keyword">new</span> RpcResponseClosureAdapter&lt;AppendEntriesResponse&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Status status)</span> </span>&#123;</span><br><span class="line">                        onRpcReturned(Replicator.<span class="keyword">this</span>.id, RequestType.AppendEntries, status, request,</span><br><span class="line">                            getResponse(), seq, stateVersion, monotonicSendTimeMs);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            addInflight(RequestType.AppendEntries, <span class="keyword">this</span>.nextIndex, <span class="number">0</span>, <span class="number">0</span>, seq, rpcFuture);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.id.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>探测请求没什么好说的，值得注意的是onHeartbeatReturned是有可能触发该探测的。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onRpcReturned</span><span class="params">(<span class="keyword">final</span> ThreadId id, <span class="keyword">final</span> RequestType reqType, <span class="keyword">final</span> Status status, <span class="keyword">final</span> Message request,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">final</span> Message response, <span class="keyword">final</span> <span class="keyword">int</span> seq, <span class="keyword">final</span> <span class="keyword">int</span> stateVersion, <span class="keyword">final</span> <span class="keyword">long</span> rpcSendTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTimeMs = Utils.nowMs();</span><br><span class="line">    Replicator r;</span><br><span class="line">    <span class="keyword">if</span> ((r = (Replicator) id.lock()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stateVersion != r.version) &#123;</span><br><span class="line">        id.unlock();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要花点时间解释这个根据seq优先队列的用处</span></span><br><span class="line">    <span class="comment">//首先要知道raft强调日志必须顺序一致的，任何并发调用onRpcReturned都可能打乱复制顺序</span></span><br><span class="line">    <span class="comment">//假设现在this.reqSeq=3, requiredNextSeq=2，我们正在等待的reqSeq=2的响应由于种种原因还没到来</span></span><br><span class="line">    <span class="comment">//此时某次心跳onHeartbeatReturned触发了sendEmptyEntries(false)，将reqSeq改为4，也就说seq=3，而且该探测请求很快被响应且调用该方法</span></span><br><span class="line">    <span class="comment">//后来先到的response会被先hold到pendingResponses</span></span><br><span class="line">    <span class="keyword">final</span> PriorityQueue&lt;RpcResponse&gt; holdingQueue = r.pendingResponses;</span><br><span class="line">    holdingQueue.add(<span class="keyword">new</span> RpcResponse(reqType, seq, status, request, response, rpcSendTime));</span><br><span class="line">    <span class="comment">//某个优先级更高的请求还没被回复，需要做一次探测请求</span></span><br><span class="line">    <span class="keyword">if</span> (holdingQueue.size() &gt; r.raftOptions.getMaxReplicatorInflightMsgs()) &#123;</span><br><span class="line">        r.resetInflights();</span><br><span class="line">        r.state = State.Probe;</span><br><span class="line">        r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> continueSendEntries = <span class="keyword">false</span>;<span class="comment">//是否要继续上图虚线框内的Loop</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> processed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!holdingQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">final</span> RpcResponse queuedPipelinedResponse = holdingQueue.peek();<span class="comment">//优先级最高的响应</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据requiredNextSeq，还有更高优先级的响应未到，仍需等待</span></span><br><span class="line">            <span class="keyword">if</span> (queuedPipelinedResponse.seq != r.requiredNextSeq) &#123;</span><br><span class="line">                <span class="keyword">if</span> (processed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//前面还有processed已经成功处理，可能会调用sendEntries()，所以break即可</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//优先级最高的请求会被响应，所以直接返回unlock</span></span><br><span class="line">                    continueSendEntries = <span class="keyword">false</span>;</span><br><span class="line">                    id.unlock();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            holdingQueue.remove();</span><br><span class="line">            processed++;</span><br><span class="line">            <span class="keyword">final</span> Inflight inflight = r.pollInflight();</span><br><span class="line">            <span class="keyword">if</span> (inflight == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// The previous in-flight requests were cleared</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//我这里没想明白什么情况会出现queuedPipelinedResponse.seq==r.requiredNextSeq且!=inflight.seq</span></span><br><span class="line">            <span class="keyword">if</span> (inflight.seq != queuedPipelinedResponse.seq) &#123;</span><br><span class="line">                <span class="comment">// reset state</span></span><br><span class="line">                r.resetInflights();</span><br><span class="line">                r.state = State.Probe;</span><br><span class="line">                continueSendEntries = <span class="keyword">false</span>;</span><br><span class="line">                r.block(Utils.nowMs(), RaftError.EREQUEST.getNumber());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (queuedPipelinedResponse.requestType) &#123;</span><br><span class="line">                    <span class="keyword">case</span> AppendEntries:</span><br><span class="line">                        continueSendEntries = onAppendEntriesReturned(id, inflight, queuedPipelinedResponse.status,</span><br><span class="line">                            (AppendEntriesRequest) queuedPipelinedResponse.request,</span><br><span class="line">                            (AppendEntriesResponse) queuedPipelinedResponse.response, rpcSendTime, startTimeMs, r);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Snapshot:</span><br><span class="line">                        continueSendEntries = onInstallSnapshotReturned(id, r, queuedPipelinedResponse.status,</span><br><span class="line">                            (InstallSnapshotRequest) queuedPipelinedResponse.request,</span><br><span class="line">                            (InstallSnapshotResponse) queuedPipelinedResponse.response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (continueSendEntries) &#123;</span><br><span class="line">                    <span class="comment">// Success, increase the response sequence.</span></span><br><span class="line">                    r.getAndIncrementRequiredNextSeq();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// The id is already unlocked in onAppendEntriesReturned/onInstallSnapshotReturned, we SHOULD break out.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (continueSendEntries) &#123;</span><br><span class="line">            <span class="comment">// unlock in sendEntries.</span></span><br><span class="line">            r.sendEntries();<span class="comment">//继续日志复制循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onRpcReturned</code>的主要功能在严格控制Leader处理请求-响应的顺序，避免乱序提交带来的数据不一致。</p><p>顺序校验后，轮到<code>onAppendEntriesReturned</code>了，它主要两个功能。<br>一个是校验<code>Replicator.nextIndex-1</code>与Follower.lastLogIndex是否一致，若否，则矫正；第二个，对已经复制成功的LogEntity反馈给<code>BallotBox</code>，quorum–。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">onAppendEntriesReturned</span><span class="params">(<span class="keyword">final</span> ThreadId id, <span class="keyword">final</span> Inflight inflight, <span class="keyword">final</span> Status status,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">final</span> AppendEntriesRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">final</span> AppendEntriesResponse response, <span class="keyword">final</span> <span class="keyword">long</span> rpcSendTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">final</span> <span class="keyword">long</span> startTimeMs, <span class="keyword">final</span> Replicator r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里我也没想明白满足(queuedPipelinedResponse.seq==r.requiredNextSeq &amp;&amp; queuedPipelinedResponse.seq==inflight.seq)，什么场景会出现不相等</span></span><br><span class="line">    <span class="keyword">if</span> (inflight.startIndex != request.getPrevLogIndex() + <span class="number">1</span>) &#123;</span><br><span class="line">        r.resetInflights();</span><br><span class="line">        r.state = State.Probe;</span><br><span class="line">        <span class="comment">// unlock id in sendEmptyEntries</span></span><br><span class="line">        r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!status.isOk()) &#123;   <span class="comment">//follower挂了，快速失败，且阻塞一小段时间，停止日志复制</span></span><br><span class="line">        notifyReplicatorStatusListener(r, ReplicatorEvent.ERROR, status);</span><br><span class="line">        <span class="keyword">if</span> (++r.consecutiveErrorTimes % <span class="number">10</span> == <span class="number">0</span>) &#123;&#125;</span><br><span class="line">        r.resetInflights();</span><br><span class="line">        r.state = State.Probe;</span><br><span class="line">        <span class="comment">// unlock in in block</span></span><br><span class="line">        r.block(startTimeMs, status.getCode());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r.consecutiveErrorTimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!response.getSuccess()) &#123;<span class="comment">//这个也不说了</span></span><br><span class="line">        <span class="keyword">if</span> (response.getTerm() &gt; r.options.getTerm()) &#123;</span><br><span class="line">            <span class="keyword">final</span> NodeImpl node = r.options.getNode();</span><br><span class="line">            r.notifyOnCaughtUp(RaftError.EPERM.getNumber(), <span class="keyword">true</span>);</span><br><span class="line">            r.destroy();</span><br><span class="line">            node.increaseTermTo(response.getTerm(), <span class="keyword">new</span> Status(RaftError.EHIGHERTERMRESPONSE,</span><br><span class="line">                <span class="string">"Leader receives higher term heartbeat_response from peer:%s"</span>, r.options.getPeerId()));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//能走到这一步，说明任期没问题，但LogIndex有出入</span></span><br><span class="line">        <span class="keyword">if</span> (rpcSendTime &gt; r.lastRpcSendTimestamp) &#123;</span><br><span class="line">            r.lastRpcSendTimestamp = rpcSendTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除所有准备发送的LogEntity</span></span><br><span class="line">        r.resetInflights();</span><br><span class="line">        <span class="comment">// 在[2.2、发送心跳包]那里handleAppendEntriesRequest有一大段注释，对应着看</span></span><br><span class="line">        <span class="keyword">if</span> (response.getLastLogIndex() + <span class="number">1</span> &lt; r.nextIndex) &#123;</span><br><span class="line">            <span class="comment">// The peer contains less logs than leader</span></span><br><span class="line">            r.nextIndex = response.getLastLogIndex() + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//逐一往回追溯，直到有term&amp;LogIndex对应上的nextIndex</span></span><br><span class="line">            <span class="keyword">if</span> (r.nextIndex &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                r.nextIndex--; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// LOG.error</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dummy_id is unlock in _send_heartbeat</span></span><br><span class="line">        r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// success，有可能Leader重新选举又赢了</span></span><br><span class="line">    <span class="keyword">if</span> (response.getTerm() != r.options.getTerm()) &#123;</span><br><span class="line">        r.resetInflights();</span><br><span class="line">        r.state = State.Probe;</span><br><span class="line">        id.unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rpcSendTime &gt; r.lastRpcSendTimestamp) &#123;</span><br><span class="line">        r.lastRpcSendTimestamp = rpcSendTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> entriesSize = request.getEntriesCount();</span><br><span class="line">    <span class="keyword">if</span> (entriesSize &gt; <span class="number">0</span>) &#123; <span class="comment">//这是一次复制请求的响应</span></span><br><span class="line">        <span class="keyword">if</span> (r.options.getReplicatorType().isFollower()) &#123;</span><br><span class="line">            r.options.getBallotBox().commitAt(r.nextIndex, r.nextIndex + entriesSize - <span class="number">1</span>, r.options.getPeerId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The request is probe request, change the state into Replicate.</span></span><br><span class="line">        r.state = State.Replicate;</span><br><span class="line">    &#125;</span><br><span class="line">    r.nextIndex += entriesSize;<span class="comment">//增加已经复制的偏移量</span></span><br><span class="line">    r.hasSucceeded = <span class="keyword">true</span>;</span><br><span class="line">    r.notifyOnCaughtUp(RaftError.SUCCESS.getNumber(), <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// dummy_id is unlock in _send_entries</span></span><br><span class="line">    <span class="keyword">if</span> (r.timeoutNowIndex &gt; <span class="number">0</span> &amp;&amp; r.timeoutNowIndex &lt; r.nextIndex) &#123;</span><br><span class="line">        r.sendTimeoutNow(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//继续日志复制循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发送日志就不说什么了，思路很清晰，整个过程如上图，是个自循环。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> prevSendIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> nextSendingIndex = getNextSendIndex();<span class="comment">//获取未被发送LogIndex</span></span><br><span class="line">            <span class="keyword">if</span> (nextSendingIndex &gt; prevSendIndex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sendEntries(nextSendingIndex)) &#123;</span><br><span class="line">                    prevSendIndex = nextSendingIndex;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    doUnlock = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.id.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">sendEntries</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> nextSendingIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AppendEntriesRequest.Builder rb = AppendEntriesRequest.newBuilder();</span><br><span class="line">    <span class="keyword">if</span> (!fillCommonFields(rb, nextSendingIndex - <span class="number">1</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// unlock id in installSnapshot</span></span><br><span class="line">        installSnapshot();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteBufferCollector dataBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxEntriesSize = <span class="keyword">this</span>.raftOptions.getMaxEntriesSize();</span><br><span class="line">    <span class="keyword">final</span> RecyclableByteBufferList byteBufList = RecyclableByteBufferList.newInstance();<span class="comment">//一个ThreadLocalList</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxEntriesSize; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> RaftOutter.EntryMeta.Builder emb = RaftOutter.EntryMeta.newBuilder();</span><br><span class="line">            <span class="comment">//(byteBufList长度超过maxBodySize || nextSendingIndex+i找不到新日志) 返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!prepareEntry(nextSendingIndex, i, emb, byteBufList)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rb.addEntries(emb.build());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rb.getEntriesCount() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//进行过快照，日志已被删除，即刻安装快照</span></span><br><span class="line">            <span class="keyword">if</span> (nextSendingIndex &lt; <span class="keyword">this</span>.options.getLogManager().getFirstLogIndex()) &#123;</span><br><span class="line">                installSnapshot();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有更多日志了，等待LogManagerImpl#appendEntries的通知</span></span><br><span class="line">            waitMoreEntries(nextSendingIndex);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (byteBufList.getCapacity() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dataBuf = ByteBufferCollector.allocateByRecyclers(byteBufList.getCapacity());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> ByteBuffer b : byteBufList) &#123;</span><br><span class="line">                dataBuf.put(b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> ByteBuffer buf = dataBuf.getBuffer();</span><br><span class="line">            buf.flip();</span><br><span class="line">            rb.setData(ZeroByteStringHelper.wrap(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        RecycleUtil.recycle(byteBufList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AppendEntriesRequest request = rb.build();</span><br><span class="line">    <span class="keyword">this</span>.statInfo.runningState = RunningState.APPENDING_ENTRIES;</span><br><span class="line">    <span class="keyword">this</span>.statInfo.firstLogIndex = rb.getPrevLogIndex() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.statInfo.lastLogIndex = rb.getPrevLogIndex() + rb.getEntriesCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Recyclable recyclable = dataBuf;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> v = <span class="keyword">this</span>.version;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> monotonicSendTimeMs = Utils.monotonicMs();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> seq = getAndIncrementReqSeq();</span><br><span class="line">    <span class="keyword">final</span> Future&lt;Message&gt; rpcFuture = <span class="keyword">this</span>.rpcService.appendEntries(<span class="keyword">this</span>.options.getPeerId().getEndpoint(),</span><br><span class="line">        request, -<span class="number">1</span>, <span class="keyword">new</span> RpcResponseClosureAdapter&lt;AppendEntriesResponse&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Status status)</span> </span>&#123;</span><br><span class="line">                RecycleUtil.recycle(recyclable);</span><br><span class="line">                onRpcReturned(Replicator.<span class="keyword">this</span>.id, RequestType.AppendEntries, status, request, getResponse(), seq,</span><br><span class="line">                    v, monotonicSendTimeMs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    addInflight(RequestType.AppendEntries, nextSendingIndex, request.getEntriesCount(), request.getData().size(),</span><br><span class="line">        seq, rpcFuture);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 最后再来看Follower怎么处理AppendEntriesRequest，如果前面校验过了的话，就开始执行下面部分代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">handleAppendEntriesRequest</span><span class="params">(<span class="keyword">final</span> AppendEntriesRequest request, <span class="keyword">final</span> RpcRequestClosure done)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startMs = Utils.monotonicMs();</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> entriesCount = request.getEntriesCount();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//balabala，前面已经说过了</span></span><br><span class="line">        <span class="comment">// Parse request</span></span><br><span class="line">        <span class="keyword">long</span> index = prevLogIndex;</span><br><span class="line">        <span class="keyword">final</span> List&lt;LogEntry&gt; entries = <span class="keyword">new</span> ArrayList&lt;&gt;(entriesCount);</span><br><span class="line">        ByteBuffer allData = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (request.hasData()) &#123;</span><br><span class="line">            allData = request.getData().asReadOnlyByteBuffer();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> List&lt;RaftOutter.EntryMeta&gt; entriesList = request.getEntriesList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entriesCount; i++) &#123;</span><br><span class="line">            index++;<span class="comment">//LogIndex 偏移量，即系logId = Follower.lastCommittedIndex + index</span></span><br><span class="line">            <span class="keyword">final</span> RaftOutter.EntryMeta entry = entriesList.get(i);</span><br><span class="line">            <span class="keyword">final</span> LogEntry logEntry = logEntryFromMeta(index, allData, entry);<span class="comment">//根据entryLen偏移量截取allData</span></span><br><span class="line">            <span class="keyword">if</span> (logEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Validate checksum</span></span><br><span class="line">                <span class="comment">// return error</span></span><br><span class="line">                entries.add(logEntry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//落盘后调用FollowerStableClosure，给Leader一个响应，request.lastCommittedIndex大于自己，就依序执行状态机提交数据</span></span><br><span class="line">        <span class="keyword">final</span> FollowerStableClosure closure = <span class="keyword">new</span> FollowerStableClosure(request, AppendEntriesResponse.newBuilder()</span><br><span class="line">            .setTerm(<span class="keyword">this</span>.currTerm), <span class="keyword">this</span>, done, <span class="keyword">this</span>.currTerm);</span><br><span class="line">        <span class="keyword">this</span>.logManager.appendEntries(entries, closure);</span><br><span class="line">        <span class="comment">// update configuration after _log_manager updated its memory status</span></span><br><span class="line">        checkAndSetConfiguration(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、何时提交？commit到底有多折腾？"><a href="#3、何时提交？commit到底有多折腾？" class="headerlink" title="3、何时提交？commit到底有多折腾？"></a>3、何时提交？commit到底有多折腾？</h3><p>Leader和Follower提交流程大致如下，最后都会分别执行StateMachine写入client发送的数据，下面LogManager、LogStorage以后单独讲。</p><p><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/commit%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="commit执行状态机"></p><p>我们直接来看Leader调用的<code>BallBox.commitAt()</code>吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">commitAt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> firstLogIndex, <span class="keyword">final</span> <span class="keyword">long</span> lastLogIndex, <span class="keyword">final</span> PeerId peer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO  use lock-free algorithm here?</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> stamp = <span class="keyword">this</span>.stampedLock.writeLock();</span><br><span class="line">    <span class="keyword">long</span> lastCommittedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//选举成功后默认lastLogIndex+1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.pendingIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastLogIndex &lt; <span class="keyword">this</span>.pendingIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lastLogIndex &gt;= <span class="keyword">this</span>.pendingIndex + <span class="keyword">this</span>.pendingMetaQueue.size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> startAt = Math.max(<span class="keyword">this</span>.pendingIndex, firstLogIndex);</span><br><span class="line">        Ballot.PosHint hint = <span class="keyword">new</span> Ballot.PosHint();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> logIndex = startAt; logIndex &lt;= lastLogIndex; logIndex++) &#123;</span><br><span class="line">            <span class="keyword">final</span> Ballot bl = <span class="keyword">this</span>.pendingMetaQueue.get((<span class="keyword">int</span>) (logIndex - <span class="keyword">this</span>.pendingIndex));<span class="comment">//队列偏移量</span></span><br><span class="line">            hint = bl.grant(peer, hint);</span><br><span class="line">            <span class="keyword">if</span> (bl.isGranted()) &#123;</span><br><span class="line">                lastCommittedIndex = logIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastCommittedIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//没有任何提交的日志</span></span><br><span class="line">        &#125;<span class="comment">//这一段我没能理解</span></span><br><span class="line">        <span class="comment">// When removing a peer off the raft group which contains even number of</span></span><br><span class="line">        <span class="comment">// peers, the quorum would decrease by 1, e.g. 3 of 4 changes to 2 of 3. In</span></span><br><span class="line">        <span class="comment">// this case, the log after removal may be committed before some previous</span></span><br><span class="line">        <span class="comment">// logs, since we use the new configuration to deal the quorum of the</span></span><br><span class="line">        <span class="comment">// removal request, we think it's safe to commit all the uncommitted</span></span><br><span class="line">        <span class="comment">// previous logs, which is not well proved right now</span></span><br><span class="line">        <span class="keyword">this</span>.pendingMetaQueue.removeFromFirst((<span class="keyword">int</span>) (lastCommittedIndex - <span class="keyword">this</span>.pendingIndex) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.pendingIndex = lastCommittedIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.lastCommittedIndex = lastCommittedIndex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.stampedLock.unlockWrite(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.waiter.onCommitted(lastCommittedIndex);<span class="comment">//执行状态机</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Follower就更简单了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setLastCommittedIndex</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> lastCommittedIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> stamp = <span class="keyword">this</span>.stampedLock.writeLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//只有leader才会初始化pendingIndex</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.pendingIndex != <span class="number">0</span> || !<span class="keyword">this</span>.pendingMetaQueue.isEmpty()) &#123;</span><br><span class="line">            Requires.requireTrue(lastCommittedIndex &lt; <span class="keyword">this</span>.pendingIndex,</span><br><span class="line">                <span class="string">"Node changes to leader, pendingIndex=%d, param lastCommittedIndex=%d"</span>, <span class="keyword">this</span>.pendingIndex,</span><br><span class="line">                lastCommittedIndex);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastCommittedIndex &lt; <span class="keyword">this</span>.lastCommittedIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastCommittedIndex &gt; <span class="keyword">this</span>.lastCommittedIndex) &#123;</span><br><span class="line">            <span class="keyword">this</span>.lastCommittedIndex = lastCommittedIndex;</span><br><span class="line">            <span class="keyword">this</span>.stampedLock.unlockWrite(stamp);</span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.waiter.onCommitted(lastCommittedIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stampedLock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行状态机那一块其实没什么好讲的，属于完全正常的流程，可自行阅读源码。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> CAP理论 </tag>
            
            <tag> RAFT算法 </tag>
            
            <tag> 分布式一致性 </tag>
            
            <tag> BRAFT </tag>
            
            <tag> JRaft </tag>
            
            <tag> 选举算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JRaft源码分析01】启用以及选举过程</title>
      <link href="/2020/03/21/20200328-%E3%80%90JRaft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9001%E3%80%91%E5%90%AF%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/03/21/20200328-%E3%80%90JRaft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9001%E3%80%91%E5%90%AF%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>最近潜心cap理论和raft算法，选用了蚂蚁金服的sofa-jraft，深入研究具体的实现。该框架参考自百度的BRAFT，可以说是非常优秀的分布式通用框架，很值得学习。</p><hr><p>Raft算法的理论就不再多说了，感性认识的话可以看这个<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">动画</a>，非常好懂。</p><h3 id="1、启动入口"><a href="#1、启动入口" class="headerlink" title="1、启动入口"></a>1、启动入口</h3><p>示例在github的<a href="https://github.com/zehonghuang/sofa-jraft/tree/master/jraft-example" target="_blank" rel="noopener">jraft-example</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RaftGroupService raftGroupService = <span class="keyword">new</span> RaftGroupService(groupId, serverId, nodeOptions, rpcServer);</span><br><span class="line"><span class="comment">//依次实例化NodeManager、NodeImpl、RpcServer</span></span><br><span class="line">Node node = raftGroupService.start();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Node <span class="title">start</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> startRpcServer)</span> </span>&#123;</span><br><span class="line">    NodeManager.getInstance().addAddress(<span class="keyword">this</span>.serverId.getEndpoint());</span><br><span class="line">    <span class="keyword">this</span>.node = RaftServiceFactory.createAndInitRaftNode(<span class="keyword">this</span>.groupId, <span class="keyword">this</span>.serverId, <span class="keyword">this</span>.nodeOptions);</span><br><span class="line">    <span class="keyword">if</span> (startRpcServer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.rpcServer.startup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、包罗万象的Node"><a href="#2、包罗万象的Node" class="headerlink" title="2、包罗万象的Node"></a>2、包罗万象的Node</h3><p>分布式系统关键单体就是节点Node，它包括raft分布式算法中需要的所有行为，不限于选举、投票、日志、复制、接收rpc请求等，梦开始的地方。</p><p><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/Node%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Node结构图"></p><p>jraft也是遵循这个思路，所以<code>NodeImpl</code>包含了众多核心逻辑，先看一下初始化了什么内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> NodeOptions opts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.electionTimeoutCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定时器，后面heartbeat、block会有用到</span></span><br><span class="line">    <span class="keyword">this</span>.timerManager = <span class="keyword">new</span> TimerManager();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.timerManager.init(<span class="keyword">this</span>.options.getTimerPoolSize())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Init timers</span></span><br><span class="line">    <span class="keyword">final</span> String suffix = getNodeId().toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如上图所说，下面依次是投票计时器、选举计时器、下线计时器、快照计时器</span></span><br><span class="line">    <span class="keyword">this</span>.voteTimer = <span class="keyword">new</span> RepeatedTimer(<span class="string">"JRaft-VoteTimer-"</span> + suffix, <span class="keyword">this</span>.options.getElectionTimeoutMs()) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onTrigger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            handleVoteTimeout();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在一定范围内的随机超时时间</span></span><br><span class="line">        <span class="comment">//adjustTimeout -&gt; randomTimeout()</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.electionTimer = <span class="keyword">new</span> RepeatedTimer(<span class="string">"JRaft-ElectionTimer-"</span> + suffix, <span class="keyword">this</span>.options.getElectionTimeoutMs()) &#123;</span><br><span class="line">        <span class="comment">//onTrigger -&gt; handleElectionTimeout()</span></span><br><span class="line">        <span class="comment">//adjustTimeout -&gt; randomTimeout()</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.stepDownTimer = <span class="keyword">new</span> RepeatedTimer(<span class="string">"JRaft-StepDownTimer-"</span> + suffix,</span><br><span class="line">        <span class="keyword">this</span>.options.getElectionTimeoutMs() &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//onTrigger -&gt; handleStepDownTimeout()</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.snapshotTimer = <span class="keyword">new</span> RepeatedTimer(<span class="string">"JRaft-SnapshotTimer-"</span> + suffix,</span><br><span class="line">        <span class="keyword">this</span>.options.getSnapshotIntervalSecs() * <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="comment">//onTrigger -&gt; handleSnapshotTimeout()</span></span><br><span class="line">        <span class="comment">//adjustTimeout -&gt; 赋值逻辑不一样，说到快照再提</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.configManager = <span class="keyword">new</span> ConfigurationManager();</span><br><span class="line">    <span class="comment">//单线程处理来自apply()的Task，核心处理方法在LogEntryAndClosureHandler -&gt; onEvent -&gt; executeApplyingTasks()</span></span><br><span class="line">    <span class="keyword">this</span>.applyDisruptor = DisruptorBuilder.&lt;LogEntryAndClosure&gt; newInstance() </span><br><span class="line">        .setRingBufferSize(<span class="keyword">this</span>.raftOptions.getDisruptorBufferSize()) </span><br><span class="line">        .setEventFactory(<span class="keyword">new</span> LogEntryAndClosureFactory()) </span><br><span class="line">        .setThreadFactory(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"JRaft-NodeImpl-Disruptor-"</span>, <span class="keyword">true</span>)) </span><br><span class="line">        .setProducerType(ProducerType.MULTI) </span><br><span class="line">        .setWaitStrategy(<span class="keyword">new</span> BlockingWaitStrategy()) </span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">this</span>.applyDisruptor.handleEventsWith(<span class="keyword">new</span> LogEntryAndClosureHandler());</span><br><span class="line">    <span class="keyword">this</span>.applyDisruptor.setDefaultExceptionHandler(<span class="keyword">new</span> LogExceptionHandler&lt;Object&gt;(getClass().getSimpleName()));</span><br><span class="line">    <span class="keyword">this</span>.applyQueue = <span class="keyword">this</span>.applyDisruptor.start(); <span class="comment">// applyQueue用于接收储存来自apply()的Task</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.metrics.getMetricRegistry() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.metrics.getMetricRegistry().register(<span class="string">"jraft-node-impl-disruptor"</span>,</span><br><span class="line">            <span class="keyword">new</span> DisruptorMetricSet(<span class="keyword">this</span>.applyQueue));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有限状态机</span></span><br><span class="line">    <span class="keyword">this</span>.fsmCaller = <span class="keyword">new</span> FSMCallerImpl();</span><br><span class="line">    <span class="keyword">if</span> (!initLogStorage()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//实例化LogManagerImpl，提供了rocksdb作为日志持久化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!initMetaStorage()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//元数据，存储term、当前vote peerid，不能持久化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!initFSMCaller(<span class="keyword">new</span> LogId(<span class="number">0</span>, <span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//选票箱不是选举用的，在于写入且复制日志后，执行状态机</span></span><br><span class="line">    <span class="keyword">this</span>.ballotBox = <span class="keyword">new</span> BallotBox();</span><br><span class="line">    <span class="keyword">final</span> BallotBoxOptions ballotBoxOpts = <span class="keyword">new</span> BallotBoxOptions();</span><br><span class="line">    ballotBoxOpts.setWaiter(<span class="keyword">this</span>.fsmCaller);</span><br><span class="line">    ballotBoxOpts.setClosureQueue(<span class="keyword">this</span>.closureQueue);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.ballotBox.init(ballotBoxOpts)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!initSnapshotStorage()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//实例化SnapshotExecutorImpl</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Status st = <span class="keyword">this</span>.logManager.checkConsistency();<span class="comment">//检查快照index是否落在first &amp; last log index之内</span></span><br><span class="line">    <span class="keyword">if</span> (!st.isOk()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//管理refactor的</span></span><br><span class="line">    <span class="keyword">this</span>.replicatorGroup = <span class="keyword">new</span> ReplicatorGroupImpl();</span><br><span class="line">    <span class="keyword">this</span>.rpcService = <span class="keyword">new</span> BoltRaftClientService(<span class="keyword">this</span>.replicatorGroup);</span><br><span class="line">    <span class="keyword">final</span> ReplicatorGroupOptions rgOpts = <span class="keyword">new</span> ReplicatorGroupOptions();</span><br><span class="line">    <span class="comment">//rgOpts.set...一堆设置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.rpcService.init(<span class="keyword">this</span>.options)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.replicatorGroup.init(<span class="keyword">new</span> NodeId(<span class="keyword">this</span>.groupId, <span class="keyword">this</span>.serverId), rgOpts);</span><br><span class="line">    <span class="comment">//只读服务，包括readindex也是在这里被调用</span></span><br><span class="line">    <span class="keyword">this</span>.readOnlyService = <span class="keyword">new</span> ReadOnlyServiceImpl();</span><br><span class="line">    <span class="keyword">final</span> ReadOnlyServiceOptions rosOpts = <span class="keyword">new</span> ReadOnlyServiceOptions();</span><br><span class="line">    rosOpts.setFsmCaller(<span class="keyword">this</span>.fsmCaller);</span><br><span class="line">    rosOpts.setNode(<span class="keyword">this</span>);</span><br><span class="line">    rosOpts.setRaftOptions(<span class="keyword">this</span>.raftOptions);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.readOnlyService.init(rosOpts)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set state to follower</span></span><br><span class="line">    <span class="keyword">this</span>.state = State.STATE_FOLLOWER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.snapshotExecutor != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.options.getSnapshotIntervalSecs() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.snapshotTimer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.conf.isEmpty()) &#123;</span><br><span class="line">        stepDown(<span class="keyword">this</span>.currTerm, <span class="keyword">false</span>, <span class="keyword">new</span> Status()); <span class="comment">// 这里是用于节点下线的方法，这里是为了启动选举倒计时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!NodeManager.getInstance().add(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Now the raft node is started , have to acquire the writeLock to avoid race</span></span><br><span class="line">    <span class="comment">//... 还有单点自举的代码，忽略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从初始化代码来看，几乎核心逻辑都交给定时器，以及Disruptor来处理，所以单纯靠debug跟踪是不可能的，需要先了解raft算法逻辑以及每个定时器的作用来人肉跳转。</p><h3 id="3、选举出Leader"><a href="#3、选举出Leader" class="headerlink" title="3、选举出Leader"></a>3、选举出Leader</h3><p>节点启动完成后，会被立即启动ElectionTimer，执行该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleElectionTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state != State.STATE_FOLLOWER) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isCurrentLeaderValid()) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 心跳包会不断更新lastLeaderTimestamp，如果间隔超过electionTimeoutMs，Follower会发起第一轮选举</span></span><br><span class="line">        &#125;</span><br><span class="line">        resetLeaderId(PeerId.emptyPeer(), <span class="keyword">new</span> Status(RaftError.ERAFTTIMEDOUT, <span class="string">"Lost connection from leader %s."</span>,</span><br><span class="line">            <span class="keyword">this</span>.leaderId));</span><br><span class="line">        <span class="comment">// 检查优先级是否允许该节点进行选举</span></span><br><span class="line">        <span class="keyword">if</span> (!allowLaunchElection()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        doUnlock = <span class="keyword">false</span>;</span><br><span class="line">        preVote();  <span class="comment">//开始第一轮投票</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1、Pre-Vote是否有必要"><a href="#3-1、Pre-Vote是否有必要" class="headerlink" title="3.1、Pre-Vote是否有必要"></a>3.1、Pre-Vote是否有必要</h4><p>一般来说，raft的选举仅且只有一轮投票选出集群leader，但会存在缺陷，就是网络分区后，少数派节点虽然都不会得到足够的票数成为分区Leader，但任选编号term却会不断增加，在网络分区恢复，少数派节点会因为term较大，而迫使多数派Leader下线，我们叫他做<code>捣蛋鬼</code>。为了避免<code>捣蛋鬼</code>谋权篡位，我们引入<code>Pre-Vote</code>，只有得到绝大多数选票，才有被提拔为候选人的资格。</p><p>在Diego Ongaro的博士论文<a href="https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf" target="_blank" rel="noopener">《CONSENSUS: BRIDGING THEORY AND PRACTICE》</a>中，有一节较为全面的解释。<br><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/WX20200329-223149%402x.png" alt="9.6 Preventing disruptions when a server rejoins the cluster"></p><p>JRaft也有实现了<code>Pre-Vote</code>，下面来看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preVote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> oldTerm; <span class="comment">// oldTerm = this.currTerm;</span></span><br><span class="line">    <span class="comment">//这里有一段快照 &amp; serverId的校验，then writeLock.unlock();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> LogId lastLogId = <span class="keyword">this</span>.logManager.getLastLogId(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// pre_vote need defense ABA after unlock&amp;writeLock</span></span><br><span class="line">        <span class="keyword">if</span> (oldTerm != <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这一句在计算quorum</span></span><br><span class="line">        <span class="keyword">this</span>.prevVoteCtx.init(<span class="keyword">this</span>.conf.getConf(), <span class="keyword">this</span>.conf.isStable() ? <span class="keyword">null</span> : <span class="keyword">this</span>.conf.getOldConf());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> PeerId peer : <span class="keyword">this</span>.conf.listPeers()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (peer.equals(<span class="keyword">this</span>.serverId)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.rpcService.connect(peer.getEndpoint())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> OnPreVoteRpcDone done = <span class="keyword">new</span> OnPreVoteRpcDone(peer, <span class="keyword">this</span>.currTerm);</span><br><span class="line">            done.request = RequestVoteRequest.newBuilder() <span class="comment">//</span></span><br><span class="line">                .setPreVote(<span class="keyword">true</span>) <span class="comment">// it's a pre-vote request.</span></span><br><span class="line">                .setGroupId(<span class="keyword">this</span>.groupId) <span class="comment">//</span></span><br><span class="line">                .setServerId(<span class="keyword">this</span>.serverId.toString()) <span class="comment">//</span></span><br><span class="line">                .setPeerId(peer.toString()) <span class="comment">//</span></span><br><span class="line">                .setTerm(<span class="keyword">this</span>.currTerm + <span class="number">1</span>) <span class="comment">// next term 这里不用currTerm++，为了不让本地节点term暴增</span></span><br><span class="line">                .setLastLogIndex(lastLogId.getIndex()) <span class="comment">//</span></span><br><span class="line">                .setLastLogTerm(lastLogId.getTerm()) <span class="comment">//</span></span><br><span class="line">                .build();</span><br><span class="line">            <span class="keyword">this</span>.rpcService.preVote(peer.getEndpoint(), done.request, done); <span class="comment">//我们来看处理handlePreVoteRequest()</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.prevVoteCtx.grant(<span class="keyword">this</span>.serverId);<span class="comment">//为自己投一票</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.prevVoteCtx.isGranted()) &#123;</span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            electSelf(); <span class="comment">//假如获取到大于等于quorum票数，则进入下一轮投票</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发出第一轮投票请求后，其他节点随即处理请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">handlePreVoteRequest</span><span class="params">(<span class="keyword">final</span> RequestVoteRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> granted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// noinspection ConstantConditions</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//Leader可用，在租期内发送过心跳包</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.leaderId != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.leaderId.isEmpty() &amp;&amp; isCurrentLeaderValid()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意preVote发送的是currTerm+1，所以要么小于，要么刚好等于</span></span><br><span class="line">            <span class="comment">//如果小于则没资格成为候选人</span></span><br><span class="line">            <span class="keyword">if</span> (request.getTerm() &lt; <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">                <span class="comment">// A follower replicator may not be started when this node become leader, so we must check it.</span></span><br><span class="line">                checkReplicator(candidateId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.getTerm() == <span class="keyword">this</span>.currTerm + <span class="number">1</span>) &#123;</span><br><span class="line">                checkReplicator(candidateId);</span><br><span class="line">            &#125;</span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">            <span class="comment">//若刚好等于，就看看谁的LogIndex更大了</span></span><br><span class="line">            <span class="keyword">final</span> LogId lastLogId = <span class="keyword">this</span>.logManager.getLastLogId(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            doUnlock = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">            <span class="comment">//通常来说，能正常工作的多数派LastLogId更大</span></span><br><span class="line">            <span class="keyword">final</span> LogId requestLastLogId = <span class="keyword">new</span> LogId(request.getLastLogIndex(), request.getLastLogTerm());</span><br><span class="line">            granted = requestLastLogId.compareTo(lastLogId) &gt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//yep， 发送结果</span></span><br><span class="line">        <span class="keyword">return</span> RequestVoteResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">            .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">//</span></span><br><span class="line">            .setGranted(granted) <span class="comment">//</span></span><br><span class="line">            .build();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到个非常有意思的地方，我们都知道，选举中每个选民手里只有一张票，要么自己要么候选人。但在<code>Pre-Vote</code>选民可以投至少一张票（不考虑Leaner），只要满足条件即可获取选票，最后只看选票是否过半得出候选人名单。</p><p>然后处理第一轮选票结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePreVoteResponse</span><span class="params">(<span class="keyword">final</span> PeerId peerId, <span class="keyword">final</span> <span class="keyword">long</span> term, <span class="keyword">final</span> RequestVoteResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state != State.STATE_FOLLOWER) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//可能后面的选票来晚了，节点要么出错，要么晋升为候选人或者当选为Leader</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (term != <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//此时可能已经屈服为FOLLOWER</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无论任何情况，只要发现任选编号大于自己，都会被强制下线</span></span><br><span class="line">        <span class="comment">//这也是为什么需要Pre-Vote的原因，如果没有简直是牛逼坏了</span></span><br><span class="line">        <span class="keyword">if</span> (response.getTerm() &gt; <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">            stepDown(response.getTerm(), <span class="keyword">false</span>, <span class="keyword">new</span> Status(RaftError.EHIGHERTERMRESPONSE,</span><br><span class="line">                <span class="string">"Raft node receives higher term pre_vote_response."</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一轮选票顺利进行，该节点达标则立即进入第二轮</span></span><br><span class="line">        <span class="keyword">if</span> (response.getGranted()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.prevVoteCtx.grant(peerId);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.prevVoteCtx.isGranted()) &#123;</span><br><span class="line">                doUnlock = <span class="keyword">false</span>;</span><br><span class="line">                electSelf();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2、正式选举Leader"><a href="#3-2、正式选举Leader" class="headerlink" title="3.2、正式选举Leader"></a>3.2、正式选举Leader</h4><p>有了第一轮投票，随即进行第二轮，不进行timeout等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先投自己一票，然后发起投票请求</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">electSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> oldTerm;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state == State.STATE_FOLLOWER) &#123;</span><br><span class="line">            <span class="keyword">this</span>.electionTimer.stop();</span><br><span class="line">        &#125;</span><br><span class="line">        resetLeaderId(PeerId.emptyPeer(), <span class="keyword">new</span> Status(RaftError.ERAFTTIMEDOUT,</span><br><span class="line">            <span class="string">"A follower's leader_id is reset to NULL as it begins to request_vote."</span>));</span><br><span class="line">        <span class="keyword">this</span>.state = State.STATE_CANDIDATE; <span class="comment">// 角色转换为候选人</span></span><br><span class="line">        <span class="keyword">this</span>.currTerm++;    <span class="comment">//这里递增了</span></span><br><span class="line">        <span class="comment">//这是NodeImpl全局变量PeerId voteId，由于存储该节点把选票投给谁</span></span><br><span class="line">        <span class="comment">//候选人投自己一票</span></span><br><span class="line">        <span class="keyword">this</span>.votedId = <span class="keyword">this</span>.serverId.copy();</span><br><span class="line">        <span class="comment">//启动投票时限，如果stepDownWhenVoteTimedout=true，会重新第一轮投票，否则直接重新发起第二轮</span></span><br><span class="line">        <span class="keyword">this</span>.voteTimer.start();</span><br><span class="line">        <span class="comment">//初始化quorum</span></span><br><span class="line">        <span class="keyword">this</span>.voteCtx.init(<span class="keyword">this</span>.conf.getConf(), <span class="keyword">this</span>.conf.isStable() ? <span class="keyword">null</span> : <span class="keyword">this</span>.conf.getOldConf());</span><br><span class="line">        oldTerm = <span class="keyword">this</span>.currTerm;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//刷盘后的lastLogIndexId</span></span><br><span class="line">    <span class="keyword">final</span> LogId lastLogId = <span class="keyword">this</span>.logManager.getLastLogId(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// vote need defense ABA after unlock&amp;writeLock</span></span><br><span class="line">        <span class="keyword">if</span> (oldTerm != <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> PeerId peer : <span class="keyword">this</span>.conf.listPeers()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (peer.equals(<span class="keyword">this</span>.serverId)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.rpcService.connect(peer.getEndpoint())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> OnRequestVoteRpcDone done = <span class="keyword">new</span> OnRequestVoteRpcDone(peer, <span class="keyword">this</span>.currTerm, <span class="keyword">this</span>);</span><br><span class="line">            done.request = RequestVoteRequest.newBuilder() <span class="comment">//</span></span><br><span class="line">                .setPreVote(<span class="keyword">false</span>) <span class="comment">// It's not a pre-vote request.</span></span><br><span class="line">                .setGroupId(<span class="keyword">this</span>.groupId) <span class="comment">//</span></span><br><span class="line">                .setServerId(<span class="keyword">this</span>.serverId.toString()) <span class="comment">//</span></span><br><span class="line">                .setPeerId(peer.toString()) <span class="comment">//</span></span><br><span class="line">                .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">//</span></span><br><span class="line">                .setLastLogIndex(lastLogId.getIndex()) <span class="comment">//</span></span><br><span class="line">                .setLastLogTerm(lastLogId.getTerm()) <span class="comment">//</span></span><br><span class="line">                .build();</span><br><span class="line">            <span class="keyword">this</span>.rpcService.requestVote(peer.getEndpoint(), done.request, done);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.metaStorage.setTermAndVotedFor(<span class="keyword">this</span>.currTerm, <span class="keyword">this</span>.serverId);<span class="comment">//记录你把票投给谁了</span></span><br><span class="line">        <span class="keyword">this</span>.voteCtx.grant(<span class="keyword">this</span>.serverId);<span class="comment">//给自己一票，如果只有你自己一人，直接成为Leader</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.voteCtx.isGranted()) &#123;</span><br><span class="line">            becomeLeader();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Candidate</code>和<code>Follower</code>都会收到除自己外其他候选人的投票请求，对于F来说就是谁先来且符合条件我就投给谁，仅有一票，所以用<code>this.votedId</code>标记投出去的选票变得尤为重要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">handleRequestVoteRequest</span><span class="params">(<span class="keyword">final</span> RequestVoteRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// check term</span></span><br><span class="line">            <span class="keyword">if</span> (request.getTerm() &gt;= <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">                <span class="comment">// 这还用说么，如果是candidate或leader直接降级。更正任期term，以及改变状态为follower</span></span><br><span class="line">                <span class="keyword">if</span> (request.getTerm() &gt; <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">                    stepDown(request.getTerm(), <span class="keyword">false</span>, <span class="keyword">new</span> Status(RaftError.EHIGHERTERMRESPONSE,</span><br><span class="line">                        <span class="string">"Raft node receives higher term RequestVoteRequest."</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//这里是处理晚到过期的投票</span></span><br><span class="line">            &#125;</span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> LogId lastLogId = <span class="keyword">this</span>.logManager.getLastLogId(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            doUnlock = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">            <span class="comment">// vote need ABA check after unlock&amp;writeLock</span></span><br><span class="line">            <span class="keyword">if</span> (request.getTerm() != <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//this.currTerm被上面stepDown()更正过，如果在写锁unlock时又被更正，则说明本次投票请求失效</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下面是投出宝贵的一票</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> logIsOk = <span class="keyword">new</span> LogId(request.getLastLogIndex(), request.getLastLogTerm())</span><br><span class="line">                .compareTo(lastLogId) &gt;= <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//查看该节点是否已经投出选票</span></span><br><span class="line">            <span class="keyword">if</span> (logIsOk &amp;&amp; (<span class="keyword">this</span>.votedId == <span class="keyword">null</span> || <span class="keyword">this</span>.votedId.isEmpty())) &#123;</span><br><span class="line">                stepDown(request.getTerm(), <span class="keyword">false</span>, <span class="keyword">new</span> Status(RaftError.EVOTEFORCANDIDATE,</span><br><span class="line">                    <span class="string">"Raft node votes for some candidate, step down to restart election_timer."</span>));</span><br><span class="line">                <span class="keyword">this</span>.votedId = candidateId.copy();</span><br><span class="line">                <span class="keyword">this</span>.metaStorage.setVotedFor(candidateId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RequestVoteResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">            .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">//</span></span><br><span class="line">            .setGranted(request.getTerm() == <span class="keyword">this</span>.currTerm &amp;&amp; candidateId.equals(<span class="keyword">this</span>.votedId)) <span class="comment">//</span></span><br><span class="line">            .build();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>港真，我在<code>votedId</code>绕了一两个钟，就为了想明白request.term和currTerm在各种情况下的表现，最后来到handleRequestVoteResponse真的开心，选举快结束了。蔡英文当了总统，手动微笑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequestVoteResponse</span><span class="params">(<span class="keyword">final</span> PeerId peerId, <span class="keyword">final</span> <span class="keyword">long</span> term, <span class="keyword">final</span> RequestVoteResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state != State.STATE_CANDIDATE) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (term != <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (response.getTerm() &gt; <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">            stepDown(response.getTerm(), <span class="keyword">false</span>, <span class="keyword">new</span> Status(RaftError.EHIGHERTERMRESPONSE,</span><br><span class="line">                <span class="string">"Raft node receives higher term request_vote_response."</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上面不用看了，都因为term不够，不能转正</span></span><br><span class="line">        <span class="comment">// check granted quorum?</span></span><br><span class="line">        <span class="keyword">if</span> (response.getGranted()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.voteCtx.grant(peerId);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.voteCtx.isGranted()) &#123;</span><br><span class="line">                becomeLeader(); <span class="comment">//成为leader</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段就没什么好说得了，发现一个新角色就是Leaner(学习者)以后再说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">becomeLeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cancel candidate vote timer</span></span><br><span class="line">    stopVoteTimer();</span><br><span class="line">    <span class="keyword">this</span>.state = State.STATE_LEADER;</span><br><span class="line">    <span class="keyword">this</span>.leaderId = <span class="keyword">this</span>.serverId.copy();</span><br><span class="line">    <span class="keyword">this</span>.replicatorGroup.resetTerm(<span class="keyword">this</span>.currTerm);</span><br><span class="line">    <span class="comment">// Start follower's replicators</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> PeerId peer : <span class="keyword">this</span>.conf.listPeers()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (peer.equals(<span class="keyword">this</span>.serverId)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.replicatorGroup.addReplicator(peer)) &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> PeerId peer : <span class="keyword">this</span>.conf.listLearners()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.replicatorGroup.addReplicator(peer, ReplicatorType.Learner)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// init commit manager</span></span><br><span class="line">    <span class="keyword">this</span>.ballotBox.resetPendingIndex(<span class="keyword">this</span>.logManager.getLastLogIndex() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.confCtx.isBusy()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.confCtx.flush(<span class="keyword">this</span>.conf.getConf(), <span class="keyword">this</span>.conf.getOldConf());<span class="comment">//进行Leader的第一次刷盘</span></span><br><span class="line">    <span class="keyword">this</span>.stepDownTimer.start(); <span class="comment">//定时刷新leaderLeaseTimeoutMs，在读一致性那里会详细说明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3、下线方法stepDown到底做了些什么？"><a href="#3-3、下线方法stepDown到底做了些什么？" class="headerlink" title="3.3、下线方法stepDown到底做了些什么？"></a>3.3、下线方法stepDown到底做了些什么？</h4><p>上面很多地方出现<code>stepDown</code>，到底是何方神圣，来康一康吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stepDown</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> term, <span class="keyword">final</span> <span class="keyword">boolean</span> wakeupCandidate, <span class="keyword">final</span> Status status)</span> </span>&#123;</span><br><span class="line">    LOG.debug(<span class="string">"Node &#123;&#125; stepDown, term=&#123;&#125;, newTerm=&#123;&#125;, wakeupCandidate=&#123;&#125;."</span>, getNodeId(), <span class="keyword">this</span>.currTerm, term,</span><br><span class="line">        wakeupCandidate);</span><br><span class="line">    <span class="comment">//这里就不多做解释了</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state == State.STATE_CANDIDATE) &#123;</span><br><span class="line">        stopVoteTimer();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.state.compareTo(State.STATE_TRANSFERRING) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        stopStepDownTimer();</span><br><span class="line">        <span class="keyword">this</span>.ballotBox.clearPendingTasks();</span><br><span class="line">        <span class="comment">// signal fsm leader stop immediately</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state == State.STATE_LEADER) &#123;</span><br><span class="line">            onLeaderStop(status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resetLeaderId(PeerId.emptyPeer(), status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新降级为FOLLOWER</span></span><br><span class="line">    <span class="keyword">this</span>.state = State.STATE_FOLLOWER;</span><br><span class="line">    <span class="keyword">this</span>.confCtx.reset();</span><br><span class="line">    updateLastLeaderTimestamp(Utils.monotonicMs());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.snapshotExecutor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.snapshotExecutor.interruptDownloadingSnapshots(term);<span class="comment">//停止进行中的快照</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更正currTerm</span></span><br><span class="line">    <span class="keyword">if</span> (term &gt; <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">        <span class="keyword">this</span>.currTerm = term;</span><br><span class="line">        <span class="keyword">this</span>.votedId = PeerId.emptyPeer();</span><br><span class="line">        <span class="keyword">this</span>.metaStorage.setTermAndVotedFor(term, <span class="keyword">this</span>.votedId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wakeupCandidate) &#123;<span class="comment">//唤醒一个最优质的，日志完整度和优先级最高的节点，直接进入第二轮选举</span></span><br><span class="line">        <span class="keyword">this</span>.wakingCandidate = <span class="keyword">this</span>.replicatorGroup.stopAllAndFindTheNextCandidate(<span class="keyword">this</span>.conf);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.wakingCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Replicator.sendTimeoutNowAndStop(<span class="keyword">this</span>.wakingCandidate, <span class="keyword">this</span>.options.getElectionTimeoutMs());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.replicatorGroup.stopAll();<span class="comment">//否则所有复制器停止工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.stopTransferArg != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.transferTimer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.transferTimer.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// There is at most one StopTransferTimer at the same term, it's safe to</span></span><br><span class="line">        <span class="comment">// mark stopTransferArg to NULL</span></span><br><span class="line">        <span class="keyword">this</span>.stopTransferArg = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Learner node will not trigger the election timer.</span></span><br><span class="line">    <span class="keyword">if</span> (!isLearner()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.electionTimer.start();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;&#125;<span class="comment">//LOG</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个选举算法的过程就是这样，理顺后，逻辑简单明了，实现起来并不困难，基本围绕者term和lastLogId。stepDown确实很重要，让一个节点回到出厂设置，这个方法代码可能会随着框架自定义内容增加而增加，自己实现simple版至少不用wakeupCandidate和transferTimer。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> CAP理论 </tag>
            
            <tag> RAFT算法 </tag>
            
            <tag> 分布式一致性 </tag>
            
            <tag> BRAFT </tag>
            
            <tag> JRaft </tag>
            
            <tag> 选举算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis源码分析】Redis真的不是单线程，后台IO服务(BIO)</title>
      <link href="/2019/12/21/20191221-%E3%80%90Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Redis%E7%9C%9F%E7%9A%84%E4%B8%8D%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%90%8E%E5%8F%B0IO%E6%9C%8D%E5%8A%A1-BIO/"/>
      <url>/2019/12/21/20191221-%E3%80%90Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Redis%E7%9C%9F%E7%9A%84%E4%B8%8D%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%90%8E%E5%8F%B0IO%E6%9C%8D%E5%8A%A1-BIO/</url>
      
        <content type="html"><![CDATA[<p>面试总喜欢被问Redis是单线程还是多线程，千篇一律的回答单线程却不知所以然，严格来说Redis是多线程多进程、单线程处理请求，本文说的就是多线程下的BIO(Background I/O service)。</p><hr><p>由于redis单线程处理请求，所以某些耗时的操作被作为异步任务，有三种任务分别是：关闭文件、AOF同步磁盘、释放空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Background job opcodes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_CLOSE_FILE    0 <span class="comment">// close()，重写aof，会关闭旧文件fd，具体实现可参考aof.c的backgroundRewriteDoneHandler()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_AOF_FSYNC     1 <span class="comment">// fsync()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_LAZY_FREE     2 <span class="comment">// 延迟释放</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_NUM_OPS       3</span></span><br></pre></td></tr></table></figure><p>每种任务类型都有独立的队列、执行线程、互斥锁，每个任务执行完成并不会callback通知调用方。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_t</span> bio_threads[BIO_NUM_OPS];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> bio_mutex[BIO_NUM_OPS];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_cond_t</span> bio_newjob_cond[BIO_NUM_OPS];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_cond_t</span> bio_step_cond[BIO_NUM_OPS];</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">list</span> *bio_jobs[BIO_NUM_OPS];</span><br><span class="line"><span class="comment">// 用于记录每个任务类型的任务数，假如主线程有与BIO共享的数据时，在主线程操作前，会等待直到队列不会有新的任务</span></span><br><span class="line"><span class="comment">// 通常在aof同步以及延迟释放会用到</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> bio_pending[BIO_NUM_OPS];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This structure represents a background Job. It is only used locally to this</span></span><br><span class="line"><span class="comment"> * file as the API does not expose the internals at all. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_job</span> &#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> time; <span class="comment">/* Time at which the job was created. */</span></span><br><span class="line">    <span class="comment">// 多于三个参数可以传递指针or结构体</span></span><br><span class="line">    <span class="keyword">void</span> *arg1, *arg2, *arg3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">bioProcessBackgroundJobs</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">// 下面三个方法实现均在lazyfree.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lazyfreeFreeObjectFromBioThread</span><span class="params">(robj *o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lazyfreeFreeDatabaseFromBioThread</span><span class="params">(dict *ht1, dict *ht2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lazyfreeFreeSlotsMapFromBioThread</span><span class="params">(zskiplist *sl)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make sure we have enough stack to perform all the things we do in the</span></span><br><span class="line"><span class="comment"> * main thread. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_THREAD_STACK_SIZE (1024*1024*4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在server.c中InitServerLast()调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bioInit</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    <span class="keyword">size_t</span> stacksize;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialization of state vars and objects */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BIO_NUM_OPS; j++) &#123;</span><br><span class="line">        pthread_mutex_init(&amp;bio_mutex[j],<span class="literal">NULL</span>);</span><br><span class="line">        pthread_cond_init(&amp;bio_newjob_cond[j],<span class="literal">NULL</span>);</span><br><span class="line">        pthread_cond_init(&amp;bio_step_cond[j],<span class="literal">NULL</span>);</span><br><span class="line">        bio_jobs[j] = listCreate();</span><br><span class="line">        bio_pending[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_getstacksize(&amp;attr,&amp;stacksize);</span><br><span class="line">    <span class="keyword">if</span> (!stacksize) stacksize = <span class="number">1</span>; <span class="comment">// 不废话，至少4MB</span></span><br><span class="line">    <span class="keyword">while</span> (stacksize &lt; REDIS_THREAD_STACK_SIZE) stacksize *= <span class="number">2</span>;</span><br><span class="line">    pthread_attr_setstacksize(&amp;attr, stacksize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// just do it</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BIO_NUM_OPS; j++) &#123;</span><br><span class="line">        <span class="keyword">void</span> *arg = (<span class="keyword">void</span>*)(<span class="keyword">unsigned</span> <span class="keyword">long</span>) j;</span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;thread,&amp;attr,bioProcessBackgroundJobs,arg) != <span class="number">0</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"Fatal: Can't initialize Background Jobs."</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bio_threads[j] = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bioCreateBackgroundJob</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *arg1, <span class="keyword">void</span> *arg2, <span class="keyword">void</span> *arg3)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_job</span> *<span class="title">job</span> = <span class="title">zmalloc</span>(<span class="title">sizeof</span>(*<span class="title">job</span>));</span></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务线程主体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">bioProcessBackgroundJobs</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_job</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> type = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) arg;</span><br><span class="line">    <span class="keyword">sigset_t</span> sigset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that the type is within the right interval. */</span></span><br><span class="line">    <span class="keyword">if</span> (type &gt;= BIO_NUM_OPS) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Warning: bio thread started with wrong type %lu"</span>,type);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应bioKillThreads的调用</span></span><br><span class="line">    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, <span class="literal">NULL</span>); <span class="comment">// 意味着线程收到终止信号时，会立即取消</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line">    <span class="comment">// 屏蔽SIGALRM定时器信号</span></span><br><span class="line">    sigemptyset(&amp;sigset);</span><br><span class="line">    sigaddset(&amp;sigset, SIGALRM);</span><br><span class="line">    <span class="keyword">if</span> (pthread_sigmask(SIG_BLOCK, &amp;sigset, <span class="literal">NULL</span>))</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Warning: can't mask SIGALRM in bio.c thread: %s"</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        listNode *ln;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列没有任务会一直hold着</span></span><br><span class="line">        <span class="keyword">if</span> (listLength(bio_jobs[type]) == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;bio_newjob_cond[type],&amp;bio_mutex[type]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Pop the job from the queue. */</span></span><br><span class="line">        ln = listFirst(bio_jobs[type]);</span><br><span class="line">        job = ln-&gt;value;</span><br><span class="line">        <span class="comment">// 成功取出任务，则可以释放锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;bio_mutex[type]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Process the job accordingly to its type. */</span></span><br><span class="line">        <span class="keyword">if</span> (type == BIO_CLOSE_FILE) &#123;</span><br><span class="line">            close((<span class="keyword">long</span>)job-&gt;arg1);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BIO_AOF_FSYNC) &#123;</span><br><span class="line">            redis_fsync((<span class="keyword">long</span>)job-&gt;arg1); <span class="comment">// syscall fsync</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BIO_LAZY_FREE) &#123;</span><br><span class="line">            <span class="comment">// 原注解意思，</span></span><br><span class="line">            <span class="comment">// arg1为要释放的对象指针</span></span><br><span class="line">            <span class="comment">// arg2、arg3为要释放的redis db指针</span></span><br><span class="line">            <span class="comment">// arg3则是个跳表</span></span><br><span class="line">            <span class="keyword">if</span> (job-&gt;arg1)</span><br><span class="line">                lazyfreeFreeObjectFromBioThread(job-&gt;arg1); <span class="comment">// 具体参数见：freeObjAsync</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (job-&gt;arg2 &amp;&amp; job-&gt;arg3)</span><br><span class="line">                lazyfreeFreeDatabaseFromBioThread(job-&gt;arg2,job-&gt;arg3); <span class="comment">// 具体参数见：emptyDbAsync</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (job-&gt;arg3)</span><br><span class="line">                lazyfreeFreeSlotsMapFromBioThread(job-&gt;arg3); <span class="comment">// 具体参数见：slotToKeyFlushAsync</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">"Wrong job type in bioProcessBackgroundJobs()."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(job); <span class="comment">//执行完释放任务</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Lock again before reiterating the loop, if there are no longer</span></span><br><span class="line"><span class="comment">         * jobs to process we'll block again in pthread_cond_wait(). */</span></span><br><span class="line">        pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line">        listDelNode(bio_jobs[type],ln);</span><br><span class="line">        bio_pending[type]--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Unblock threads blocked on bioWaitStepOfType() if any. */</span></span><br><span class="line">        pthread_cond_broadcast(&amp;bio_step_cond[type]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the number of pending jobs of the specified type. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">bioPendingJobsOfType</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line">    val = bio_pending[type];</span><br><span class="line">    pthread_mutex_unlock(&amp;bio_mutex[type]);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前看来redis 5.0也没有用到该方法</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">bioWaitStepOfType</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line">    val = bio_pending[type];</span><br><span class="line">    <span class="keyword">if</span> (val != <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;bio_step_cond[type],&amp;bio_mutex[type]);</span><br><span class="line">        val = bio_pending[type];</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;bio_mutex[type]);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有在进程奔溃收到SIGSEGV信号，才会执行该方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bioKillThreads</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BIO_NUM_OPS; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_cancel(bio_threads[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((err = pthread_join(bio_threads[j],<span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"Bio thread for job type #%d can be joined: %s"</span>,</span><br><span class="line">                        j, strerror(err));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"Bio thread for job type #%d terminated"</span>,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux内核 </tag>
            
            <tag> Linux编程 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis源码分析】Redis启动过程是这样的！</title>
      <link href="/2019/12/16/20191218-%E3%80%90Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Redis%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%EF%BC%81/"/>
      <url>/2019/12/16/20191218-%E3%80%90Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Redis%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>redis的源码确实是比我想象中要好读，本身是过程式编程，所以很多核心逻辑已经包含在main函数的调用链，流程非常长，耐心看下去还是能get到些东西的。</p><hr><p>main函数包含了很多逻辑：哨兵模式、定时任务、持久化、模块加载、从磁盘加载数据等等，每个地方都能单独拎出来讲，这里就不说太多了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to initialize our libraries, and the server configuration. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INIT_SETPROCTITLE_REPLACEMENT</span></span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//设置地域，对字符集有影响</span></span><br><span class="line">    setlocale(LC_COLLATE,<span class="string">""</span>);</span><br><span class="line">    tzset(); <span class="comment">//时区设置</span></span><br><span class="line">    <span class="comment">//写异常报告</span></span><br><span class="line">    zmalloc_set_oom_handler(redisOutOfMemoryHandler);</span><br><span class="line">    srand(time(<span class="literal">NULL</span>)^getpid());</span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> hashseed[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">//从/dev/urandom文件获取随机数生成dict所需的随机种子</span></span><br><span class="line">    <span class="comment">//urandom记录系统混乱值，包括软硬件信息</span></span><br><span class="line">    getRandomHexChars(hashseed,<span class="keyword">sizeof</span>(hashseed));</span><br><span class="line">    dictSetHashFunctionSeed((<span class="keyword">uint8_t</span>*)hashseed);</span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc,argv);</span><br><span class="line">    initServerConfig();</span><br><span class="line">    moduleInitModulesSystem();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store the executable path and arguments in a safe place in order</span></span><br><span class="line"><span class="comment">     * to be able to restart the server later. */</span></span><br><span class="line">    server.executable = getAbsolutePath(argv[<span class="number">0</span>]);</span><br><span class="line">    server.exec_argv = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*)*(argc+<span class="number">1</span>));</span><br><span class="line">    server.exec_argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to init sentinel right now as parsing the configuration file</span></span><br><span class="line"><span class="comment">     * in sentinel mode will have the effect of populating the sentinel</span></span><br><span class="line"><span class="comment">     * data structures with master nodes to monitor. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">        initSentinelConfig();</span><br><span class="line">        initSentinel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we need to start in redis-check-rdb/aof mode. We just execute</span></span><br><span class="line"><span class="comment">     * the program main. However the program is part of the Redis executable</span></span><br><span class="line"><span class="comment">     * so that we can easily execute an RDB check on loading errors. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>],<span class="string">"redis-check-rdb"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_rdb_main(argc,argv,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>],<span class="string">"redis-check-aof"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_aof_main(argc,argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里有一大段参数处理，被我去掉</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 管理守护线程的方式</span></span><br><span class="line">    <span class="comment">// service redis restart</span></span><br><span class="line">    <span class="comment">// systemctl start redis</span></span><br><span class="line">    <span class="comment">// 直接kill -9，redis会被重新拉起，以防误杀</span></span><br><span class="line">    server.supervised = redisIsSupervised(server.supervised_mode);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">background</span> = server.daemonize &amp;&amp; !server.supervised; <span class="comment">// 后台运行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">background</span>) daemonize(); <span class="comment">// 调用setsid()，父子进程脱离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化socket、eventloop、定时器: 持久化任务、超时任务</span></span><br><span class="line">    <span class="comment">// 初始化持久化进程通讯用的通道</span></span><br><span class="line">    initServer();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">background</span> || server.pidfile) createPidFile();</span><br><span class="line">    redisSetProcTitle(argv[<span class="number">0</span>]);</span><br><span class="line">    redisAsciiArt(); <span class="comment">// 打印LOGO</span></span><br><span class="line">    checkTcpBacklogSettings();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!server.sentinel_mode) &#123;</span><br><span class="line">        <span class="comment">/* Things not needed when running in Sentinel mode. */</span></span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Server initialized"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line">        linuxMemoryWarnings();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        moduleLoadFromQueue(); <span class="comment">// 加载module</span></span><br><span class="line">        InitServerLast();</span><br><span class="line">        loadDataFromDisk();</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (verifyClusterConfigWithData() == C_ERR) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"You can't have keys in a DB different than DB 0 when in "</span></span><br><span class="line">                    <span class="string">"Cluster mode. Exiting."</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        InitServerLast();</span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Warning the user about suspicious maxmemory setting. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory &gt; <span class="number">0</span> &amp;&amp; server.maxmemory &lt; <span class="number">1024</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?"</span>, server.maxmemory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次做了</span></span><br><span class="line">    <span class="comment">// 1、集群模式下，更新节点状态</span></span><br><span class="line">    <span class="comment">// 2、清理过期Key-Value</span></span><br><span class="line">    <span class="comment">// 3、向从库同步数据</span></span><br><span class="line">    <span class="comment">// 4、主从同步时，会锁住客户端请求，并在这里释放锁</span></span><br><span class="line">    <span class="comment">// 5、尝试执行被刮起的客户端命令</span></span><br><span class="line">    <span class="comment">// 6、持久化AOF</span></span><br><span class="line">    <span class="comment">// 7、处理被阻塞的向客户端写操作</span></span><br><span class="line">    <span class="comment">// 8、释放拓展模块的全局锁（在加载conf以配置的module时加了独自锁）</span></span><br><span class="line">    aeSetBeforeSleepProc(server.el,beforeSleep);</span><br><span class="line">    <span class="comment">// 获取拓展模块的全局锁</span></span><br><span class="line">    aeSetAfterSleepProc(server.el,afterSleep);</span><br><span class="line">    aeMain(server.el);  <span class="comment">// 这是正式启动轮训，单线程处理请求</span></span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initServer</code>初始化了一堆文件or时间监听的事件，其中任务较重的应该是<code>serverCron</code>了，有机会再细说。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    signal(SIGHUP, SIG_IGN); <span class="comment">// 忽略终端会话结束</span></span><br><span class="line">    signal(SIGPIPE, SIG_IGN); <span class="comment">// 若不忽略信号会出现Broken pipe，且退出进程</span></span><br><span class="line">    setupSignalHandlers();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.syslog_enabled) &#123;</span><br><span class="line">        openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,</span><br><span class="line">            server.syslog_facility);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createSharedObjects();</span><br><span class="line">    adjustOpenFilesLimit();</span><br><span class="line">    server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);</span><br><span class="line">    <span class="keyword">if</span> (server.el == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//err log</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    server.db = zmalloc(<span class="keyword">sizeof</span>(redisDb)*server.dbnum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open the TCP listening socket for the user commands. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地进程通信，用于安全访问</span></span><br><span class="line">    <span class="comment">/* Open the listening Unix domain socket. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.unixsocket != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        unlink(server.unixsocket); <span class="comment">/* don't care if this fails */</span></span><br><span class="line">        server.sofd = anetUnixServer(server.neterr,server.unixsocket,</span><br><span class="line">            server.unixsocketperm, server.tcp_backlog);</span><br><span class="line">        <span class="keyword">if</span> (server.sofd == ANET_ERR) &#123;</span><br><span class="line">            serverLog(LL_WARNING, <span class="string">"Opening Unix socket: %s"</span>, server.neterr);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>,server.sofd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Abort if there are no listening sockets at all. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.ipfd_count == <span class="number">0</span> &amp;&amp; server.sofd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// exit</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        <span class="comment">//配置server.db属性，默认16个</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 省略一堆server设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理客户端超时、无法访问的超时key、定时定量持久化</span></span><br><span class="line">    <span class="keyword">if</span> (aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">        <span class="comment">// exit</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create an event handler for accepting new connections in TCP and Unix</span></span><br><span class="line"><span class="comment">     * domain sockets. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">            acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">            &#123;</span><br><span class="line">                serverPanic(</span><br><span class="line">                    <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span> &amp;&amp; aeCreateFileEvent(server.el,server.sofd,AE_READABLE,</span><br><span class="line">        acceptUnixHandler,<span class="literal">NULL</span>) == AE_ERR) serverPanic(<span class="string">"Unrecoverable error creating server.sofd file event."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若被阻塞的客户端需要时可唤醒轮训，在beforeSleep尝试执行完客户端请求，moduleBlockedClientPipeReadable为空方法</span></span><br><span class="line">    <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.module_blocked_pipe[<span class="number">0</span>], AE_READABLE,</span><br><span class="line">        moduleBlockedClientPipeReadable,<span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">            serverPanic(</span><br><span class="line">                <span class="string">"Error registering the readable event for the module "</span></span><br><span class="line">                <span class="string">"blocked clients subsystem."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open the AOF file if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_ON) &#123;</span><br><span class="line">        server.aof_fd = open(server.aof_filename,</span><br><span class="line">                               O_WRONLY|O_APPEND|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span> (server.aof_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// exit</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑32为系统地址空间仅为4G，所以在没有指定maxmemory下限制3G，以为内存不足而无法工作</span></span><br><span class="line">    <span class="keyword">if</span> (server.arch_bits == <span class="number">32</span> &amp;&amp; server.maxmemory == <span class="number">0</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with 'noeviction' policy now."</span>);</span><br><span class="line">        server.maxmemory = <span class="number">3072L</span>L*(<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">/* 3 GB */</span></span><br><span class="line">        server.maxmemory_policy = MAXMEMORY_NO_EVICTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) clusterInit();</span><br><span class="line">    replicationScriptCacheInit();</span><br><span class="line">    scriptingInit(<span class="number">1</span>);</span><br><span class="line">    slowlogInit();</span><br><span class="line">    latencyMonitorInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux内核 </tag>
            
            <tag> Linux编程 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java并发】new Thread时JVM做了什么？</title>
      <link href="/2019/12/11/20191216-%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91new-Thread%E6%97%B6JVM%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2019/12/11/20191216-%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91new-Thread%E6%97%B6JVM%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>最近兴致勃勃捡起C++，打算深入Unix网络编程，但输出博客想从比较简单的问题入手，所以对标一下Java与C的线程创建过程，加深一下理解。（注，Linux）</p><hr><p>Java创建线程是简单的，<code>new Thread()</code>和<code>start()</code>即可启动并执行线程，但由于posix提供的api还涉及不少线程属性，真实过程显然要复杂得多。可以看到前者<code>new Thread</code>只是初始化属性，后者才是真正意义上调用本地接口<code>JVM_StartThread</code>，创建线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下函数指针均被定义在jvm.h，实现在jvm.cpp</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"start0"</span>,           <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;<span class="string">"stop0"</span>,            <span class="string">"("</span> OBJ <span class="string">")V"</span>, (<span class="keyword">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;<span class="string">"isAlive"</span>,          <span class="string">"()Z"</span>,        (<span class="keyword">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;<span class="string">"suspend0"</span>,         <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;<span class="string">"resume0"</span>,          <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;<span class="string">"setPriority0"</span>,     <span class="string">"(I)V"</span>,       (<span class="keyword">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;<span class="string">"yield"</span>,            <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class="line">    &#123;<span class="string">"sleep"</span>,            <span class="string">"(J)V"</span>,       (<span class="keyword">void</span> *)&amp;JVM_Sleep&#125;,</span><br><span class="line">    &#123;<span class="string">"currentThread"</span>,    <span class="string">"()"</span> THD,     (<span class="keyword">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;<span class="string">"countStackFrames"</span>, <span class="string">"()I"</span>,        (<span class="keyword">void</span> *)&amp;JVM_CountStackFrames&#125;,</span><br><span class="line">    &#123;<span class="string">"interrupt0"</span>,       <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;<span class="string">"isInterrupted"</span>,    <span class="string">"(Z)Z"</span>,       (<span class="keyword">void</span> *)&amp;JVM_IsInterrupted&#125;,</span><br><span class="line">    &#123;<span class="string">"holdsLock"</span>,        <span class="string">"("</span> OBJ <span class="string">")Z"</span>, (<span class="keyword">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;<span class="string">"getThreads"</span>,        <span class="string">"()["</span> THD,   (<span class="keyword">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;<span class="string">"dumpThreads"</span>,      <span class="string">"(["</span> THD <span class="string">")[["</span> STE, (<span class="keyword">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">    &#123;<span class="string">"setNativeName"</span>,    <span class="string">"("</span> STR <span class="string">")V"</span>, (<span class="keyword">void</span> *)&amp;JVM_SetNativeThreadName&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>阅读相关JVM源码时，需要知道几个重要类的关系，下面部分实现默认os_linux.cpp。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、JavaThread: 创建线程执行任务，持有java_lang_thread &amp; OSThread对象，维护线程状态运行Thread.run()的地方</span><br><span class="line">2、OSThread: 由于不同操作系统的状态不一致，所以JVM维护了一套平台线程状态，被JavaThread所持有</span><br><span class="line">3、java_lang_Thread::ThreadStatus: 即Java线程状态，与java.lang.Thread.State完全一致</span><br><span class="line">4、OSThread::ThreadState: 2所说的平台线程状态</span><br></pre></td></tr></table></figure><p>需要说的是，以下相关pthread函数均是posix标准，可自行阅读&lt;pthread.h&gt;文档，不多赘述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_StartThread(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_StartThread"</span>);</span><br><span class="line">  JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> throw_illegal_thread_state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里一对花括号代表一段程序，执行完后回释放资源，会调用~MutexLocker(Monitor * monitor)释放互斥锁 (注，~代表析构函数)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//获取互斥锁，加上诉说明，等同于synchronized代码块</span></span><br><span class="line">    <span class="comment">//这里的独占锁依然使用了pthread_mutex_lock函数</span></span><br><span class="line">    <span class="comment">//具体实现在os_posix.cpp的PlatformEvent.park &amp; unpark函数</span></span><br><span class="line">    <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里检查Thread.java的long eetop变量是否有值，避免重复启动线程，该值为JavaThread的地址</span></span><br><span class="line">    <span class="keyword">if</span> (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      throw_illegal_thread_state = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//实例化Thread时，可以设置stackSize，用于初始化虚拟地址栈空间</span></span><br><span class="line">      jlong <span class="built_in">size</span> =</span><br><span class="line">             java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));</span><br><span class="line"></span><br><span class="line">      NOT_LP64(<span class="keyword">if</span> (<span class="built_in">size</span> &gt; SIZE_MAX) <span class="built_in">size</span> = SIZE_MAX;)</span><br><span class="line">      <span class="keyword">size_t</span> sz = <span class="built_in">size</span> &gt; <span class="number">0</span> ? (<span class="keyword">size_t</span>) <span class="built_in">size</span> : <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//这里正式调用pthread_create创建线程</span></span><br><span class="line">      native_thread = <span class="keyword">new</span> JavaThread(&amp;thread_entry, sz);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//可能因为内存不足，无法为OSThread分配空间，所以可能为NULL</span></span><br><span class="line">      <span class="keyword">if</span> (native_thread-&gt;osthread() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//上面提到的eetop，将在这里被设置</span></span><br><span class="line">        native_thread-&gt;<span class="built_in">prepare</span>(jthread);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (throw_illegal_thread_state) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_IllegalThreadStateException());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(native_thread != <span class="literal">NULL</span>, <span class="string">"Starting null thread?"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (native_thread-&gt;osthread() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 安全内存回收(SMR)</span></span><br><span class="line">    native_thread-&gt;smr_delete();</span><br><span class="line">    <span class="keyword">if</span> (JvmtiExport::should_post_resource_exhausted()) &#123;</span><br><span class="line">      JvmtiExport::post_resource_exhausted(</span><br><span class="line">        JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,</span><br><span class="line">        os::native_thread_creation_failed_msg());</span><br><span class="line">    &#125;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),</span><br><span class="line">              os::native_thread_creation_failed_msg());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//哦吼！这是线程真正的开始</span></span><br><span class="line">  Thread::start(native_thread);</span><br><span class="line"></span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure><p>我们知道<code>pthread_create</code>创建线程后立刻执行线程，所以什么<code>Thread::start</code>才是真正启动线程，我们需要进一步窥探。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JavaThread类定义在thread.hpp中，为Thread的子类</span></span><br><span class="line">JavaThread::JavaThread(ThreadFunction entry_point, <span class="keyword">size_t</span> stack_sz) :</span><br><span class="line">                       Thread() &#123;</span><br><span class="line">  <span class="comment">//初始化字段，最重要的是创建线程安全点，作用在垃圾回收时的STW</span></span><br><span class="line">  initialize();</span><br><span class="line">  _jni_attach_state = _not_attaching_via_jni;</span><br><span class="line">  set_entry_point(entry_point);</span><br><span class="line">  <span class="comment">//yep，线程类型有gc、编译、守护、平台等几种</span></span><br><span class="line">  os::ThreadType thr_type = os::java_thread;</span><br><span class="line">  thr_type = entry_point == &amp;compiler_thread_entry ? os::compiler_thread :</span><br><span class="line">                                                     os::java_thread;</span><br><span class="line">  os::create_thread(<span class="keyword">this</span>, thr_type, stack_sz);</span><br><span class="line">  <span class="comment">//这段话我没懂，有大佬明白可以交流下</span></span><br><span class="line">  <span class="comment">// The _osthread may be NULL here because we ran out of memory (too many threads active).</span></span><br><span class="line">  <span class="comment">// We need to throw and OutOfMemoryError - however we cannot do this here because the caller</span></span><br><span class="line">  <span class="comment">// may hold a lock and all locks must be unlocked before throwing the exception (throwing</span></span><br><span class="line">  <span class="comment">// the exception consists of creating the exception object &amp; initializing it, initialization</span></span><br><span class="line">  <span class="comment">// will leave the VM via a JavaCall and then all locks must be unlocked).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The thread is still suspended when we reach here. Thread must be explicit started</span></span><br><span class="line">  <span class="comment">// by creator! Furthermore, the thread must also explicitly be added to the Threads list</span></span><br><span class="line">  <span class="comment">// by calling Threads:add. The reason why this is not done here, is because the thread</span></span><br><span class="line">  <span class="comment">// object must be fully initialized (take a look at JVM_Start)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>create_thread</code>对线程属性的设置跟日常写c++时有些不同，包括警戒线缓冲区和页面对其，一般我们并不会考虑aligned。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//os_linux.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> os::create_thread(Thread* thread, ThreadType thr_type,</span><br><span class="line">                       <span class="keyword">size_t</span> req_stack_size) &#123;</span><br><span class="line">  assert(thread-&gt;osthread() == <span class="literal">NULL</span>, <span class="string">"caller responsible"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate the OSThread object (&lt;_&lt;)可能空指针</span></span><br><span class="line">  OSThread* osthread = <span class="keyword">new</span> OSThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (osthread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// java_thread</span></span><br><span class="line">  osthread-&gt;set_thread_type(thr_type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initial state is ALLOCATED but not INITIALIZED</span></span><br><span class="line">  osthread-&gt;set_state(ALLOCATED);</span><br><span class="line"></span><br><span class="line">  thread-&gt;set_osthread(osthread);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">  pthread_attr_init(&amp;attr);</span><br><span class="line">  <span class="comment">// 所以java线程都是分离状态，join也并非用结合状态</span></span><br><span class="line">  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -Xss默认1M，Thread没设置stackSize，在Linux-x86默认512K，取最大值</span></span><br><span class="line">  <span class="keyword">size_t</span> stack_size = os::Posix::get_initial_stack_size(thr_type, req_stack_size);</span><br><span class="line">  <span class="comment">//这里设置栈警戒缓冲区，默认系统页大小</span></span><br><span class="line">  <span class="comment">//原注解的意思是，Linux的NPTL没有完全按照posix标准</span></span><br><span class="line">  <span class="comment">//理应guard_size + stack_size，且二者大小相等，而不是从stack_size取guard_size作为警戒取</span></span><br><span class="line">  <span class="comment">//所以这里模仿实现posix标准</span></span><br><span class="line">  <span class="keyword">size_t</span> guard_size = os::Linux::default_guard_size(thr_type);</span><br><span class="line">  <span class="keyword">if</span> (stack_size &lt;= SIZE_MAX - guard_size) &#123;</span><br><span class="line">    stack_size += guard_size;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(is_aligned(stack_size, os::vm_page_size()), <span class="string">"stack_size not aligned"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> status = pthread_attr_setstacksize(&amp;attr, stack_size);</span><br><span class="line">  assert_status(status == <span class="number">0</span>, status, <span class="string">"pthread_attr_setstacksize"</span>);</span><br><span class="line"></span><br><span class="line">  pthread_attr_setguardsize(&amp;attr, os::Linux::default_guard_size(thr_type));</span><br><span class="line"></span><br><span class="line">  ThreadState state;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//欧了，创建线程，函数指针thread_native_entry是重点</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, &amp;attr, (<span class="keyword">void</span>* (*)(<span class="keyword">void</span>*)) thread_native_entry, thread);</span><br><span class="line">    </span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Need to clean up stuff we've allocated so far</span></span><br><span class="line">      thread-&gt;set_osthread(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">delete</span> osthread;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store pthread info into the OSThread</span></span><br><span class="line">    osthread-&gt;set_pthread_id(tid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待thread_native_entry设置osthread为INITIALIZED，或收到终止信号</span></span><br><span class="line">    &#123;</span><br><span class="line">      Monitor* sync_with_child = osthread-&gt;startThread_lock();</span><br><span class="line">      <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(sync_with_child, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">      <span class="keyword">while</span> ((state = osthread-&gt;get_state()) == ALLOCATED) &#123;</span><br><span class="line">        sync_with_child-&gt;wait(Mutex::_no_safepoint_check_flag);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// Aborted due to thread limit being reached</span></span><br><span class="line">  <span class="keyword">if</span> (state == ZOMBIE) &#123;</span><br><span class="line">    thread-&gt;set_osthread(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">delete</span> osthread;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The thread is returned suspended (in state INITIALIZED),</span></span><br><span class="line">  <span class="comment">// and is started higher up in the call chain</span></span><br><span class="line">  assert(state == INITIALIZED, <span class="string">"race condition"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>pthread_create</code>会立即执行<code>thread_native_entry</code>，但又因为JavaThread被OSThread管理着，所以需要加各种排斥锁，达到二者状态同步的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thread_native_entry</span><span class="params">(Thread *thread)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  thread-&gt;record_stack_base_and_size();</span><br><span class="line">  <span class="comment">//我没理解这里的左右，有CPU大佬请解答</span></span><br><span class="line">  <span class="comment">// Try to randomize the cache line index of hot stack frames.</span></span><br><span class="line">  <span class="comment">// This helps when threads of the same stack traces evict each other's</span></span><br><span class="line">  <span class="comment">// cache lines. The threads can be either from the same JVM instance, or</span></span><br><span class="line">  <span class="comment">// from different JVM instances. The benefit is especially true for</span></span><br><span class="line">  <span class="comment">// processors with hyperthreading technology.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pid = os::current_process_id();</span><br><span class="line">  alloca(((pid ^ counter++) &amp; <span class="number">7</span>) * <span class="number">128</span>);</span><br><span class="line">  <span class="comment">//声明类似ThreadLocal的pthread_key_t</span></span><br><span class="line">  thread-&gt;initialize_thread_current();</span><br><span class="line"></span><br><span class="line">  OSThread* osthread = thread-&gt;osthread();</span><br><span class="line">  Monitor* sync = osthread-&gt;startThread_lock();</span><br><span class="line"></span><br><span class="line">  osthread-&gt;set_thread_id(os::current_thread_id());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (UseNUMA) &#123;</span><br><span class="line">    <span class="keyword">int</span> lgrp_id = os::numa_get_group_id();</span><br><span class="line">    <span class="keyword">if</span> (lgrp_id != <span class="number">-1</span>) &#123;</span><br><span class="line">      thread-&gt;set_lgrp_id(lgrp_id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 屏蔽来自VM的阻塞信号</span></span><br><span class="line">  os::Linux::hotspot_sigmask(thread);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize floating point control register</span></span><br><span class="line">  os::Linux::init_thread_fpu_state();</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(sync, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// notify parent thread</span></span><br><span class="line">    osthread-&gt;set_state(INITIALIZED);</span><br><span class="line">    sync-&gt;notify_all();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait until os::start_thread() &lt;&lt;&lt;------  自璇中，等待调用Thread::start()</span></span><br><span class="line">    <span class="keyword">while</span> (osthread-&gt;get_state() == INITIALIZED) &#123;</span><br><span class="line">      sync-&gt;wait(Mutex::_no_safepoint_check_flag);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(osthread-&gt;pthread_id() != <span class="number">0</span>, <span class="string">"pthread_id was not set as expected"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call one more level start routine</span></span><br><span class="line">  thread-&gt;call_run(); <span class="comment">// &lt;--- 里面调用JavaThread::run()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: at this point the thread object may already have deleted itself.</span></span><br><span class="line">  <span class="comment">// Prevent dereferencing it from here on out.</span></span><br><span class="line">  thread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行Runable之前，JVM需要给java线程分配本地缓冲区等操作(这是一个大块)，这里算是到头了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JavaThread::<span class="built_in">run</span>() &#123;</span><br><span class="line">  <span class="comment">// 初始化TLAB，即在年轻代割一点空间给自己，具体大小-XX:UseTLAB设置</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;initialize_tlab();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//不知道干嘛的，在linux_x86是空实现</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;record_base_of_stack_pointer();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;create_stack_guard_pages();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;cache_global_variables();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Thread is now sufficiently initialized to be handled by the safepoint code as being</span></span><br><span class="line">  <span class="comment">// in the VM. Change thread state from _thread_new to _thread_in_vm</span></span><br><span class="line">  ThreadStateTransition::transition_and_fence(<span class="keyword">this</span>, _thread_new, _thread_in_vm);</span><br><span class="line"></span><br><span class="line">  assert(JavaThread::current() == <span class="keyword">this</span>, <span class="string">"sanity check"</span>);</span><br><span class="line">  assert(!Thread::current()-&gt;owns_locks(), <span class="string">"sanity check"</span>);</span><br><span class="line"></span><br><span class="line">  DTRACE_THREAD_PROBE(start, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;set_active_handles(JNIHandleBlock::allocate_block());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (JvmtiExport::should_post_thread_life()) &#123;</span><br><span class="line">    JvmtiExport::post_thread_start(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这里才是真正调用java.lang.Thread#run()方法，执行Runable</span></span><br><span class="line">  <span class="comment">// We call another function to do the rest so we are sure that the stack addresses used</span></span><br><span class="line">  <span class="comment">// from there will be lower than the stack base just computed.</span></span><br><span class="line">  thread_main_inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面代码不多做解释了，<code>this-&gt;entry_point()(this, this)</code> 等同于调用函数<code>thread_entry</code>，<code>JavaCalls</code>也是个大块，复杂调用java方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JavaThread::thread_main_inner() &#123;</span><br><span class="line">  assert(JavaThread::current() == <span class="keyword">this</span>, <span class="string">"sanity check"</span>);</span><br><span class="line">  assert(<span class="keyword">this</span>-&gt;threadObj() != <span class="literal">NULL</span>, <span class="string">"just checking"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Execute thread entry point unless this thread has a pending exception</span></span><br><span class="line">  <span class="comment">// or has been stopped before starting.</span></span><br><span class="line">  <span class="comment">// Note: Due to JVM_StopThread we can have pending exceptions already!</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;has_pending_exception() &amp;&amp;</span><br><span class="line">      !java_lang_Thread::is_stillborn(<span class="keyword">this</span>-&gt;threadObj())) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">ResourceMark <span class="title">rm</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">      <span class="keyword">this</span>-&gt;set_native_thread_name(<span class="keyword">this</span>-&gt;get_thread_name());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">HandleMark <span class="title">hm</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;entry_point()(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DTRACE_THREAD_PROBE(<span class="built_in">stop</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cleanup is handled in post_run()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="function">HandleMark <span class="title">hm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, thread-&gt;threadObj())</span></span>;</span><br><span class="line">  <span class="function">JavaValue <span class="title">result</span><span class="params">(T_VOID)</span></span>;</span><br><span class="line">  JavaCalls::call_virtual(&amp;result,</span><br><span class="line">                          obj,</span><br><span class="line">                          SystemDictionary::Thread_klass(),</span><br><span class="line">                          vmSymbols::run_method_name(),</span><br><span class="line">                          vmSymbols::void_method_signature(),</span><br><span class="line">                          THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体来说，创建一个线程对于JVM来说还是相对费劲的，不是说性能不好，是需要做太多事。与GC息息相关的两个点就是TLAB与ThreadSafePoint，其他则是对于java程序员透明的栈空间的分配(这里指的是虚拟内存地址)、线程状态管理。</p>]]></content>
      
      
      <categories>
          
          <category> java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> java </tag>
            
            <tag> Thread </tag>
            
            <tag> Linux编程 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【网络编程】从Linux角度以及JVM源码，深入NIO的细节</title>
      <link href="/2019/01/09/20190109-%E3%80%90%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%91NIO%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/01/09/20190109-%E3%80%90%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%91NIO%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>最近一段时间都在啃Linux内核， 也给了自己机会再度深入理解Java的NIO实现，希望能获得更多东西，尝试理解以前未能理解的，会涉及少量OpenJDK源码。</p><hr><p>因为NIO本身的实现很多牵扯到操作系统，所以需要先稍微过一下，有理解不对的地方，请指出。</p><h3 id="涉及的Linux知识"><a href="#涉及的Linux知识" class="headerlink" title="涉及的Linux知识"></a>涉及的Linux知识</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>对于Linux来说，一切皆为文件，设备文件、IO文件还是普通文件，都可以通过一个叫做文件描述符（FileDescriptor）的东西来进行操作，其涉及的数据结构可以自行了解VFS。</p><h5 id="设备阻塞与非阻塞"><a href="#设备阻塞与非阻塞" class="headerlink" title="设备阻塞与非阻塞"></a>设备阻塞与非阻塞</h5><p>任意对设备的操作都是默认为阻塞的，如果没有或有不可操作的资源，会被添加到<code>wait_queue_head_t</code>中进行等待，直到被<code>semaphore</code>通知允许执行。此时可以通过<code>fcntl()</code>函数将文件描述符设置为非阻塞，若没有或有不可操作的资源，立即返回错误信息。</p><h4 id="JVM内存结构-amp-虚拟地址空间"><a href="#JVM内存结构-amp-虚拟地址空间" class="headerlink" title="JVM内存结构 &amp; 虚拟地址空间"></a>JVM内存结构 &amp; 虚拟地址空间</h4><p>众所周知，Linux下的每一进程都有自己的虚拟内存地址，而JVM也是一个进程，且JVM有自己的内存结构。既然如此，两者之间必有对应关系，OracleJDK7提供了NMT，用<code>jcmd pid VM.native_memory detail</code>可以查看各类区域的reserved，被committed的内存大小及其地址区间，再通过<code>pmap -p</code>可以看到进程内存信息。</p><p>肉眼对比地址区间可以发现，JVM heap是通过mmap分配内存的，位于进程的映射区内，而进程堆区可以被malloc进行分配，对应关系如图。<br><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/jvm%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80.png" alt="jvm内存虚拟地址"></p><h4 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h4><p>先回顾一下几个相关函数，JVM相关实现可以看Net.c源码，这里不做赘述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// domain : AF_UNIX|AF_LOCAL 本地传输，AF_INET|AF_INET6  ipv4/6传输</span></span><br><span class="line"><span class="comment">// type : SOCK_STREAM -&gt; TCP, SOCK_DGRAM -&gt; UDP</span></span><br><span class="line"><span class="comment">// protocol : 0 系统默认</span></span><br><span class="line"><span class="comment">// return : socket fd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">//sockfd : socket retuen fd</span></span><br><span class="line"><span class="comment">//addr : sockaddr_in&#123;sin_family=AF_INET -&gt; ipv4,s_addr -&gt; ip地址,sin_port -&gt; 端口号&#125;</span></span><br><span class="line"><span class="comment">//addrlen : sockaddr的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* addr, <span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">//backlog : 最大连接数， syn queue + accpet queue 的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">//同bind()的参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sd, struct sockaddr *server, <span class="keyword">int</span> addr_len)</span></span>;</span><br></pre></td></tr></table></figure><p>另，socketIO可以使用<code>read &amp; write</code>，和<code>recv &amp; send</code>两种函数，后者多了一个参数flags。</p><p>注，阻塞非阻塞模式，以下函数返回值有所区别。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;<span class="comment">//pwrite(), writev()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;<span class="comment">//pread(), readv()</span></span><br><span class="line"><span class="comment">//flags：这里没打算展开讲，自行google</span></span><br><span class="line"><span class="comment">//MSG_DONTROUTE 本地网络，不需查找路由</span></span><br><span class="line"><span class="comment">//MSG_OOB TCP URG紧急指针，多用于心跳</span></span><br><span class="line"><span class="comment">//MSG_PEEK  只读不取，数据保留在缓冲区</span></span><br><span class="line"><span class="comment">//MSG_WAITALL 等待到满足指定条件才返回，在此之前会一直阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">void</span> *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">void</span> *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>NIO在不同操作系统提供了不同实现，win-select，linux-epoll以及mac-kqueue，本文忽略windows平台，只说linux &amp; mac下的实现。</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>不太想讲epoll跟select的区别，网上多的是，不过唯一要说epoll本身是fd，很多功能都基于此，也不需要select一样重复实例化，下面的kqueue也是一样。</p><p>首先是epoll是个文件，所以有可能被其他epoll/select/poll监听，所以可能会出现循环或反向路径，内核实现极其复杂冗长，有兴趣可以啃下<code>ep_loop_check</code>和<code>reverse_path_check</code>，我图论学得不好，看不下去。<br>需要说明fd、event、epfd的关系，epfd &lt;n/n&gt; fd &lt;n/n&gt; event，均是多对多的关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">  <span class="keyword">void</span> *ptr; <span class="comment">//如果需要，可以携带自定义数据</span></span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">//被监听的事件</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;</span><br><span class="line">  <span class="comment">//EPOLLOUT：TL，缓冲池为空</span></span><br><span class="line">  <span class="comment">//EPOLLIN：TL，缓冲池为满</span></span><br><span class="line">  <span class="comment">//EPOLLET：EL，有所变化</span></span><br><span class="line">  <span class="comment">//还有其他，不一一列出了</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//size : 可监听的最大数目，后来2.6.8开始，此参数无效</span></span><br><span class="line"><span class="comment">//return : epoll fd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="comment">//op : EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL 分别是新增修改删除fd</span></span><br><span class="line"><span class="comment">//fd : 被监听的事件</span></span><br><span class="line"><span class="comment">//event : 上面的struct</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">//events : 就绪事件的数组</span></span><br><span class="line"><span class="comment">//maxevents : 能被处理的最大事件数</span></span><br><span class="line"><span class="comment">//timeout : 0 非阻塞，-1 阻塞，&gt;0 等待超时</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>值得注意的是，epoll的边沿模式(EL)和水平模式(TL)，</p><p><code>EL</code>只在中断信号来临时反馈，所以<code>buffer cache</code>的数据未处理完，没有新数据到来是不会通知就绪的。<br><code>TL</code>则是会查看<code>buffer cache</code>是否还有数据，只要没有被处理完，会继续通知就绪。</p><p>一个关于这两种模式的问题，就EL模式是否必须把fd设置为O_NONBLOCK。我不是很理解<a href="http://man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="noopener">Linux手册</a>中对EL的描述，为什么要和EL扯上关系，若是因为读写阻塞导致后续任务饥饿，那在TL是一样的后果。要我说，既然用了epoll，那就直接把fd设置为O_NONBLOCK得了，就没那么多事。</p><p>对此我强烈建议写过一次linux下的网络编程，加强理解，这里不写示例了。</p><h4 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a>kqueue</h4><p>全网关于kqueue的文章少之又少，特别是中文，描述得比较详细的只有这篇<a href="https://blog.csdn.net/mumumuwudi/article/details/47145801" target="_blank" rel="noopener">《FreeBSD Kqueue的实现原理》</a>，外文的就是发明者的论文和<a href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2&manpath=FreeBSD+5.0-current" target="_blank" rel="noopener">FreeBSD手册</a>了。kqueue的数据结构我并没有完全搞懂，懒得啃FreeBSD的实现（解压出来的源码有1.05g 手动微笑）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个kqueue fd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kqueue</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//用于注册、等待阻塞</span></span><br><span class="line"><span class="comment">//changelist : 监听列表</span></span><br><span class="line"><span class="comment">//nchanges : 监听数目</span></span><br><span class="line"><span class="comment">//eventlist : 就绪列表</span></span><br><span class="line"><span class="comment">//nevents : 就绪事件数目</span></span><br><span class="line"><span class="comment">//timeout : 0 非阻塞，-1 阻塞，&gt;0 等待超时</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kevent</span><span class="params">(<span class="keyword">int</span> kq, <span class="keyword">const</span> struct kevent *changelist, <span class="keyword">int</span> nchanges, struct kevent *eventlist, <span class="keyword">int</span> nevents, <span class="keyword">const</span> struct timespec *timeout)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kevent</span> &#123;</span></span><br><span class="line">  <span class="comment">//ident : 通常是个fd</span></span><br><span class="line">  <span class="keyword">uintpt_t</span> ident;</span><br><span class="line">  <span class="comment">//filter :</span></span><br><span class="line">  short filter; <span class="comment">// filter for event</span></span><br><span class="line">  u_short flags; <span class="comment">// action flags for kq</span></span><br><span class="line">  u_int fflags; <span class="comment">// filter flag value</span></span><br><span class="line">  <span class="keyword">intptr_t</span> data; <span class="comment">// filter data value</span></span><br><span class="line">  <span class="keyword">void</span> *udata; <span class="comment">// opaque identifier</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EV_SET(&amp;kev, ident, filter, flags, fflags, data, udata);</span><br></pre></td></tr></table></figure><h3 id="NIO源码"><a href="#NIO源码" class="headerlink" title="NIO源码"></a>NIO源码</h3><h4 id="先来一个NIO网络通讯的示例"><a href="#先来一个NIO网络通讯的示例" class="headerlink" title="先来一个NIO网络通讯的示例"></a>先来一个NIO网络通讯的示例</h4><p>Server，<code>IOException</code>是要做处理的，我懒得写。<a href="https://github.com/zehonghuang/github_blog_bak/blob/master/source/file/ServerDemo.java" target="_blank" rel="noopener">示例代码</a></p><p>Client，<code>read()</code>同 Server。<a href="https://github.com/zehonghuang/github_blog_bak/blob/master/source/file/ClientDemo.java" target="_blank" rel="noopener">示例代码</a></p><h4 id="多路复用们的包装类"><a href="#多路复用们的包装类" class="headerlink" title="多路复用们的包装类"></a>多路复用们的包装类</h4><p>我很想按照demo的代码顺序讲，但感觉NIO的实现几乎围绕着<code>SelectorImpl</code>写的，所以还是先来讲讲起子类与多路复用的包装类们。</p><h4 id="EPollSelectorImpl-amp-EPollSelectorWapper"><a href="#EPollSelectorImpl-amp-EPollSelectorWapper" class="headerlink" title="EPollSelectorImpl &amp; EPollSelectorWapper"></a><code>EPollSelectorImpl</code> &amp; <code>EPollSelectorWapper</code></h4><p>后者就是Linux中epoll编程的包装类，在对应的<code>EPollArrayWrapper.c</code>中可以看出调用的都是上面说到的函数，实现类特意注册了一个管道用于唤醒<code>epoll_wait</code>。</p><p>每种实现都是通过<code>selector.select();</code>进行轮询，其实现的终极入口在<code>SelectorImpl.doSelect(timeout)</code>，对于epoll来说，究极实现在<code>EPollArrayWrapper.poll(timeout)</code>，最后调用的则是<code>epoll_wait</code>，下面代码都是围绕着轮询实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EPollSelectorImpl</span> <span class="keyword">extends</span> <span class="title">SelectorImpl</span> </span>&#123;</span><br><span class="line">  <span class="comment">//用于中断epoll阻塞的pipe文件描述符，fd0:入口 fd1:出口</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> fd0;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> fd1;</span><br><span class="line">  <span class="comment">//epoll声明的JNI包装类</span></span><br><span class="line">  EPollArrayWrapper pollWrapper;</span><br><span class="line">  <span class="comment">//fd -&gt; selectionKey</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer,SelectionKeyImpl&gt; fdToKey;</span><br><span class="line">  <span class="comment">//关闭selector，将会把所有文件描述符全部close并置为-1，implClose()可见</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object interruptLock = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> interruptTriggered = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  EPollSelectorImpl(SelectorProvider sp) &#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">    <span class="comment">//删除被cancel的selectionKey</span></span><br><span class="line">    processDeregisterQueue();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      begin();</span><br><span class="line">      pollWrapper.poll(timeout);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除阻塞中被其他线程cancel的selectionKey</span></span><br><span class="line">    processDeregisterQueue();</span><br><span class="line">    <span class="keyword">int</span> numKeysUpdated = updateSelectedKeys();</span><br><span class="line">    <span class="comment">//处理中断</span></span><br><span class="line">    <span class="keyword">if</span> (pollWrapper.interrupted()) &#123;</span><br><span class="line">      <span class="comment">//清除pipe事件的响应，并恢复中断状态</span></span><br><span class="line">      pollWrapper.putEventOps(pollWrapper.interruptedIndex(), <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">synchronized</span> (interruptLock) &#123;</span><br><span class="line">        pollWrapper.clearInterrupted();</span><br><span class="line">        <span class="comment">//读取管道数据</span></span><br><span class="line">        IOUtil.drain(fd0);</span><br><span class="line">        interruptTriggered = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EPollArrayWrapper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> epfd;</span><br><span class="line">  <span class="comment">//用于对epoll_event *events数组的增删查改</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AllocatedNativeObject pollArray;</span><br><span class="line">  <span class="comment">//*events地址</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> pollArrayAddress;</span><br><span class="line">  <span class="comment">//对应上面fd1</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> outgoingInterruptFD;</span><br><span class="line">  <span class="comment">//对应上面fd0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> incomingInterruptFD;</span><br><span class="line">  <span class="comment">//*events中断事件的下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> interruptedIndex;</span><br><span class="line"></span><br><span class="line">  EPollArrayWrapper() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//创建epoll fd</span></span><br><span class="line">    epfd = epollCreate();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    updateRegistrations(); <span class="comment">//更新注册的event</span></span><br><span class="line">    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;updated; i++) &#123;</span><br><span class="line">      <span class="comment">//管道事件唤醒epoll，结束等待</span></span><br><span class="line">      <span class="keyword">if</span> (getDescriptor(i) == incomingInterruptFD) &#123;</span><br><span class="line">        interruptedIndex = i;</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> updated;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interrupt(outgoingInterruptFD);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//本地方法名: Java_sun_nio_ch_EPollArrayWrapper_interrupt，会向管道传递数字「1」表中断</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EPollArrayWrapper的JNI代码，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESTARTABLE(_cmd, _result) do &#123; \</span></span><br><span class="line">  <span class="keyword">do</span> &#123; \</span><br><span class="line">    _result = _cmd; \</span><br><span class="line">    <span class="comment">//如果被系统中断而结束轮询，会继续下一次epoll_wait</span></span><br><span class="line">  &#125; <span class="keyword">while</span>((_result == <span class="number">-1</span>) &amp;&amp; (errno == EINTR)); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_sun_nio_ch_EPollArrayWrapper_epollWait(JNIEnv *env, jobject <span class="keyword">this</span>,</span><br><span class="line">                                            jlong address, jint numfds,</span><br><span class="line">                                            jlong timeout, jint epfd)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span> = <span class="title">jlong_to_ptr</span>(<span class="title">address</span>);</span><span class="comment">//获取指针</span></span><br><span class="line">  <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123; <span class="comment">//无限阻塞 or 非阻塞</span></span><br><span class="line">    RESTARTABLE((*epoll_wait_func)(epfd, events, numfds, timeout), res);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;            <span class="comment">//系统中断后，会继续下一次epoll_wait</span></span><br><span class="line">    res = iepoll(epfd, events, numfds, timeout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">iepoll(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> numfds, jlong timeout)</span><br><span class="line">&#123;</span><br><span class="line">  jlong start, now;</span><br><span class="line">  <span class="keyword">int</span> remaining = timeout;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">t</span>;</span></span><br><span class="line">  <span class="keyword">int</span> diff;</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;t, <span class="literal">NULL</span>);</span><br><span class="line">  start = t.tv_sec * <span class="number">1000</span> + t.tv_usec / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> res = epoll_wait(epfd, events, numfds, timeout);</span><br><span class="line">    <span class="comment">//同RESTARTABLE，被中断后重新计算剩余超时时间并继续轮询</span></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span> &amp;&amp; errno == EINTR) &#123;</span><br><span class="line">      <span class="keyword">if</span> (remaining &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        gettimeofday(&amp;t, <span class="literal">NULL</span>);</span><br><span class="line">        now = t.tv_sec * <span class="number">1000</span> + t.tv_usec / <span class="number">1000</span>;</span><br><span class="line">        diff = now - start;</span><br><span class="line">        remaining -= diff;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span> || remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start = now;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="KqueueSelectorImpl-amp-KqueueSelectorWapper"><a href="#KqueueSelectorImpl-amp-KqueueSelectorWapper" class="headerlink" title="KqueueSelectorImpl &amp; KqueueSelectorWapper"></a><code>KqueueSelectorImpl</code> &amp; <code>KqueueSelectorWapper</code></h4><p>我挺纠结是否要说kqueue，毕竟除了本身的声明过程，其他几乎与上述的epoll一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KQueueSelectorImpl</span> <span class="keyword">extends</span> <span class="title">SelectorImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> entries = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">    processDeregisterQueue();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      begin();</span><br><span class="line">      entries = kqueueWrapper.poll(timeout);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      end();</span><br><span class="line">    &#125;</span><br><span class="line">    processDeregisterQueue();</span><br><span class="line">    <span class="comment">//这里更新selectedKey的位置不同，但其中逻辑与epoll是一样的</span></span><br><span class="line">    <span class="keyword">return</span> updateSelectedKeys(entries);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KQueueArrayWrapper</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">    updateRegistrations();</span><br><span class="line">    <span class="keyword">int</span> updated = kevent0(kq, keventArrayAddress, NUM_KEVENTS, timeout);</span><br><span class="line">    <span class="keyword">return</span> updated;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">kevent0</span><span class="params">(<span class="keyword">int</span> kq, <span class="keyword">long</span> keventAddress, <span class="keyword">int</span> keventCount,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">long</span> timeout)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要说不同，也就最后<code>kevent0</code>的轮询，不像epoll收到中断后会继续轮询，这里是直接return 0，由用户代码继续下一次轮询。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_sun_nio_ch_KQueueArrayWrapper_kevent0(JNIEnv *env, jobject <span class="keyword">this</span>, jint kq,</span><br><span class="line">                                           jlong kevAddr, jint kevCount,</span><br><span class="line">                                           jlong timeout)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (timeout &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    ts.tv_sec = timeout / <span class="number">1000</span>;</span><br><span class="line">    ts.tv_nsec = (timeout % <span class="number">1000</span>) * <span class="number">1000000</span>;</span><br><span class="line">    tsp = &amp;ts;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    tsp = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result = kevent(kq, <span class="literal">NULL</span>, <span class="number">0</span>, kevs, kevCount, tsp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      JNU_ThrowIOExceptionWithLastError(env, <span class="string">"KQueueArrayWrapper: kqueue failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此，多路复用在JVM的实现到这为止。</p><h4 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h4><p>讲道理，这个图看起来复杂，其实功能接口很分明，阅读难度并不大。</p><p><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/Channel%E4%BD%93%E7%B3%BB.png" alt="Channel体系"></p><h4 id="接口类型及其作用"><a href="#接口类型及其作用" class="headerlink" title="接口类型及其作用"></a>接口类型及其作用</h4><p><code>Channel</code>顶级接口，实际只提供一个<code>close()</code>。</p><p><code>InterruptibleChannel</code>注释写了用于异步关闭or中断，大概说的是<code>AbstractInterruptibleChannel.begin()</code>的回调，中断后调用<code>implCloseChannel()</code>。</p><p><code>SelectableChannel</code>这个就是多路复用提供的部分实现API。</p><p><code>NetworkChannel</code>网络IO，绑定、设置socket选项等。</p><p><code>ScatteringByteChannel</code> &amp; <code>GatheringByteChannel</code>就是BufferByte读写了。</p><p><code>SeekableByteChannel</code>知道<code>lseek()</code>就明白是跟文件IO相关的了。</p><h4 id="网络IO相关实现及其分析"><a href="#网络IO相关实现及其分析" class="headerlink" title="网络IO相关实现及其分析"></a>网络IO相关实现及其分析</h4><p>这里我需要先说明一下<code>configureBlocking(boolean)</code>方法，这实际是调用了上述说到<code>fcntl()</code>，可以看下<code>IOUtil.configureBlocking(FileDescriptor fd, boolean blocking);</code>的JNI源码，所以下述socket fd都是非阻塞的，有<code>空循环</code>很正常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IOUtil.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">configureBlocking(<span class="keyword">int</span> fd, jboolean blocking)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> flags = fcntl(fd, F_GETFL);</span><br><span class="line">  <span class="keyword">int</span> newflags = blocking ? (flags &amp; ~O_NONBLOCK) : (flags | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (flags == newflags) ? <span class="number">0</span> : fcntl(fd, F_SETFL, newflags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过有必要说明该方法的使用注意事项，一旦fd(即channel)被注册后，是不能重新设置为阻塞的。如果在注册前或不需要注册，是可以使用阻塞模式的fd进行读写操作的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSelectableChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">SelectableChannel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isOpen())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">      <span class="keyword">if</span> (blocking == block)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      <span class="comment">//ValidKeys是查找该fd是否有注册的key，如果有且设置为阻塞，直接抛异常。</span></span><br><span class="line">      <span class="keyword">if</span> (block &amp;&amp; haveValidKeys())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br><span class="line">      implConfigureBlocking(block);</span><br><span class="line">      blocking = block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面已经提及<code>AbstractSelectableChannel.configureBlocking</code>这么小而重要的方法，有一个与其息息相关的方法就是register了。需要说的是，epfd(或kq)和被监听的fd是可以多对多的，所以每个channel都需要被维护一个selectionKey[]记录被哪些epfd监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Object att)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isOpen())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">    <span class="comment">//随意传一个int是非法的</span></span><br><span class="line">    <span class="keyword">if</span> ((ops &amp; ~validOps()) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如上面所说，阻塞不能被注册的</span></span><br><span class="line">    <span class="keyword">if</span> (blocking)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br><span class="line">    <span class="comment">//从SelectionKey[]中查找是被注册过</span></span><br><span class="line">    SelectionKey k = findKey(sel);</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//实际调用epoll_ctl + EPOLL_CTL_MOD</span></span><br><span class="line">      k.interestOps(ops);</span><br><span class="line">      k.attach(att);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOpen())</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">        <span class="comment">//就是epoll_ctl + EPOLL_CTL_ADD</span></span><br><span class="line">        k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att);</span><br><span class="line">        addKey(k);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看<code>ServerSocketChannel.open()</code>发射出去的实例<code>SocketChannelImpl</code>，示例中<code>ssc.bind(new InetSocketAddress(16767))</code>已经包含了<code>bind</code>&amp;<code>listen</code>两个函数，这里也把<code>accpet()</code>给说了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerSocketChannelImpl</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">ServerSocketChannel</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">SelChImpl</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">//未初始化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_UNINITIALIZED = -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//正在使用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_INUSE = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//socket被kill</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_KILLED = <span class="number">1</span>;</span><br><span class="line">  ServerSocketChannelImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    <span class="comment">// Net包含一切与socket编程有关的JNI</span></span><br><span class="line">    <span class="keyword">this</span>.fd =  Net.serverSocket(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// fd的真实地址</span></span><br><span class="line">    <span class="keyword">this</span>.fdVal = IOUtil.fdVal(fd);</span><br><span class="line">    <span class="keyword">this</span>.state = ST_INUSE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ServerSocketChannel <span class="title">bind</span><span class="params">(SocketAddress local, <span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      InetSocketAddress isa = (local == <span class="keyword">null</span>) ? <span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>) :</span><br><span class="line">          Net.checkAddress(local);</span><br><span class="line">      SecurityManager sm = System.getSecurityManager();</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="comment">//SDP相关的钩子，没看懂</span></span><br><span class="line">      NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());</span><br><span class="line">      <span class="comment">//实际调用的是net_util_md.c的NET_InetAddressToSockaddr 和NET_Bind</span></span><br><span class="line">      Net.bind(fd, isa.getAddress(), isa.getPort());</span><br><span class="line">      Net.listen(fd, backlog &lt; <span class="number">1</span> ? <span class="number">50</span> : backlog);</span><br><span class="line">      <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        localAddress = Net.localAddress(fd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SocketChannel <span class="title">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      SocketChannel sc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//connection fd，用于socket读写</span></span><br><span class="line">      FileDescriptor newfd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">      <span class="comment">//客户端地址</span></span><br><span class="line">      InetSocketAddress[] isaa = <span class="keyword">new</span> InetSocketAddress[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        begin();</span><br><span class="line">        <span class="keyword">if</span> (!isOpen())</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        thread = NativeThread.current();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          n = accept(<span class="keyword">this</span>.fd, newfd, isaa);</span><br><span class="line">          <span class="comment">//遇到EINTR，忽略且继续监听</span></span><br><span class="line">          <span class="keyword">if</span> ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        thread = <span class="number">0</span>;</span><br><span class="line">        end(n &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">assert</span> IOStatus.check(n);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//默认connection fd阻塞，后面需要非阻塞读写则重新设为O_NONBLOCK</span></span><br><span class="line">      IOUtil.configureBlocking(newfd, <span class="keyword">true</span>);</span><br><span class="line">      InetSocketAddress isa = isaa[<span class="number">0</span>];</span><br><span class="line">      sc = <span class="keyword">new</span> SocketChannelImpl(provider(), newfd, isa);</span><br><span class="line">      SecurityManager sm = System.getSecurityManager();</span><br><span class="line">      <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sc;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Net.c算是把Linux的socket编程都写了一遍了，部分是ipv6&amp;udp的设置，我个人不是很了解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Net.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_sun_nio_ch_Net_socket0(JNIEnv *env, jclass cl, jboolean preferIPv6,</span><br><span class="line">                            jboolean stream, jboolean reuse, jboolean ignored)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> type = (stream ? SOCK_STREAM : SOCK_DGRAM);</span><br><span class="line">  <span class="comment">//参数参考上述内容</span></span><br><span class="line">  fd = socket(domain, type, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> handleSocketError(env, errno);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//默认ipv4与ipv6能监听同一端口</span></span><br><span class="line">  setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (<span class="keyword">char</span>*)&amp;arg, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果是UDP协议（以下省略部分代码，可以阅读openjdk9的完整代码）</span></span><br><span class="line">  <span class="comment">//不支持IP_MULTICAST_ALL，这个是linux2.6的非标准选项，被人喷了一脸血</span></span><br><span class="line">  <span class="comment">//int level = (domain == AF_INET6) ? IPPROTO_IPV6 : IPPROTO_IP;</span></span><br><span class="line">  setsockopt(fd, level, IP_MULTICAST_ALL, (<span class="keyword">char</span>*)&amp;arg, <span class="keyword">sizeof</span>(arg));</span><br><span class="line">  <span class="comment">//支持IPv6组播</span></span><br><span class="line">  setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &amp;arg, <span class="keyword">sizeof</span>(arg));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//server是允许reuseadd的，client不允许</span></span><br><span class="line">  setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">char</span>*)&amp;arg, <span class="keyword">sizeof</span>(arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ServerSocketChannelImpl.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> JNIEXPORT jint JNICALL</span><br><span class="line"> Java_sun_nio_ch_ServerSocketChannelImpl_accept0(JNIEnv *env, jobject <span class="keyword">this</span>,</span><br><span class="line">                                                 jobject ssfdo, jobject newfdo,</span><br><span class="line">                                                 jobjectArray isaa)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="comment">//出现ECONNABORTED则忽略，继续accept，用户代码不需要对RST做出处理。</span></span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">     <span class="keyword">socklen_t</span> sa_len = alloc_len;</span><br><span class="line">     newfd = accept(ssfd, sa, &amp;sa_len);</span><br><span class="line">     <span class="keyword">if</span> (newfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (errno != ECONNABORTED) &#123;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (newfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">free</span>((<span class="keyword">void</span> *)sa);</span><br><span class="line">     <span class="comment">//IOS_** 同等IOStatus.java中的常量</span></span><br><span class="line">     <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">       <span class="keyword">return</span> IOS_UNAVAILABLE;</span><br><span class="line">     <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">       <span class="keyword">return</span> IOS_INTERRUPTED;</span><br><span class="line">     JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Accept failed"</span>);</span><br><span class="line">     <span class="keyword">return</span> IOS_THROWN;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>客户端的连接就很简单了，并不难，方法看似很长重点也就那么几行，JNI的代码就不贴了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(SocketAddress sa)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    InetAddress ia = isa.getAddress();</span><br><span class="line">    <span class="keyword">if</span> (ia.isAnyLocalAddress())</span><br><span class="line">      ia = InetAddress.getLocalHost();</span><br><span class="line">    n = Net.connect(fd,</span><br><span class="line">                    ia,</span><br><span class="line">                    isa.getPort());</span><br><span class="line">    <span class="comment">//同样忽略RST错误</span></span><br><span class="line">    <span class="keyword">if</span> ((n == IOStatus.INTERRUPTED)</span><br><span class="line">          &amp;&amp; isOpen())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h4><p>留个位置</p><h4 id="ByteBuffer体系"><a href="#ByteBuffer体系" class="headerlink" title="ByteBuffer体系"></a>ByteBuffer体系</h4><p>从继承关系来看，其实并不复杂，数据结构也很简单，但对于<code>malloc</code>和<code>allocateDirect</code>分配的空间在进程虚拟内存所处的位置却很值得拿出来探讨一番，因为涉及NIO是否真实现了<code>零拷贝</code>。</p><p><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/ByteBuffer.png" alt="ByteBuffer"></p><h5 id="Buffer的指针"><a href="#Buffer的指针" class="headerlink" title="Buffer的指针"></a>Buffer的指针</h5><p>就是个对数组操作的容器，内部的指针也很容易理解，直接上图上源码，不多做解释。</p><p><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/bytebuffer%E6%8C%87%E9%92%88.png" alt="Buffer的指针"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">  <span class="comment">//标记读取or写入位置</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//已读已写的位置</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//最大极限</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line">  <span class="comment">//容器容量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">  <span class="comment">//重设位置</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newPosition &gt; limit) || (newPosition &lt; <span class="number">0</span>))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    position = newPosition;</span><br><span class="line">    <span class="comment">//标记位超过新位置，重置为-1</span></span><br><span class="line">    <span class="keyword">if</span> (mark &gt; position) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//与position(int)方法同理</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class="number">0</span>))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    limit = newLimit;</span><br><span class="line">    <span class="comment">//如果位置超出新限制，则重合pos和limit</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt; limit) position = limit;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; limit) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h4><p>都是一些读读写写的操作，不做讲述了。</p><h4 id="HeapByteBuffer"><a href="#HeapByteBuffer" class="headerlink" title="HeapByteBuffer"></a>HeapByteBuffer</h4><p>其实就是个byte[]，这个确实没什么好讲的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapByteBuffer</span> <span class="keyword">extends</span> <span class="title">ByteBuffer</span> </span>&#123;</span><br><span class="line">  HeapByteBuffer(<span class="keyword">int</span> cap, <span class="keyword">int</span> lim) &#123;</span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, lim, cap, <span class="keyword">new</span> <span class="keyword">byte</span>[cap], <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h4><p>正如类名所示direct，分配了java heap以外的「直接」内存，空间大小由JVM参数<code>-XX:MaxDirectMemorySize</code>控制，默认64m。我一开始认为jvm应该会根据这个参数在进程里面分配相对于的vm_area_struct，与heap相似的管理方式。直到我看到下面<code>DirectByteBuffer</code>的构造方法，吃了一鲸，并不是我想象中那样，而是DirectMemory分配的控制是交给java控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectByteBuffer</span> <span class="keyword">extends</span> <span class="title">MappedByteBuffer</span> <span class="keyword">implements</span> <span class="title">DirectBuffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="comment">//是否对齐页面，一般设置为false，-XX:+PageAlignDirectMemory控制</span></span><br><span class="line">    <span class="comment">//如果对齐，最后的address是个页面上边框的地址，有利于页面查找效率</span></span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//这里会尝试分配空间，假如空间不足会执行Cleaner做清理后再次尝试分配</span></span><br><span class="line">    <span class="comment">//上面失败后，会进入自旋9次，若成功则返回，失败抛出OOM</span></span><br><span class="line">    <span class="comment">//关于这个方法可以参考JVM大佬寒泉子的http://lovestblog.cn/blog/2015/05/12/direct-buffer/</span></span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//看JNI代码可以看到jvm声明了自己的方法os::malloc进行内存分配</span></span><br><span class="line">      base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">      Bits.unreserveMemory(size, cap);</span><br><span class="line">      <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将内存全部置零</span></span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">// Round up to page boundary</span></span><br><span class="line">      address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方我一直很让我纠结，这个「直接」内存是分配在进程的堆区还是在映射区（忽略malloc()大于128k使用mmap()），自己又实在不想浪费心力过分研读JVM源码。如果正用了malloc，DirectByteBuffer并非所谓实现Linux零拷贝。</p><p>如果是在进程堆区，最后还是要拷贝至内核空间，参考FileChannel的map()，JNI毫不吝啬直接调用mmap()，所以看到os::malloc我很疑惑是否仅仅直接交给glibc进行内存分配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory(JNIEnv *env, jobject unsafe, jlong size))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_AllocateMemory"</span>);</span><br><span class="line">  <span class="keyword">size_t</span> sz = (<span class="keyword">size_t</span>)size;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (sz == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sz = round_to(sz, HeapWordSize);</span><br><span class="line">  <span class="keyword">void</span>* x = os::<span class="built_in">malloc</span>(sz, mtInternal);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//Copy::fill_to_words((HeapWord*)x, sz / HeapWordSize);</span></span><br><span class="line">  <span class="keyword">return</span> addr_to_java(x);</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> NIO </tag>
            
            <tag> Linux内核 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Spring源码分析】BeanFactory体系的作用</title>
      <link href="/2018/11/23/20181123-%E3%80%90Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91BeanFactory%E4%BD%93%E7%B3%BB%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2018/11/23/20181123-%E3%80%90Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91BeanFactory%E4%BD%93%E7%B3%BB%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>最近静下心开始研读spring源码，从容器开始，直入眼帘的就是BeanFactory这个终极boss。通过BeanFactory及其子接口能得知不同的注入方式与获取方式，在尝试拓展自己的实例化时，有必要的用处。</p><hr><p>先看看<code>BeanFactory</code>的最终实现类<code>DefaultListableBeanFactory</code>，生成出来的类关系图，看起来相当的复杂。本文暂且只讨论<code>BeanFactory</code>本身，与一代子接口<code>AutowireCapableBeanFactory</code>、<code>HierarchicalBeanFactory</code>、<code>ListableBeanFactory</code>，还有个<code>ConfigurableBeanFactory</code>实在不想展开讲，东西有点多。</p><p><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/DefaultListableBeanFactory.png" alt="DefaultListableBeanFactory类图"></p><ul><li>BeanFactory顶级父类</li></ul><p>作为顶级接口，提供了工厂的一切基本操作，获取实例、判断实例种类、类型、是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">//FactoryBean的转义附，一种在Spring中特色的Bean，后头会讲到</span></span><br><span class="line">  <span class="comment">//这里未被转义的都是我们认知的普通Bean</span></span><br><span class="line">  String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 以下提供了5种获取Bean的方法：</span></span><br><span class="line"><span class="comment">   * 1、通过BeanName，在获取xml中的bean id时比较常用，常常id唯一</span></span><br><span class="line"><span class="comment">   * 2、通过BeanName与类型，通过类型校验，避免同名不同类的错误</span></span><br><span class="line"><span class="comment">   * 3、通过BeanName与构造方法参数获取</span></span><br><span class="line"><span class="comment">   * 4、通过类型获取，依然有可能出现多Bean的错误</span></span><br><span class="line"><span class="comment">   * 5、通过类型与构造方法参数获取</span></span><br><span class="line"><span class="comment">   * 带构造方法参数的获取方法，一般用在non-singleton的Bean</span></span><br><span class="line"><span class="comment">   * 具体可以看@Scope的说明</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">   T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">   <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * ObjectProvider是spring 4.3提供的注入方式，针对构造方法依赖注入做的可选方式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line">   &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查找是否存在Bean，本容器没有，会往上一层继续找</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line">  <span class="comment">//是否单例</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">  <span class="comment">//是否原型</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">  <span class="comment">//是否有匹配的类型</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">  String[] getAliases(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AutowireCapableBeanFactory，使spring容器外的实例对象可以优雅地使用容器内的任意一个Bean。</li></ul><p>该接口在用户代码中很少会用到，但由于需要集成其他框架时，可以优雅的实例化prototype，具体可以常见quartz的Job接口，Job的实现类不在容器中也能注入使用@Autowire。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">//成员变量使用@Autowire，可以不指定注入模式</span></span><br><span class="line">  <span class="keyword">int</span> AUTOWIRE_NO = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//以下两种针对不使用注解与构造方法，必须有seter方法</span></span><br><span class="line">  <span class="keyword">int</span> AUTOWIRE_BY_NAME = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> AUTOWIRE_BY_TYPE = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//通过没有注解且有构造器</span></span><br><span class="line">  <span class="keyword">int</span> AUTOWIRE_CONSTRUCTOR = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="keyword">int</span> AUTOWIRE_AUTODETECT = <span class="number">4</span>;</span><br><span class="line">  String ORIGINAL_INSTANCE_SUFFIX = <span class="string">".ORIGINAL"</span>;</span><br><span class="line">  <span class="comment">//以下方法均是装配existingBean，不同方法的实现可以阅读AbstractAutowireCapableBeanFactory</span></span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">createBean</span><span class="params">(Class&lt;T&gt; beanClass)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">autowireBean</span><span class="params">(Object existingBean)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">  <span class="function">Object <span class="title">configureBean</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">  <span class="function">Object <span class="title">createBean</span><span class="params">(Class&lt;?&gt; beanClass, <span class="keyword">int</span> autowireMode, <span class="keyword">boolean</span> dependencyCheck)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">  <span class="function">Object <span class="title">autowire</span><span class="params">(Class&lt;?&gt; beanClass, <span class="keyword">int</span> autowireMode, <span class="keyword">boolean</span> dependencyCheck)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">autowireBeanProperties</span><span class="params">(Object existingBean, <span class="keyword">int</span> autowireMode, <span class="keyword">boolean</span> dependencyCheck)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">  <span class="comment">//以下是对实例化对象的后处理</span></span><br><span class="line">  <span class="function">Object <span class="title">initializeBean</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">  <span class="function">Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">  <span class="function">Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">destroyBean</span><span class="params">(Object existingBean)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>HierarchicalBeanFactory，获取上一层的容器</li></ul><p>该方法是为了容器的分层，差不多父xml与子xml的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HierarchicalBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">BeanFactory <span class="title">getParentBeanFactory</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsLocalBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ListableBeanFactory，可列表化的工厂</li></ul><p>该接口提供的方法，都能让你简单粗暴地获取你想要的local bean，无需通过bean一个一个找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">//查找beanName是否存在</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line">  <span class="comment">//获取beanDefinitionMap.size()</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//获取所有BeanName，在配置被冻结之前，获取的列表可能会变化</span></span><br><span class="line">  String[] getBeanDefinitionNames();</span><br><span class="line">  String[] getBeanNamesForType(ResolvableType type);</span><br><span class="line">  String[] getBeanNamesForType(<span class="meta">@Nullable</span> Class&lt;?&gt; type);</span><br><span class="line">  String[] getBeanNamesForType(<span class="meta">@Nullable</span> Class&lt;?&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit);</span><br><span class="line">  <span class="comment">//获取beanName-bean的Map</span></span><br><span class="line">  <span class="comment">//includeNonSingletons是否包含non-singleton的Bean</span></span><br><span class="line">  <span class="comment">//allowEagerInit是否对懒加载的Bean进行初始化</span></span><br><span class="line">  &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(@Nullable Class&lt;T&gt; type)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">  &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(@Nullable Class&lt;T&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">  <span class="comment">//下面的均是找到对应注解的Bean</span></span><br><span class="line">  String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; annotationType);</span><br><span class="line">  <span class="function">Map&lt;String, Object&gt; <span class="title">getBeansWithAnnotation</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  &lt;A extends Annotation&gt; <span class="function">A <span class="title">findAnnotationOnBean</span><span class="params">(String beanName, Class&lt;A&gt; annotationType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为Spring容器本身太复杂，所以本文就着BeanFactory接口，说明了不同接口的作用，还未深入具体其实现。<br>希望后续的几篇文章能加快进度，尽快理清spring每个体系的关系。</p>]]></content>
      
      
      <categories>
          
          <category> Spring源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java　 </tag>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
            <tag> IOC控制反转 </tag>
            
            <tag> BeanFactory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Dubbo源码分析】四种负载均衡</title>
      <link href="/2018/09/06/20180906-%E3%80%90Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E5%9B%9B%E7%A7%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2018/09/06/20180906-%E3%80%90Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E5%9B%9B%E7%A7%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<p>Dubbo选择在客户端做负载均衡，提供了四种选择：随机、轮询、最少活跃调用数、一致性Hash。四种算法简单且有趣，可以稍微研究以下。</p><hr><p>首先<code>LoadBalance</code>接口是一个SPI，<code>select()</code>方法被声明为Adaptive，通过URL参数找到对应的负载均衡方式，如果以下四种无法满足，可以自行拓展。</p><ul><li>AbstractLoadBalance的模版方法</li></ul><p>抽象类只提供了一个模版方法，具体的均衡策略由doSelect实现，<code>getWeight</code>是一个公用的计算权重方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLoadBalance</span> <span class="keyword">implements</span> <span class="title">LoadBalance</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateWarmupWeight</span><span class="params">(<span class="keyword">int</span> uptime, <span class="keyword">int</span> warmup, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//uptime：运行时间</span></span><br><span class="line">    <span class="comment">//warmup：预热时间</span></span><br><span class="line">    <span class="comment">//ww = 权重 * 运行时间／预热时间</span></span><br><span class="line">    <span class="comment">//在预热时间内，ww与运行时间成正比，uptime越短，权重越小</span></span><br><span class="line">    <span class="comment">//超出预热时间，返回预设权重</span></span><br><span class="line">    <span class="keyword">int</span> ww = (<span class="keyword">int</span>) ((<span class="keyword">float</span>) uptime / ((<span class="keyword">float</span>) warmup / (<span class="keyword">float</span>) weight));</span><br><span class="line">    <span class="keyword">return</span> ww &lt; <span class="number">1</span> ? <span class="number">1</span> : (ww &gt; weight ? weight : ww);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//模版方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty())</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> doSelect(invokers, url, invocation);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);</span><br><span class="line">    <span class="keyword">if</span> (weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//获取启动时间</span></span><br><span class="line">      <span class="keyword">long</span> timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, <span class="number">0L</span>);</span><br><span class="line">      <span class="keyword">if</span> (timestamp &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="comment">//获取运行时间</span></span><br><span class="line">        <span class="keyword">int</span> uptime = (<span class="keyword">int</span>) (System.currentTimeMillis() - timestamp);</span><br><span class="line">        <span class="comment">//预热时间</span></span><br><span class="line">        <span class="keyword">int</span> warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);</span><br><span class="line">        <span class="comment">//未达到预热时间，则根据运行时间长短重新计算权重</span></span><br><span class="line">        <span class="keyword">if</span> (uptime &gt; <span class="number">0</span> &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class="line">          weight = calculateWarmupWeight(uptime, warmup, weight);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RandomLoadBalance随机访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> length = invokers.size(); <span class="comment">//调用者数量</span></span><br><span class="line">  <span class="keyword">int</span> totalWeight = <span class="number">0</span>; <span class="comment">//权重总额</span></span><br><span class="line">  <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>; <span class="comment">//是否每个调用者的权重都是相等的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class="line">    totalWeight += weight; <span class="comment">//求和</span></span><br><span class="line">    <span class="comment">//出现相邻的调用者权重不等，则sameWeight为否</span></span><br><span class="line">    <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></span><br><span class="line">          &amp;&amp; weight != getWeight(invokers.get(i - <span class="number">1</span>), invocation)) &#123;</span><br><span class="line">      sameWeight = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//以下的逻辑需要列一个表，可能会清晰一些</span></span><br><span class="line">  <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">    <span class="comment">//得到一个【0, totalWeight)的随机数</span></span><br><span class="line">    <span class="keyword">int</span> offset = random.nextInt(totalWeight);</span><br><span class="line">    <span class="comment">//循环依次减去调用者权重，直到offset&lt;0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      offset -= getWeight(invokers.get(i), invocation);</span><br><span class="line">      <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> invokers.get(random.nextInt(length));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码什么意思呢？我们稍微列一下。</p><p>假设，ABC三个节点，权重分别是1，2，3，那totalWeight = 6，则offset取值范围是[0,6)。<br>那么，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">offset  A:1    B:2    C:3</span><br><span class="line">     0  0-1&lt;0                选A</span><br><span class="line">     1  1-1&#x3D;0 0-2&lt;0       选B</span><br><span class="line">     2  2-1&#x3D;1 1-2&lt;0       选B</span><br><span class="line">     3  3-1&#x3D;2 2-2&#x3D;00-3&lt;0  选C</span><br><span class="line">     4  4-1&#x3D;3 3-2&#x3D;11-3&lt;0  选C</span><br><span class="line">     5  5-1&#x3D;4  4-2&#x3D;22-3&lt;0  选C</span><br></pre></td></tr></table></figure><p>可见ABC被分配到的概率也是1、2、3。</p><ul><li>RoundRobinLoadBalance权重比例轮训</li></ul><p>按照权重轮训，这个负载均衡的方式可以说是十分坑爹，按照文档里的说法是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</span><br></pre></td></tr></table></figure><p>就是会出现某台机子的活跃度非常高，而且还不断的把请求丢给这台机器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">  String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">"."</span> + invocation.getMethodName();</span><br><span class="line">  <span class="keyword">int</span> length = invokers.size(); <span class="comment">//调用者数量</span></span><br><span class="line">  <span class="keyword">int</span> maxWeight = <span class="number">0</span>; <span class="comment">//最大最小权重</span></span><br><span class="line">  <span class="keyword">int</span> minWeight = Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">final</span> LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; invokerToWeightMap = <span class="keyword">new</span> LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt;();</span><br><span class="line">  <span class="keyword">int</span> weightSum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class="line">    maxWeight = Math.max(maxWeight, weight);</span><br><span class="line">    minWeight = Math.min(minWeight, weight);<span class="comment">//找出最大最小权重</span></span><br><span class="line">    <span class="keyword">if</span> (weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      invokerToWeightMap.put(invokers.get(i), <span class="keyword">new</span> IntegerWrapper(weight));</span><br><span class="line">      weightSum += weight;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  AtomicPositiveInteger sequence = sequences.get(key);</span><br><span class="line">  <span class="keyword">if</span> (sequence == <span class="keyword">null</span>) &#123;</span><br><span class="line">    sequences.putIfAbsent(key, <span class="keyword">new</span> AtomicPositiveInteger());</span><br><span class="line">    sequence = sequences.get(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//下面通过mod和weight不断递减1，依次轮训调用</span></span><br><span class="line">  <span class="comment">//A:1 B:2 C:3 D:2，调用量：7</span></span><br><span class="line">  <span class="comment">//则轮训调用A1次，B2次，C3次，D1次</span></span><br><span class="line">  <span class="keyword">int</span> currentSequence = sequence.getAndIncrement();</span><br><span class="line">  <span class="keyword">if</span> (maxWeight &gt; <span class="number">0</span> &amp;&amp; minWeight &lt; maxWeight) &#123;</span><br><span class="line">    <span class="keyword">int</span> mod = currentSequence % weightSum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxWeight; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; each : invokerToWeightMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">final</span> Invoker&lt;T&gt; k = each.getKey();</span><br><span class="line">        <span class="keyword">final</span> IntegerWrapper v = each.getValue();</span><br><span class="line">        <span class="keyword">if</span> (mod == <span class="number">0</span> &amp;&amp; v.getValue() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v.getValue() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          v.decrement();</span><br><span class="line">          mod--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> invokers.get(currentSequence % length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LeastActiveLoadBalance最低活跃量</li></ul><p>这种方式需要配合<code>ActiveLimitFilter</code>一起使用，有一点要注意，这个活跃度是针对客户端而言，它并没有通过zk同步每个终端调用量来得到服务端的真实负载，这个拦截器仅仅作为客户端限流用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> length = invokers.size(); <span class="comment">//调用者数量</span></span><br><span class="line">  <span class="keyword">int</span> leastActive = -<span class="number">1</span>; <span class="comment">//最低活跃度</span></span><br><span class="line">  <span class="keyword">int</span> leastCount = <span class="number">0</span>; <span class="comment">//多少相同最低活跃度</span></span><br><span class="line">  <span class="keyword">int</span>[] leastIndexs = <span class="keyword">new</span> <span class="keyword">int</span>[length]; <span class="comment">//记录相等最低活跃度的调用者下标</span></span><br><span class="line">  <span class="keyword">int</span> totalWeight = <span class="number">0</span>; <span class="comment">//相同最低活跃度的权重总额</span></span><br><span class="line">  <span class="keyword">int</span> firstWeight = <span class="number">0</span>; <span class="comment">// Initial value, used for comparision</span></span><br><span class="line">  <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>; <span class="comment">//相同最低活跃度的调用者权重是否相等</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class="line">    <span class="keyword">int</span> active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); <span class="comment">// Active number</span></span><br><span class="line">    <span class="keyword">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); <span class="comment">// Weight</span></span><br><span class="line">    <span class="keyword">if</span> (leastActive == -<span class="number">1</span> || active &lt; leastActive) &#123; <span class="comment">// Restart, when find a invoker having smaller least active value.</span></span><br><span class="line">      leastActive = active; <span class="comment">//记录新的最低活跃度</span></span><br><span class="line">      leastCount = <span class="number">1</span>;</span><br><span class="line">      leastIndexs[<span class="number">0</span>] = i; <span class="comment">//重置</span></span><br><span class="line">      totalWeight = weight; <span class="comment">//重置</span></span><br><span class="line">      firstWeight = weight; <span class="comment">//重置</span></span><br><span class="line">      sameWeight = <span class="keyword">true</span>; <span class="comment">// 重置</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (active == leastActive) &#123; <span class="comment">// If current invoker's active value equals with leaseActive, then accumulating.</span></span><br><span class="line">      leastIndexs[leastCount++] = i;</span><br><span class="line">      totalWeight += weight; <span class="comment">//累加权重</span></span><br><span class="line">      <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; weight != firstWeight) &#123;</span><br><span class="line">        sameWeight = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//最低活跃度只有一个，那那肯定是它</span></span><br><span class="line">  <span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> invokers.get(leastIndexs[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//下面这一步不用多说了，与RandomLoadBalance一摸一样</span></span><br><span class="line">  <span class="comment">//最低活跃度相同的调用这，以权重比例随机访问</span></span><br><span class="line">  <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> offsetWeight = random.nextInt(totalWeight);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> leastIndex = leastIndexs[i];</span><br><span class="line">      offsetWeight -= getWeight(invokers.get(leastIndex), invocation);</span><br><span class="line">      <span class="keyword">if</span> (offsetWeight &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> invokers.get(leastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> invokers.get(leastIndexs[random.nextInt(leastCount)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ConsistentHashLoadBalance一致性哈希</li></ul><p>这个其实没什么好说的，源码只是计算hash值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一致性 Hash，相同参数的请求总是发到同一提供者。</span><br><span class="line">当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rpc框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java　 </tag>
            
            <tag> Dubbo </tag>
            
            <tag> rpc </tag>
            
            <tag> 负载均衡 </tag>
            
            <tag> LoadBalance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Dubbo源码分析】SPI机制，将URL与可插拔拓展融合到极致</title>
      <link href="/2018/09/02/20180902-%E3%80%90Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91SPI%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%B0%86URL%E4%B8%8E%E5%8F%AF%E6%8F%92%E6%8B%94%E6%8B%93%E5%B1%95%E8%9E%8D%E5%90%88%E5%88%B0%E6%9E%81%E8%87%B4/"/>
      <url>/2018/09/02/20180902-%E3%80%90Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91SPI%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%B0%86URL%E4%B8%8E%E5%8F%AF%E6%8F%92%E6%8B%94%E6%8B%93%E5%B1%95%E8%9E%8D%E5%90%88%E5%88%B0%E6%9E%81%E8%87%B4/</url>
      
        <content type="html"><![CDATA[<p>开始啃Dubbo时候，对其功能多样被吓到，若干功能由xml配置可任意组装，担心其复杂度过高，源码难啃。当我开始啃启动步骤的代码后，发现<code>ExtensionLoader</code>经常出现在较重要实例化的地方。<br>是的，<code>ExtensionLoader、@SPI、@Adaptive、@Activate</code>可以说是Dubbo的核心，<code>Cluster、Protocol、Filter</code>等接口都被声明为SPI，什么作用呢？能根据配置动态调用被声明为SPI接口的实现类，dubbo提供了URL方式作为参数配置。</p><hr><p>其实SPI的应用跟实现逻辑是相当简单的，但很巧妙，正文的源码分析部分只罗列出主要方法，以及简单说明其作用。</p><ul><li>先来看@SPI</li></ul><p>每个要成为拓展点的接口都需要被声明SPI，ExtensionLoader只加载有该注解的接口，SPI可以设置一个默认值，指向META-INF中拓展点文件的key值，如果你在url所配的参数找不到会走默认。</p><ul><li>@Adaptive</li></ul><p>该注解能作用在类型与方法：作用于方法，默认URL作为匹配方法；作用于类型，可自定义匹配方式，不一定要URL。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.URL;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.extension.Adaptive;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.extension.SPI;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SPI("默认值")</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span>(<span class="string">"default_1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestAdaptiveExt</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Adaptive(&#123;参数名数组&#125;)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Adaptive</span>(&#123;<span class="string">"key_name_1"</span>&#125;)</span><br><span class="line">  <span class="function">String <span class="title">getChlidInfo</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAdaptiveExtImpl1</span> <span class="keyword">implements</span> <span class="title">TestAdaptiveExt</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getChlidInfo</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test1"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAdaptiveExtImpl2</span> <span class="keyword">implements</span> <span class="title">TestAdaptiveExt</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getChlidInfo</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test2"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdaptive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ExtensionLoader&lt;TestAdaptiveExt&gt; loader = ExtensionLoader.getExtensionLoader(TestAdaptiveExt<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  TestAdaptiveExt testAdaptiveExt = loader.getAdaptiveExtension();</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 控制台输出：test2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  URL url = URL.valueOf(<span class="string">"test://localhost/test?Adaptive_key_name=default_2"</span>);</span><br><span class="line">  System.out.println(testAdaptiveExt.getChlidInfo(url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resources/META-INF/dubbo/internal/com.hongframe.extension.TestAdaptiveExt</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default_1</span>=<span class="string">com.hongframe.extension.impl.TestAdaptiveExtImpl1</span></span><br><span class="line"><span class="attr">default_2</span>=<span class="string">com.hongframe.extension.impl.TestAdaptiveExtImpl2</span></span><br></pre></td></tr></table></figure><ul><li>@Activate</li></ul><p>Activate提供了<code>group、value、before、after、order</code>，除前两个用来筛选外，其余三个均排序，该注解只能作用于类型，方法无效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestActivateExt</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Activate</span>(value = <span class="string">"key_name_1"</span>, group = <span class="string">"xxx_group"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivateExtImpl1</span> <span class="keyword">implements</span> <span class="title">TestActivateExt</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"TestActivateExtImpl1"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Activate</span>(<span class="string">"key_name_2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivateExtImpl2</span> <span class="keyword">implements</span> <span class="title">TestActivateExt</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"TestActivateExtImpl2"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testActivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ExtensionLoader&lt;TestActivateExt&gt; testActivateExtExtensionLoader = ExtensionLoader.getExtensionLoader(TestActivateExt<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  URL url = URL.valueOf(<span class="string">"test://localhost/test"</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 此处，对于Activate，URI的key=value只能被key激活，但对相同key的Adaptive方法能达到组合效果</span></span><br><span class="line"><span class="comment">   * 参考CacheFilter与CacheFactory的用法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 这里有个值得注意的地方：</span></span><br><span class="line"><span class="comment">   * 如果给url添加key_name_1=&lt;-default,...,...&gt;作为参数的话，是不匹配Activate.value的，转而匹配配置文件中的key，例如active1，active2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  url = url.addParameter(<span class="string">"key_name_1"</span>, <span class="string">"default_1"</span>);</span><br><span class="line">  List&lt;TestActivateExt&gt; testActivateExts = testActivateExtExtensionLoader.getActivateExtension(url, <span class="string">"key_name_1"</span>);</span><br><span class="line">  <span class="keyword">for</span>(TestActivateExt ext : testActivateExts)</span><br><span class="line">   System.out.println(ext.print());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resources/META-INF/dubbo/internal/com.hongframe.extension.TestActivateExt</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">active1</span>=<span class="string">com.hongframe.extension.impl.TestActivateExtImpl1</span></span><br><span class="line"><span class="attr">active2</span>=<span class="string">com.hongframe.extension.impl.TestActivateExtImpl2</span></span><br></pre></td></tr></table></figure><ul><li>正题，源码分析</li></ul><p>Dubbo为每个拓展点准备一个ExtensionLoader，将DUBBO_INTERNAL_DIRECTORY、SERVICES_DIRECTORY下的配置文件全部缓存到以下成员变量中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtensionLoader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//一个拓展点一个ExtensionLoader</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;();</span><br><span class="line">  <span class="comment">//拓展点实现类的实例化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ==============================</span></span><br><span class="line">  <span class="comment">//拓展点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ExtensionFactory objectFactory;</span><br><span class="line">  <span class="comment">//缓存拓展点实现的名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class="line">  <span class="comment">//缓存拓展点的实现类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = <span class="keyword">new</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;();</span><br><span class="line">  <span class="comment">//实现类的Activate注解配置</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Activate&gt; cachedActivates = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Activate&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;();</span><br><span class="line">  <span class="comment">//至关重要的，通过代码注入后得到实例化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Object&gt; cachedAdaptiveInstance = <span class="keyword">new</span> Holder&lt;Object&gt;();</span><br><span class="line">  <span class="comment">//拓展点实现类被声明为Adaptive，至多一个</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Class&lt;?&gt; cachedAdaptiveClass = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//SPI("cachedDefaultName") 默认实现类key值</span></span><br><span class="line">  <span class="keyword">private</span> String cachedDefaultName;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Throwable createAdaptiveInstanceError;</span><br><span class="line">  <span class="comment">//拓展点包装类</span></span><br><span class="line">  <span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">//非空</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isInterface()) &#123;</span><br><span class="line">      <span class="comment">//必须是接口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class="line">        <span class="comment">//必须声明@SPI</span></span><br><span class="line">    &#125;</span><br><span class="line">    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loader;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getAdaptiveExtension</code>获取拓展点实例化对象，这里会动态实例化一个拓展点实现，将其set入Holder，这个对象包装了拓展点基础的实现类，成为一个动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (createAdaptiveInstanceError == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">        instance = cachedAdaptiveInstance.get();</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建Adaptive拓展点接口的实例对象</span></span><br><span class="line">            instance = createAdaptiveExtension();</span><br><span class="line">            cachedAdaptiveInstance.set(instance);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            createAdaptiveInstanceError = t;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"fail to create adaptive instance: "</span> + t.toString(), t);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//IllegalStateException</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//向拓展点的成员变量注入对象</span></span><br><span class="line">    <span class="keyword">return</span> injectExtension(</span><br><span class="line">        <span class="comment">//加载，动态生成code，编译，实例化</span></span><br><span class="line">        (T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not create adaptive extension "</span> + type + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">  <span class="comment">//加载成员变量type指定的配置文件</span></span><br><span class="line">  getExtensionClasses();</span><br><span class="line">  <span class="keyword">if</span> (cachedAdaptiveClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//初始化：生成拓展点实现类代码，以TestAdaptiveExt为例</span></span><br><span class="line">  <span class="keyword">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createAdaptiveExtensionClass()</code>方法生成的TestAdaptiveExt实现类，详细逻辑自行阅读<code>createAdaptiveExtensionClassCode()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hongframe.extension;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAdaptiveExt</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">hongframe</span>.<span class="title">extension</span>.<span class="title">TestAdaptiveExt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getChlidInfo</span><span class="params">(com.alibaba.dubbo.common.URL arg0)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">com.alibaba.dubbo.common.URL url = arg0;</span><br><span class="line">String extName = url.getParameter(<span class="string">"key_name_1"</span>, url.getParameter(<span class="string">"key_name_2"</span>));</span><br><span class="line"><span class="keyword">if</span>(extName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(com.hongframe.extension.TestAdaptiveExt) name from url("</span> + url.toString() + <span class="string">") use keys([key_name_1, key_name_2])"</span>);</span><br><span class="line">com.hongframe.extension.TestAdaptiveExt extension =</span><br><span class="line">(com.hongframe.extension.TestAdaptiveExt)ExtensionLoader</span><br><span class="line">.getExtensionLoader(com.hongframe.extension.TestAdaptiveExt<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">extName</span>)</span>;</span><br><span class="line"><span class="keyword">return</span> extension.getChlidInfo(arg0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是加载拓展点实现类的代码，主要通过META-INF里的配置文件找到相应的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">  <span class="comment">//省略单例双检代码</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  classes = loadExtensionClasses();</span><br><span class="line">  cachedClasses.set(classes);</span><br><span class="line">  <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// synchronized in getExtensionClasses</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">  <span class="keyword">final</span> SPI defaultAnnotation = type.getAnnotation(SPI<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="keyword">if</span> (defaultAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String value = defaultAnnotation.value();</span><br><span class="line">    <span class="keyword">if</span> ((value = value.trim()).length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//至多一个默认拓展实现类名</span></span><br><span class="line">      String[] names = NAME_SEPARATOR.split(value);</span><br><span class="line">      <span class="keyword">if</span> (names.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//IllegalStateException</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (names.length == <span class="number">1</span>) cachedDefaultName = names[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">  <span class="comment">//load配置文件</span></span><br><span class="line">  <span class="comment">//其中loadResource是很简单的词法解析器，loadClass则负责将实现类缓存在成员变量</span></span><br><span class="line">  loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);<span class="comment">//"META-INF/dubbo/internal/"</span></span><br><span class="line">  loadDirectory(extensionClasses, DUBBO_DIRECTORY);<span class="comment">//"META-INF/dubbo/"</span></span><br><span class="line">  loadDirectory(extensionClasses, SERVICES_DIRECTORY);<span class="comment">//"META-INF/services/"</span></span><br><span class="line">  <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL,//抛异常用的，没什么实际用处</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;?&gt; clazz,//配置文件中的value</span></span></span><br><span class="line"><span class="function"><span class="params">//配置文件中的key</span></span></span><br><span class="line"><span class="function"><span class="params">String name)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">  <span class="comment">//是否拓展点type的实现类</span></span><br><span class="line">  <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">    <span class="comment">//IllegalStateException</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//该拓展点实现类是否被声明为Adaptive</span></span><br><span class="line">  <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cachedAdaptiveClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">      cachedAdaptiveClass = clazz;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class="line">      <span class="comment">//IllegalStateException，只能声明一个实现类</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否为包装类</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">    <span class="keyword">if</span> (wrappers == <span class="keyword">null</span>) &#123;</span><br><span class="line">      cachedWrapperClasses = <span class="keyword">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">      wrappers = cachedWrapperClasses;</span><br><span class="line">    &#125;</span><br><span class="line">    wrappers.add(clazz);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//这一步是加载被声明为Activate的实现累的</span></span><br><span class="line">    clazz.getConstructor();</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//其中涉及到一个过期的注解@Extension</span></span><br><span class="line">      <span class="comment">//如果配置文件没有设置key值，将实现类simplename作为默认</span></span><br><span class="line">      name = findAnnotationName(clazz);</span><br><span class="line">      <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//IllegalStateException</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">    <span class="keyword">if</span> (names != <span class="keyword">null</span> &amp;&amp; names.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Activate activate = clazz.getAnnotation(Activate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (activate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cachedActivates.put(names[<span class="number">0</span>], activate);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class="line">          cachedNames.put(clazz, n);</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//把不同key相同class全都塞进去</span></span><br><span class="line">          extensionClasses.put(n, clazz);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != clazz) &#123;</span><br><span class="line">          <span class="comment">//IllegalStateException</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是获取Activate拓展实现的列表方法，通常这类拓展都是需要AOP来处理事情的，类似Filter接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url,</span></span></span><br><span class="line"><span class="function"><span class="params">//url的param-key列表</span></span></span><br><span class="line"><span class="function"><span class="params">String[] values, String group)</span> </span>&#123;</span><br><span class="line">  List&lt;T&gt; exts = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">  List&lt;String&gt; names = values == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">0</span>) : Arrays.asList(values);</span><br><span class="line">  <span class="comment">//这部分从url中拿去参数，匹配符合条件的拓展点</span></span><br><span class="line">  <span class="comment">//如果key=value，后者出现-default，则表示不走匹配URL的方式</span></span><br><span class="line">  <span class="keyword">if</span> (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123;</span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line">      String name = entry.getKey();</span><br><span class="line">      Activate activate = entry.getValue();</span><br><span class="line">      <span class="keyword">if</span> (isMatchGroup(group, activate.group())) &#123;</span><br><span class="line">        T ext = getExtension(name);</span><br><span class="line">        <span class="keyword">if</span> (!names.contains(name)</span><br><span class="line">              &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)</span><br><span class="line">              &amp;&amp; isActive(activate, url)) &#123;</span><br><span class="line">          exts.add(ext);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据before、after、order优先级依次排序</span></span><br><span class="line">    Collections.sort(exts, ActivateComparator.COMPARATOR);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//遍历values给到的参数</span></span><br><span class="line">  List&lt;T&gt; usrs = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class="line">      String name = names.get(i);</span><br><span class="line">      <span class="comment">//跳过被标记-的拓展点</span></span><br><span class="line">      <span class="keyword">if</span> (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)</span><br><span class="line">              &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (Constants.DEFAULT_KEY.equals(name)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (!usrs.isEmpty()) &#123;</span><br><span class="line">                exts.addAll(<span class="number">0</span>, usrs);</span><br><span class="line">                usrs.clear();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//注意，这里的name是配置文件中的key</span></span><br><span class="line">            T ext = getExtension(name);</span><br><span class="line">            usrs.add(ext);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!usrs.isEmpty()) &#123;</span><br><span class="line">    exts.addAll(usrs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> exts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>总结</li></ul><p>其实没多少可以总结的，dubbo的微内核其实就一个ExtensionLoader类，但弄清之后，可以较为清晰的研究dubbo各种功能的源码，因为其功能也是拓展点之一，只要找到对于实现即可。</p>]]></content>
      
      
      <categories>
          
          <category> rpc框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java　 </tag>
            
            <tag> Dubbo </tag>
            
            <tag> SPI </tag>
            
            <tag> 反射 </tag>
            
            <tag> rpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java并发】JUC—ReentrantReadWriteLock有坑，小心读锁！</title>
      <link href="/2018/07/02/20180702%20-%E3%80%90Java%E5%B9%B6%E5%8F%91%E3%80%91JUC%E2%80%94ReentrantReadWriteLock%E6%9C%89%E5%9D%91%EF%BC%8C%E5%B0%8F%E5%BF%83%E8%AF%BB%E9%94%81%EF%BC%81/"/>
      <url>/2018/07/02/20180702%20-%E3%80%90Java%E5%B9%B6%E5%8F%91%E3%80%91JUC%E2%80%94ReentrantReadWriteLock%E6%9C%89%E5%9D%91%EF%BC%8C%E5%B0%8F%E5%BF%83%E8%AF%BB%E9%94%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>好长一段时间前，某些场景需要JUC的读写锁，但在某个时刻内读写线程都报超时预警（长时间无响应），看起来像是锁竞争过程中出现死锁（我猜）。经过排查项目并没有能造成死锁的可疑之处，因为业务代码并不复杂（仅仅是一个计算过程），经几番折腾，把注意力转移到JDK源码，正文详细说下ReentrantReadWriteLock的隐藏坑点。</p><hr><p>过程大致如下：</p><ul><li>若干个读写线程抢占读写锁</li><li>读线程手脚快，优先抢占到读锁（其中少数线程任务较重，执行时间较长）</li><li>写线程随即尝试获取写锁，未成功，进入双列表进行等待</li><li>随后读线程也进来了，要去拿读锁</li></ul><p>问题：优先得到锁的读线程执行时间长达73秒，该时段写线程等待是理所当然的，那读线程也应该能够得到读锁才对，因为是共享锁，是吧？但预警结果并不是如此，超时任务线程中大部分为读。究竟是什么让读线程无法抢占到读锁，而导致响应超时呢？</p><p>把场景简化为如下的测试代码：读——写——读 线程依次尝试获取ReadWriteLock，用空转替换执行时间过长。</p><p>执行结果：控制台仅打印出<code>Thread[读线程 -- 1,5,main]</code>，既是说<code>读线程 -- 2</code>并没有抢占到读锁，跟上诉的表现似乎一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ReadWriteLockTest readWriteLockTest = <span class="keyword">new</span> ReadWriteLockTest();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReadWriteLockTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    TestLock testLock = <span class="keyword">new</span> TestLock();</span><br><span class="line">    Thread read1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ReadThread(testLock), <span class="string">"读线程 -- 1"</span>);</span><br><span class="line">    read1.start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    Thread write = <span class="keyword">new</span> Thread(<span class="keyword">new</span> WriteThread(testLock), <span class="string">"写线程 -- 1"</span>);</span><br><span class="line">    write.start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    Thread read2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ReadThread(testLock), <span class="string">"读线程 -- 2"</span>);</span><br><span class="line">    read2.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String string = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> Lock readLock = readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      writeLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                writeLock.tryLock(10, TimeUnit.SECONDS);</span></span><br><span class="line">        string = s;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      readLock.lock();</span><br><span class="line">      System.out.println(Thread.currentThread());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WriteThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestLock testLock;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WriteThread</span><span class="params">(TestLock testLock)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.testLock = testLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      testLock.set(<span class="string">"射不进去，怎么办？"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReadThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestLock testLock;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadThread</span><span class="params">(TestLock testLock)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.testLock = testLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      testLock.getString();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用<code>jstack</code>查看一下线程，看到读线程2和写线程1确实处于WAITING的状态。</p><p><img src="http://p4ygo03xz.bkt.clouddn.com/github-blog/image/jstack.png-50pencent" alt="jstack"></p><p>排查项目后，业务代码并没有问题，转而看下ReentrantReadWriteLock或AQS是否有什么问题被我忽略的。</p><p>第一时间关注共享锁，因为独占锁的实现逻辑我确定很清晰了，很快我似乎看到自己想要的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if(tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);</span></span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//计算stata，若独占锁被占，且持有锁非本线程，返回-1等待挂起</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">      getExclusiveOwnerThread() != current)</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//计算获取共享锁的线程数</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">//readerShouldBlock检查读线程是否要阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">      <span class="comment">//线程数必须少于65535</span></span><br><span class="line">      r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">      <span class="comment">//符合上诉两个条件，CAS(r, r+1)</span></span><br><span class="line">      compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">      <span class="comment">//下面的逻辑就不说了，很简单</span></span><br><span class="line">      <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">        firstReader = current;</span><br><span class="line">        firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        firstReaderHoldCount++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">          cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">          readHolds.set(rh);</span><br><span class="line">        rh.count++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，没错，方法<code>readerShouldBlock()</code>十分瞩目，几乎不用看上下文就定位到该方法。因为默认非公平锁，所以直接关注NonfairSync。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面方法在ASQ中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node h, s;</span><br><span class="line">  <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp; <span class="comment">//head非空</span></span><br><span class="line">      (s = h.next)  != <span class="keyword">null</span> &amp;&amp; <span class="comment">//后续节点非空</span></span><br><span class="line">      !s.isShared()         &amp;&amp; <span class="comment">//后续节点是否为写线程</span></span><br><span class="line">      s.thread != <span class="keyword">null</span>;        <span class="comment">//后续节点线程非空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>apparentlyFirstQueuedIsExclusive</code>什么作用，检查持锁线程head后续节点s是否为写锁，若真则返回true。结合<code>tryAcquireShared</code>的逻辑，如果true意味着读线程会被挂起无法共享锁。</p><p>这好像就说得通了，当持锁的是读线程时，跟随其后的是一个写线程，那么再后面来的读线程是无法获取读锁的，只有等待写线程执行完后，才能竞争。</p><p>这是jdk为了避免写线程过分饥渴，而做出的策略。但有坑点就是，如果某一读线程执行时间过长，甚至陷入死循环，后续线程会无限期挂起，严重程度堪比死锁。为避免这种情况，除了确保读线程不会有问题外，尽量用<code>tryLock</code>，超时我们可以做出响应。</p><p>当然也可以自己实现ReentrantReadWriteLock的读写锁竞争策略，但还是算了吧，遇到读远多于写的场景时，写线程饥渴带来的麻烦更大，表示踩过坑，别介。</p>]]></content>
      
      
      <categories>
          
          <category> java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java　 </tag>
            
            <tag> 并发编程 </tag>
            
            <tag> 同步 </tag>
            
            <tag> 读写锁 </tag>
            
            <tag> 线程饥渴 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java并发】JUC.lock包AbstractQueuedSynchronizer的源码分析（一）</title>
      <link href="/2018/02/27/20180227-%E3%80%90Java%E5%B9%B6%E5%8F%91%E3%80%91JUC-lock%E5%8C%85AbstractQueuedSynchronizer%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/02/27/20180227-%E3%80%90Java%E5%B9%B6%E5%8F%91%E3%80%91JUC-lock%E5%8C%85AbstractQueuedSynchronizer%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>平时开发不少使用<code>synchronized</code>，java提供了这个语法特性使用起来非常方便，但灵活性似乎不太好，因为它只是个独占且可重入锁，无法唤醒指定线程和实现共享等其他类型锁。</p><p>jdk提供了JUC这个并发包，里面就包含了功能更多的lock包，有ReentrantLock、ReentrantReadWriteLock等多功能锁，而实现这些锁的核心在于一个同步器AbstractQueuedSynchronizer（AQS）。</p><p>我们从AQS开始分析，了解一下jdk提供的公平锁、非公平锁、共享锁、独占锁、读写锁分别是怎么实现的。</p><hr><p>咱先来看下ReentrantLock怎么用的，语义上跟synchronized是一致的，不过lock()与unlock()需要成对存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看到lock()是调用了抽象内部类Sync的lock方法，具体实现在其子类FairSync、NonfairSync。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看一下ReentrantLock的公平锁怎么实现的，可以看到lock()只调用了acquire(1)，acquire是AQS的一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      acquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果c=0，则锁处于空闲状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//如果当前线程没有前节点的话，将cas state，成功则唤醒当前线程，返回true</span></span><br><span class="line">      <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//c非0，如果当前线程已经持有锁，则state + 1，返回true。再次已实现可重入性</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">      <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看一下AQS的acquire方法，每次调用都会去尝试获取锁，tryAcquire方法是个空方法，有子类做具体的实现。回头来看FairSync的实现。</p><p><code>current</code>是当前线程，先判断锁是非空闲；如果是，hasQueuedPredecessors再判断线程是否有前节点，没有则compareAndSetState将state设置为acquires。</p><p>如果锁不是空闲状态，且当前线程是锁的持有人，则将state设置为state + acquires。在这一步已经实现了Lock的可重入性，线程进入lock()后，会判断当前线程是否已经持有锁，是的话将state加1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录lock()被多少调用了几次，0表示空闲状态，大于0表示忙碌状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//尝试获取锁，若失败，则进入等待队列;</span></span><br><span class="line">  <span class="comment">//acquireQueued将线程挂起，挂起异常则selfInterrupt中断当前线程</span></span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">      selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尝试获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK！上面已经知道了Lock是怎么实现可重入性的，现在了解一下怎么管理抢占失败而被挂起的线程。</p><p>看到AQS的内部类Node，即可知道是一个双链表，表头Head代表当前占有锁的线程，抢占失败的线程将被添加到尾部。<br><img src="http://p4ygo03xz.bkt.clouddn.com/github-blog/image/AbstractQueuedSynchronizer-Node.png" alt="双链表"></p><p>可以看到Node都有类型和挂起状态，作用于实现各类锁。在上面的代码可以看到acquire方法中通过<code>addWaiter</code>方法将新节点添加到尾部的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="comment">//共享类型</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">  <span class="comment">//独占类型</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//取消状态</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//等待触发，即抢占不到锁被挂起；</span></span><br><span class="line">  <span class="comment">//需要注意的事，head是锁的持有人，此时依然处于该状态，只有释放锁时waitStatus=0</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//等待条件符合，需要等待Condition的signal唤醒，Lock提供了newCondition()，作用跟Object的wait()与notify()是一样的</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">  <span class="comment">//节点状态向后传递，在共享锁有用处</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//挂起的状态，aitStatus=0表明释放锁</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">  <span class="keyword">volatile</span> Node prev;</span><br><span class="line">  <span class="keyword">volatile</span> Node next;</span><br><span class="line">  <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">  <span class="comment">//节点类型，是共享还是独占</span></span><br><span class="line">  Node nextWaiter;</span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">    Node p = prev;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">  &#125;</span><br><span class="line">  Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">    <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">    <span class="keyword">this</span>.thread = thread;</span><br><span class="line">  &#125;</span><br><span class="line">  Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">    <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">    <span class="keyword">this</span>.thread = thread;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我看一下AQS是怎么把线程添加到链表的。将当前tail设置为pred，如果非空，把pred设置为当前node的前节点prev，再将node设置到成员变量tail。如果tail为null，说明此刻双链表未初始化，进去<code>enq</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建当前线程为新节点</span></span><br><span class="line">  Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">  Node pred = tail;</span><br><span class="line">  <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    node.prev = pred;</span><br><span class="line">    <span class="comment">//如果此时tail没有被其他线程抢先修改，则当前节点成功添加到尾部</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">      pred.next = node;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//若失败，循环直到成功</span></span><br><span class="line">  enq(node);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="comment">//此时链表为空，初始化双链表</span></span><br><span class="line">    <span class="comment">//第一个成功抢占锁的线程是不会被添加到双链表的，所以第二个线程进来时tail是空的</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">//存在多线程同时修改head的情况</span></span><br><span class="line">        tail = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果此刻tail非空，将node添加到链表尾部，直到成功返回</span></span><br><span class="line">      node.prev = t;</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">        t.next = node;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码只展示了线程如何变成一个Node被塞进链表末端的，至关重要的线程挂起则在下面<code>acquireQueued</code>方法。挂起线程最终会调用到<code>LockSupport.park</code>这个静态方法，而park又调用了<code>Unsafe.park</code>这个本地方法。</p><p>acquireQueued的逻辑其实跟while里的wait是差不多的，一直在被无意义的循环，被挂起，直到当前节点被推到第二个节点，head结束后，被unpark唤醒后及时抢占锁(详见<code>unparkSuccessor</code>方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">//获取前节点，如果是表头则尝试获取锁</span></span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">//被挂起前最后一次挣扎，也许这时head已经完事了，就该轮到自己了</span></span><br><span class="line">        <span class="comment">//若成功，则将当前节点设置为表头</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> interrupted;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//检查当前上一个节点是否应该被挂起</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            <span class="comment">//挂起线程以及检查是否中断</span></span><br><span class="line">            parkAndCheckInterrupt())</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">  <span class="comment">//上一个节点还在等待中，则返回true，该节点也要乖乖在队列中等待</span></span><br><span class="line">  <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//把取消状态中的节点全部移除</span></span><br><span class="line">  <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      node.prev = pred = pred.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">    pred.next = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//这一步没有理解明白，但应该是再一次重试获取，确保被挂起之前不能获取到锁，如果还是失败，下一轮循环将被挂起</span></span><br><span class="line">    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，好的，上面实在公平锁的分析，下面非公平锁只是比<code>FairSync</code>的lock()多了两句代码。调用lock的时候，不是跟公平锁一样乖乖到队列中等待，而是先重试抢占锁，把state设置1，将自己设为持有锁线程。如果lock失败了，还会在tryAcquire再一次抢占，再失败则进入等待队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后来到释放锁，unlock()则是调用到AQS的release方法，tryRelease是AQS的空方法，具体实现在ReentrantLock内部类Sync。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//尝试释放锁，tryRelease具体实现需要关注子类</span></span><br><span class="line">  <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="comment">//如果head不为空，且未表明被标记已释放锁，则唤醒下一个节点</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//尝试唤醒下一个节点</span></span><br><span class="line">      unparkSuccessor(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">  <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">    compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">  Node s = node.next;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//从尾部扫描，直到找到与head最近的一个等待线程</span></span><br><span class="line">    <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">      <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">        s = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//被唤醒的线程将在acquireQueued方法重新设置head，并把该节点从链表移除</span></span><br><span class="line">  <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ReentrantLock内部类Sync的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">  <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//当state=0是，说明锁已经处于空闲状态，将当前持有锁线程置空</span></span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    free = <span class="keyword">true</span>;</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  setState(c);</span><br><span class="line">  <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java　 </tag>
            
            <tag> 并发编程 </tag>
            
            <tag> 同步 </tag>
            
            <tag> 公平锁 </tag>
            
            <tag> 非公平锁 </tag>
            
            <tag> 可重入锁 </tag>
            
            <tag> ReentrantLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>asynchttpclient源码分析-基于Netty的连接池实现</title>
      <link href="/2017/04/03/20170403-asynchttpclient%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%9F%BA%E4%BA%8ENetty%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/04/03/20170403-asynchttpclient%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%9F%BA%E4%BA%8ENetty%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>最近项目重构，有了个机会更多接触一个有别于HttpAsyncClient的异步网络框架AsyncHttpClient，是个基于Netty的支持Http(s)或WebSocket协议的客户端。这东西有很多有趣的地方，特别是连接池的实现简单易懂，没有apache.hc的连接池实现那么蛋疼。如果想深入了解Netty用法的话，这是个不错的案例，很值得深究！</p><hr><p><strong>这里暂且仅关注连接池的实现，部分涉及Netty的channel输入输出处理、哈希轮定时器算法、事件轮询方式的区别，又或者信号量的使用等等，以后有机会会单独拿出来详解。</strong></p><p>由于是基Netty的实现的，所以连接池实际上就是对channel的管理控制，有趣的是整个管理只用到了信号量+一个定时检测器，略微复杂的也就定时检测的逻辑，其实现方式简单且很好理解，不像httpclient里各种队列各种信号量难以理解。</p><p>先上一个简单的例子，事实上使用起来也不复杂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AsyncHttpClient asyncHttpClient = Dsl</span><br><span class="line">            <span class="comment">//实例化所有池和检测器</span></span><br><span class="line">            .asyncHttpClient(</span><br><span class="line">                    Dsl.config()</span><br><span class="line">                    .setMaxConnections(<span class="number">500</span>)</span><br><span class="line">                    .setMaxConnectionsPerHost(<span class="number">50</span>)</span><br><span class="line">                    .setPooledConnectionIdleTimeout(<span class="number">6000</span>)</span><br><span class="line">                    .setConnectionTtl(<span class="number">500</span>)</span><br><span class="line">                    .setIoThreadsCount(<span class="number">100</span>)</span><br><span class="line">                    .setConnectTimeout(<span class="number">60000</span>)</span><br><span class="line">                    .setUseNativeTransport(</span><br><span class="line">                            System.getProperty(<span class="string">"os.name"</span>).toLowerCase().indexOf(<span class="string">"linux"</span>) &gt; <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Param&gt; params = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        params.add(<span class="keyword">new</span> Param(<span class="string">"keyfrom"</span>, <span class="string">"XXX"</span>));</span><br><span class="line"></span><br><span class="line">        asyncHttpClient</span><br><span class="line">                .prepareGet(<span class="string">"http://fanyi.youdao.com/openapi.do"</span>)</span><br><span class="line">                .addQueryParams(params)</span><br><span class="line">                <span class="comment">//这里进入发送请求阶段</span></span><br><span class="line">                .execute()</span><br><span class="line">                .toCompletableFuture()</span><br><span class="line">                <span class="comment">//超时报错，或请求异常，做容错处理，抛出一个Response</span></span><br><span class="line">                .exceptionally(t -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Response() &#123;...&#125;;</span><br><span class="line">                &#125;)</span><br><span class="line">                .thenAccept(rep -&gt; System.out.println(<span class="string">"RESPONSE BODY"</span> + rep.getResponseBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看<code>DefaultAsyncHttpClientConfig</code>类的配置参数，这里只列出本文所需要的参数。有一点值得提一下，如果想了解Java怎么像clojure或者scala一样创建不可变对象，可以看看这个类的写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeouts</span></span><br><span class="line"><span class="comment">//连接超时</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> connectTimeout;</span><br><span class="line"><span class="comment">//请求超时</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> requestTimeout;</span><br><span class="line"><span class="comment">//读取超时，含于请求时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> readTimeout;</span><br><span class="line"><span class="comment">//关闭Client前的静默时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> shutdownQuietPeriod;</span><br><span class="line"><span class="comment">//关闭超时</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> shutdownTimeout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// keep-alive</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> keepAlive;</span><br><span class="line"><span class="comment">//连接池空闲时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> pooledConnectionIdleTimeout;</span><br><span class="line"><span class="comment">//定时清理空闲连接的时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> connectionPoolCleanerPeriod;</span><br><span class="line"><span class="comment">//连接存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> connectionTtl;</span><br><span class="line"><span class="comment">//最大连接数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxConnections;</span><br><span class="line"><span class="comment">//每个路由的最大连接数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxConnectionsPerHost;</span><br><span class="line"><span class="comment">//用于channel超时处理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelPool channelPool;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> KeepAliveStrategy keepAliveStrategy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// internals</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String threadPoolName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> httpClientCodecMaxInitialLineLength;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> httpClientCodecMaxHeaderSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> httpClientCodecMaxChunkSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> chunkedFileChunkSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> webSocketMaxBufferSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> webSocketMaxFrameSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ChannelOption&lt;Object&gt;, Object&gt; channelOptions;</span><br><span class="line"><span class="comment">//时间轮询组类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup eventLoopGroup;</span><br><span class="line"><span class="comment">//是否用epoll，仅linux系统支持</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> useNativeTransport;</span><br><span class="line"><span class="comment">//用于Timeout处理，建议用默认Netty的HashedWheelTimer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Timer nettyTimer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AdditionalChannelInitializer httpAdditionalChannelInitializer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AdditionalChannelInitializer wsAdditionalChannelInitializer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResponseBodyPartFactory responseBodyPartFactory;</span><br><span class="line"><span class="comment">//其实就是EventLoopGroup指定的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ioThreadsCount;</span><br></pre></td></tr></table></figure><p>就从这里开始，开头主要实例化<code>ChannelManager</code>和<code>NettyRequestSender</code>以及<code>Timer</code>三个重要组件，<code>NettyRequestSender</code>用于发送请求以及向<code>ChannelManager</code>索取channel使用权，<code>Timer</code>则负责另外两个组件给他的检测任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dsl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncHttpClient <span class="title">asyncHttpClient</span><span class="params">(DefaultAsyncHttpClientConfig.Builder configBuilder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认客户端</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultAsyncHttpClient(configBuilder.build());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAsyncHttpClient</span> <span class="keyword">implements</span> <span class="title">AsyncHttpClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AsyncHttpClientConfig config;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean closed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">  <span class="comment">//Netty初始化的起点，Bootstrap与Channel池管理都在这里声明</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ChannelManager channelManager;</span><br><span class="line">  <span class="comment">//发送请求，以及向ChannelManager索取channel的使用权</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> NettyRequestSender requestSender;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> allowStopNettyTimer;</span><br><span class="line">  <span class="comment">//定时做超时处理</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Timer nettyTimer;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultAsyncHttpClient</span><span class="params">(AsyncHttpClientConfig config)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line"></span><br><span class="line">    allowStopNettyTimer = config.getNettyTimer() == <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//默认使用HashedWheelTimer</span></span><br><span class="line">    nettyTimer = allowStopNettyTimer ? newNettyTimer() :config.getNettyTimer();</span><br><span class="line">    <span class="comment">//下面两个是重点！！！</span></span><br><span class="line">    channelManager = <span class="keyword">new</span> ChannelManager(config, nettyTimer);</span><br><span class="line">    requestSender = <span class="keyword">new</span> NettyRequestSender(config, channelManager,nettyTimer, <span class="keyword">new</span> AsyncHttpClientState(closed));</span><br><span class="line">    <span class="comment">//给Bootstraps配置解析器，以及处理接收服务端发送的消息的处理器</span></span><br><span class="line">    channelManager.configureBootstraps(requestSender);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> Timer <span class="title">newNettyTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashedWheelTimer timer = <span class="keyword">new</span> HashedWheelTimer();</span><br><span class="line">    timer.start();</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是重中之重，网络配置、连接池、IO线程池、轮询方式都是在这儿产生的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AsyncHttpClientConfig config;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> allowReleaseEventLoopGroup;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Bootstrap httpBootstrap;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Bootstrap wsBootstrap;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> handshakeTimeout;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> IOException tooManyConnections;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> IOException tooManyConnectionsPerHost;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定时清理不符合标准的channel</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ChannelPool channelPool;</span><br><span class="line">  <span class="comment">//netty自带的用于管理channel的管理器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ChannelGroup openChannels;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Channel, Object&gt; channelId2PartitionKey = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">//是否开启最大总连接数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> maxTotalConnectionsEnabled;</span><br><span class="line">  <span class="comment">//最大连接数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Semaphore freeChannels;</span><br><span class="line">  <span class="comment">//是否开启每个路由最大连接数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> maxConnectionsPerHostEnabled;</span><br><span class="line">  <span class="comment">//每个路由最大连接数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Object, Semaphore&gt; freeChannelsPerHost = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> AsyncHttpClientHandler wsHandler;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ChannelManager</span><span class="params">(<span class="keyword">final</span> AsyncHttpClientConfig config, Timer nettyTimer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">    <span class="comment">//忽略一小段关于ssl的</span></span><br><span class="line">    <span class="comment">//ChannelPool是用于检测已经实例化的channel的健康状况，如果不合格会直接close掉</span></span><br><span class="line">    ChannelPool channelPool = config.getChannelPool();</span><br><span class="line">    <span class="keyword">if</span> (channelPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (config.isKeepAlive()) &#123;</span><br><span class="line">            <span class="comment">//这是默认使用的，事实上多数场景不需要我们自己实现</span></span><br><span class="line">            channelPool = <span class="keyword">new</span> DefaultChannelPool(config, nettyTimer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channelPool = NoopChannelPool.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.channelPool = channelPool;</span><br><span class="line"></span><br><span class="line">    tooManyConnections = trimStackTrace(<span class="keyword">new</span> TooManyConnectionsException(config.getMaxConnections()));</span><br><span class="line">    tooManyConnectionsPerHost = trimStackTrace(<span class="keyword">new</span> TooManyConnectionsPerHostException(config.getMaxConnectionsPerHost()));</span><br><span class="line">    maxTotalConnectionsEnabled = config.getMaxConnections() &gt; <span class="number">0</span>;</span><br><span class="line">    maxConnectionsPerHostEnabled = config.getMaxConnectionsPerHost() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxTotalConnectionsEnabled || maxConnectionsPerHostEnabled) &#123;</span><br><span class="line">        <span class="comment">//管理已经被实例化的channel</span></span><br><span class="line">        openChannels = <span class="keyword">new</span> DefaultChannelGroup(<span class="string">"asyncHttpClient"</span>, GlobalEventExecutor.INSTANCE) &#123;</span><br><span class="line">            <span class="comment">//重写删除方法，因为删除channel时，需要释放信号量</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">boolean</span> removed = <span class="keyword">super</span>.remove(o);</span><br><span class="line">                <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">                    <span class="comment">//释放总连接池的信号量</span></span><br><span class="line">                    <span class="keyword">if</span> (maxTotalConnectionsEnabled)</span><br><span class="line">                        freeChannels.release();</span><br><span class="line">                    <span class="comment">//释放路由连接池的信号量</span></span><br><span class="line">                    <span class="keyword">if</span> (maxConnectionsPerHostEnabled) &#123;</span><br><span class="line">                        Object partitionKey = channelId2PartitionKey.remove(Channel<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">o</span>))</span>;</span><br><span class="line">                        <span class="keyword">if</span> (partitionKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            Semaphore hostFreeChannels = freeChannelsPerHost.get(partitionKey);</span><br><span class="line">                            <span class="keyword">if</span> (hostFreeChannels != <span class="keyword">null</span>)</span><br><span class="line">                                hostFreeChannels.release();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> removed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//信号量数为最大连接数</span></span><br><span class="line">        freeChannels = <span class="keyword">new</span> Semaphore(config.getMaxConnections());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        openChannels = <span class="keyword">new</span> DefaultChannelGroup(<span class="string">"asyncHttpClient"</span>, GlobalEventExecutor.INSTANCE);</span><br><span class="line">        freeChannels = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handshakeTimeout = config.getHandshakeTimeout();</span><br><span class="line"></span><br><span class="line">    ThreadFactory threadFactory = config.getThreadFactory() != <span class="keyword">null</span> ? config.getThreadFactory() : <span class="keyword">new</span> DefaultThreadFactory(config.getThreadPoolName());</span><br><span class="line">    allowReleaseEventLoopGroup = config.getEventLoopGroup() == <span class="keyword">null</span>;</span><br><span class="line">    ChannelFactory&lt;? extends Channel&gt; channelFactory;</span><br><span class="line">    <span class="keyword">if</span> (allowReleaseEventLoopGroup) &#123;</span><br><span class="line">        <span class="comment">//这个只能在linux下使用</span></span><br><span class="line">        <span class="keyword">if</span> (config.isUseNativeTransport()) &#123;</span><br><span class="line">            eventLoopGroup = newEpollEventLoopGroup(config.getIoThreadsCount(), threadFactory);</span><br><span class="line">            channelFactory = getEpollSocketChannelFactory();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//通常默认走这个！</span></span><br><span class="line">            eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(config.getIoThreadsCount(), <span class="comment">//瞧！IO线程数就是时间轮询的线程数</span></span><br><span class="line">              threadFactory);</span><br><span class="line">            channelFactory = NioSocketChannelFactory.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于http请求的bootstrap</span></span><br><span class="line">    httpBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);</span><br><span class="line">    <span class="comment">//用于WebSocket请求的bootstrap</span></span><br><span class="line">    wsBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);</span><br><span class="line"></span><br><span class="line">    httpBootstrap.option(ChannelOption.AUTO_READ, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化完<code>ChannelManager</code>后，就轮到请求发送器，这里先看看所需要的参数，具体执行的方法在后面说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyRequestSender</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AsyncHttpClientConfig config;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ChannelManager channelManager;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Timer nettyTimer;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AsyncHttpClientState clientState;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> NettyRequestFactory requestFactory;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NettyRequestSender</span><span class="params">(AsyncHttpClientConfig config,//</span></span></span><br><span class="line"><span class="function"><span class="params">            ChannelManager channelManager,//</span></span></span><br><span class="line"><span class="function"><span class="params">            Timer nettyTimer,//</span></span></span><br><span class="line"><span class="function"><span class="params">            AsyncHttpClientState clientState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.config = config;</span><br><span class="line">      <span class="keyword">this</span>.channelManager = channelManager;</span><br><span class="line">      <span class="keyword">this</span>.nettyTimer = nettyTimer;</span><br><span class="line">      <span class="keyword">this</span>.clientState = clientState;</span><br><span class="line">      requestFactory = <span class="keyword">new</span> NettyRequestFactory(config);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回来看看<code>ChannelManager</code>构造方法中使用的工厂方法<code>newBootstrap(channelFactory, eventLoopGroup, config)</code>，这是支持整个ahc运作的代码，对于用Netty实现网络客户端来说，这个配置很有参考价值，所以也贴上来一起观赏！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Bootstrap <span class="title">newBootstrap</span><span class="params">(ChannelFactory&lt;? extends Channel&gt; channelFactory, EventLoopGroup eventLoopGroup, AsyncHttpClientConfig config)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap().channelFactory(channelFactory)</span><br><span class="line">            <span class="comment">//客户端只有worker线程池，ServerBootstrap则需要boss和worker</span></span><br><span class="line">            .group(eventLoopGroup)</span><br><span class="line">            <span class="comment">//设置内存分配器，我的理解是关于堆内存模型的，可用于对Netty的优化</span></span><br><span class="line">            .option(ChannelOption.ALLOCATOR, config.getAllocator() != <span class="keyword">null</span> ? config.getAllocator() : ByteBufAllocator.DEFAULT)</span><br><span class="line">            <span class="comment">//是否使用tcp的Nagle算法，文件传输可以选择使用</span></span><br><span class="line">            .option(ChannelOption.TCP_NODELAY, config.isTcpNoDelay())</span><br><span class="line">            <span class="comment">//重复使用本地地址端口</span></span><br><span class="line">            .option(ChannelOption.SO_REUSEADDR, config.isSoReuseAddress())<span class="comment">//</span></span><br><span class="line">            .option(ChannelOption.AUTO_CLOSE, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (config.getConnectTimeout() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config.getSoLinger() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//就是一个设置延迟关闭时间的参数，用于保证数据发送完成</span></span><br><span class="line">        bootstrap.option(ChannelOption.SO_LINGER, config.getSoLinger());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config.getSoSndBuf() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        bootstrap.option(ChannelOption.SO_SNDBUF, config.getSoSndBuf());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config.getSoRcvBuf() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        bootstrap.option(ChannelOption.SO_RCVBUF, config.getSoRcvBuf());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义配置</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;ChannelOption&lt;Object&gt;, Object&gt; entry : config.getChannelOptions().entrySet()) &#123;</span><br><span class="line">        bootstrap.option(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bootstrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面则是管道的配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureBootstraps</span><span class="params">(NettyRequestSender requestSender)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ahc自定义的ChannelInboundHandler，异步方式获取服务端返回的数据</span></span><br><span class="line">    <span class="comment">//我们自己获取数据后的核心业务逻辑，也在这里开始</span></span><br><span class="line">    <span class="keyword">final</span> AsyncHttpClientHandler httpHandler = <span class="keyword">new</span> HttpHandler(config, <span class="keyword">this</span>, requestSender);</span><br><span class="line">    wsHandler = <span class="keyword">new</span> WebSocketHandler(config, <span class="keyword">this</span>, requestSender);</span><br><span class="line">    <span class="keyword">final</span> NoopHandler pinnedEntry = <span class="keyword">new</span> NoopHandler();</span><br><span class="line"></span><br><span class="line">    httpBootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline pipeline = ch.pipeline()<span class="comment">//</span></span><br><span class="line">                    .addLast(PINNED_ENTRY, pinnedEntry)<span class="comment">//</span></span><br><span class="line">                    .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())<span class="comment">//</span></span><br><span class="line">                    .addLast(INFLATER_HANDLER, newHttpContentDecompressor())<span class="comment">//</span></span><br><span class="line">                    .addLast(CHUNKED_WRITER_HANDLER, <span class="keyword">new</span> ChunkedWriteHandler())<span class="comment">//</span></span><br><span class="line">                    .addLast(AHC_HTTP_HANDLER, httpHandler);</span><br><span class="line">            <span class="keyword">if</span> (config.getHttpAdditionalChannelInitializer() != <span class="keyword">null</span>)</span><br><span class="line">                config.getHttpAdditionalChannelInitializer().initChannel(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    wsBootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline pipeline = ch.pipeline()<span class="comment">//</span></span><br><span class="line">                    .addLast(PINNED_ENTRY, pinnedEntry)<span class="comment">//</span></span><br><span class="line">                    .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())<span class="comment">//</span></span><br><span class="line">                    .addLast(AHC_WS_HANDLER, wsHandler);</span><br><span class="line">            <span class="keyword">if</span> (config.getWsAdditionalChannelInitializer() != <span class="keyword">null</span>)</span><br><span class="line">                config.getWsAdditionalChannelInitializer().initChannel(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切工作准备就绪，现在可以请求了！怎么构建请求就不打算讲了，可以自行阅读<code>RequestBuilderBase</code>类。执行<code>execute()</code>方法，正式开始请求，往下看<code>DefaultAsyncHttpClient.executeRequest()</code>怎么创建连接的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundRequestBuilder</span> <span class="keyword">extends</span> <span class="title">RequestBuilderBase</span>&lt;<span class="title">BoundRequestBuilder</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AsyncHttpClient client;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListenableFuture&lt;Response&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> client.executeRequest(build(), <span class="keyword">new</span> AsyncCompletionHandlerBase());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAsyncHttpClient</span> <span class="keyword">implements</span> <span class="title">AsyncHttpClient</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">executeRequest</span><span class="params">(Request request, AsyncHandler&lt;T&gt; handler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (config.getRequestFilters().isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">return</span> execute(request, handler);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不考虑设置请求过滤器的情况</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">execute</span><span class="params">(Request request, <span class="keyword">final</span> AsyncHandler&lt;T&gt; asyncHandler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//把请求参数，和读取数据后的回调一同塞给请求发送器</span></span><br><span class="line">          <span class="keyword">return</span> requestSender.sendRequest(request, asyncHandler, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          asyncHandler.onThrowable(e);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> ListenableFuture.CompletedFailure&lt;&gt;(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK～～上面列出<code>NettyRequestSender</code>需要什么参数，现在再来看看怎么做的？<br>下面的方法中，重点关注<code>sendRequestWithNewChannel</code>，它包括了如何新建channel、连接，抢占信号量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">sendRequest</span><span class="params">(<span class="keyword">final</span> Request request,//</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> AsyncHandler&lt;T&gt; asyncHandler,//</span></span></span><br><span class="line"><span class="function"><span class="params">            NettyResponseFuture&lt;T&gt; future,//</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> performingNextRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ProxyServer proxyServer = getProxyServer(config, request);</span><br><span class="line">    <span class="comment">//使用SSL代理或者ws</span></span><br><span class="line">    <span class="keyword">if</span> (proxyServer != <span class="keyword">null</span> &amp;&amp; (request.getUri().isSecured() || request.getUri().isWebSocket()) &amp;&amp; !isConnectDone(request, future))</span><br><span class="line">        <span class="comment">//暂时忽略另外两个创建连接的方式</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//我们的例子用的是GET，所以执行该方法</span></span><br><span class="line">        <span class="keyword">return</span> sendRequestWithCertainForceConnect(request, asyncHandler, future, performingNextRequest, proxyServer, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">sendRequestWithCertainForceConnect</span><span class="params">(//</span></span></span><br><span class="line"><span class="function"><span class="params">            Request request,//</span></span></span><br><span class="line"><span class="function"><span class="params">            AsyncHandler&lt;T&gt; asyncHandler,//</span></span></span><br><span class="line"><span class="function"><span class="params">            NettyResponseFuture&lt;T&gt; future,//注意，这时候传进来是<span class="keyword">null</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> performingNextRequest,//</span></span></span><br><span class="line"><span class="function"><span class="params">            ProxyServer proxyServer,//</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> forceConnect)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把所有请求信息保证在一个响应回调对象里</span></span><br><span class="line">    NettyResponseFuture&lt;T&gt; newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, forceConnect);</span><br><span class="line">    <span class="comment">//这里视图根据这个请求去拿去channel，过程有点漫长，回头再来解释</span></span><br><span class="line">    Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Channels.isChannelValid(channel))</span><br><span class="line">        <span class="keyword">return</span> sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, performingNextRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Channel <span class="title">getOpenChannel</span><span class="params">(NettyResponseFuture&lt;?&gt; future, Request request, ProxyServer proxyServer, AsyncHandler&lt;?&gt; asyncHandler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//future并没有channel，对于什么时候channel是可复用的，一直没搞明白，所以我基本默认每次都要新建一个channel</span></span><br><span class="line">    <span class="keyword">if</span> (future != <span class="keyword">null</span> &amp;&amp; future.isReuseChannel() &amp;&amp; Channels.isChannelValid(future.channel()))</span><br><span class="line">        <span class="keyword">return</span> future.channel();</span><br><span class="line">    <span class="comment">//视图在channelManager中找到可用对象</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> pollPooledChannel(request, proxyServer, asyncHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">sendRequestWithOpenChannel</span><span class="params">(Request request, ProxyServer proxy, NettyResponseFuture&lt;T&gt; future, AsyncHandler&lt;T&gt; asyncHandler, Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (asyncHandler <span class="keyword">instanceof</span> AsyncHandlerExtensions)</span><br><span class="line">        AsyncHandlerExtensions<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">asyncHandler</span>).<span class="title">onConnectionPooled</span>(<span class="title">channel</span>)</span>;</span><br><span class="line">    <span class="comment">//启动请求超时，在writeRequest中，会启动读取超时</span></span><br><span class="line">    TimeoutsHolder timeoutsHolder = scheduleRequestTimeout(future);</span><br><span class="line">    timeoutsHolder.initRemoteAddress((InetSocketAddress) channel.remoteAddress());</span><br><span class="line">    future.setChannelState(ChannelState.POOLED);</span><br><span class="line">    future.attachChannel(channel, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Channels.setAttribute(channel, future);</span><br><span class="line">    <span class="keyword">if</span> (Channels.isChannelValid(channel)) &#123;</span><br><span class="line">        writeRequest(future, channel);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handleUnexpectedClosedChannel(channel, future);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把这里当作一个请求连接的开始</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">sendRequestWithNewChannel</span><span class="params">(//</span></span></span><br><span class="line"><span class="function"><span class="params">            Request request,//</span></span></span><br><span class="line"><span class="function"><span class="params">            ProxyServer proxy,//</span></span></span><br><span class="line"><span class="function"><span class="params">            NettyResponseFuture&lt;T&gt; future,//</span></span></span><br><span class="line"><span class="function"><span class="params">            AsyncHandler&lt;T&gt; asyncHandler,//</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> performingNextRequest)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Realm realm = future.getRealm();</span><br><span class="line">    Realm proxyRealm = future.getProxyRealm();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//为做连接做准备</span></span><br><span class="line">    Bootstrap bootstrap = channelManager.getBootstrap(request.getUri(), proxy);</span><br><span class="line">    <span class="comment">//用于索取channel</span></span><br><span class="line">    Object partitionKey = future.getPartitionKey();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> acquireChannelLock = !performingNextRequest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//抢占信号量</span></span><br><span class="line">        <span class="keyword">if</span> (acquireChannelLock) &#123;</span><br><span class="line">            channelManager.acquireChannelLock(partitionKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        abort(<span class="keyword">null</span>, future, getCause(t));</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开启请求超时定时器</span></span><br><span class="line">    scheduleRequestTimeout(future);</span><br><span class="line">    <span class="comment">//域名解析</span></span><br><span class="line">    RequestHostnameResolver.INSTANCE.resolve(request, proxy, asyncHandler)<span class="comment">//</span></span><br><span class="line">            .addListener(<span class="keyword">new</span> SimpleFutureListener&lt;List&lt;InetSocketAddress&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">//域名解析后得到的IP地址列表</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(List&lt;InetSocketAddress&gt; addresses)</span> </span>&#123;</span><br><span class="line">                    NettyConnectListener&lt;T&gt; connectListener = <span class="keyword">new</span> NettyConnectListener&lt;&gt;(future, NettyRequestSender.<span class="keyword">this</span>, channelManager, acquireChannelLock, partitionKey);</span><br><span class="line">                    <span class="comment">//不要怀疑！这里开始连接了！！！</span></span><br><span class="line">                    NettyChannelConnector connector = <span class="keyword">new</span> NettyChannelConnector(request.getLocalAddress(), addresses, asyncHandler, clientState, config);</span><br><span class="line">                    <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">                        connector.connect(bootstrap, connectListener);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (acquireChannelLock) &#123;</span><br><span class="line">                        <span class="comment">//如果future已经完成，则释放信号量</span></span><br><span class="line">                        channelManager.releaseChannelLock(partitionKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//失败，释放信号</span></span><br><span class="line">                    <span class="keyword">if</span> (acquireChannelLock) &#123;</span><br><span class="line">                        channelManager.releaseChannelLock(partitionKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                    abort(<span class="keyword">null</span>, future, getCause(cause));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NettyChannelConnector</code>负责对远程IP创建连接，一旦连接成功，<code>NettyConnectListener</code>就会调用requestSender向服务端发送数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChannelConnector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">final</span> Bootstrap bootstrap, <span class="keyword">final</span> NettyConnectListener&lt;?&gt; connectListener)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取DNS后的IP地址</span></span><br><span class="line">      <span class="keyword">final</span> InetSocketAddress remoteAddress = remoteAddresses.get(i);</span><br><span class="line">      <span class="keyword">if</span> (asyncHandlerExtensions != <span class="keyword">null</span>)</span><br><span class="line">          asyncHandlerExtensions.onTcpConnectAttempt(remoteAddress);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          connect0(bootstrap, connectListener, remoteAddress);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (clientState.isClosed()) &#123;</span><br><span class="line">              connectListener.onFailure(<span class="keyword">null</span>, e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connect0</span><span class="params">(Bootstrap bootstrap, <span class="keyword">final</span> NettyConnectListener&lt;?&gt; connectListener, InetSocketAddress remoteAddress)</span> </span>&#123;</span><br><span class="line">      bootstrap.connect(remoteAddress, localAddress)<span class="comment">//</span></span><br><span class="line">              .addListener(<span class="keyword">new</span> SimpleChannelFutureListener() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">                      <span class="keyword">if</span> (asyncHandlerExtensions != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          asyncHandlerExtensions.onTcpConnectSuccess(remoteAddress, channel);</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="comment">//如果有设置连接的存活时间，则初始化channelId，在ChannelPool中自检有用到</span></span><br><span class="line">                      <span class="keyword">if</span> (connectionTtlEnabled) &#123;</span><br><span class="line">                          Channels.initChannelId(channel);</span><br><span class="line">                      &#125;</span><br><span class="line">                      connectListener.onSuccess(channel, remoteAddress);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Channel channel, Throwable t)</span> </span>&#123;</span><br><span class="line">                      <span class="keyword">if</span> (asyncHandlerExtensions != <span class="keyword">null</span>)</span><br><span class="line">                          asyncHandlerExtensions.onTcpConnectFailure(remoteAddress, t);</span><br><span class="line">                      <span class="comment">//如果连接失败，则尝试连接下一个IP</span></span><br><span class="line">                      <span class="keyword">boolean</span> retry = pickNextRemoteAddress();</span><br><span class="line">                      <span class="keyword">if</span> (retry)</span><br><span class="line">                          NettyChannelConnector.<span class="keyword">this</span>.connect(bootstrap, connectListener);</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                          connectListener.onFailure(channel, t);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接成功，就来到这里，拿到channel，准备向服务器发送数据！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyConnectListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Channel channel, InetSocketAddress remoteAddress)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      Channels.setInactiveToken(channel);</span><br><span class="line">      TimeoutsHolder timeoutsHolder = future.getTimeoutsHolder();</span><br><span class="line">      <span class="keyword">if</span> (futureIsAlreadyCancelled(channel)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Request request = future.getTargetRequest();</span><br><span class="line">      Uri uri = request.getUri();</span><br><span class="line">      timeoutsHolder.initRemoteAddress(remoteAddress);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (future.getProxyServer() == <span class="keyword">null</span> &amp;&amp; uri.isSecured()) &#123;</span><br><span class="line">        <span class="comment">//直接无视</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          writeRequest(channel);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeRequest</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (futureIsAlreadyCancelled(channel)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//在这设置属性，在读取服务器数据的httphandler里面有用到</span></span><br><span class="line">      Channels.setAttribute(channel, future);</span><br><span class="line">      <span class="comment">//注册到ChannelGroup中</span></span><br><span class="line">      channelManager.registerOpenChannel(channel, partitionKey);</span><br><span class="line">      <span class="comment">//设置为不复用channel</span></span><br><span class="line">      future.attachChannel(channel, <span class="keyword">false</span>);</span><br><span class="line">      <span class="comment">//发送请求数据</span></span><br><span class="line">      <span class="comment">//这个方法就不贴上来了，没什么意思</span></span><br><span class="line">      <span class="comment">//方法里最后将启动读取超时scheduleReadTimeout(future);意味将进入HttpHandler读取服务端数据</span></span><br><span class="line">      requestSender.writeRequest(future, channel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取数据一切顺利后，就会走下面这个私有方法，将channel送入channelpool里，等待生命的结束！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpHandler</span> <span class="keyword">extends</span> <span class="title">AsyncHttpClientHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishUpdate</span><span class="params">(<span class="keyword">final</span> NettyResponseFuture&lt;?&gt; future, Channel channel, <span class="keyword">boolean</span> expectOtherChunks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      future.cancelTimeouts();</span><br><span class="line">      <span class="keyword">boolean</span> keepAlive = future.isKeepAlive();</span><br><span class="line">      <span class="comment">//这里继续读取后面的数据块，最后channel被设置了回调，依然调用下面的tryToOfferChannelToPool方法</span></span><br><span class="line">      <span class="keyword">if</span> (expectOtherChunks &amp;&amp; keepAlive)</span><br><span class="line">          channelManager.drainChannelAndOffer(channel, future);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, future.getPartitionKey());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          future.done();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception t) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tryToOfferChannelToPool</strong> 是<code>ChannelManager</code>的方法，主要将依然活跃的channel送入生命倒数器中，还记得connectionTtl么，这个参数在这就起作用了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryToOfferChannelToPool</span><span class="params">(Channel channel, AsyncHandler&lt;?&gt; asyncHandler, <span class="keyword">boolean</span> keepAlive, Object partitionKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//长连接，或者依然活跃的</span></span><br><span class="line">    <span class="keyword">if</span> (channel.isActive() &amp;&amp; keepAlive) &#123;</span><br><span class="line">        <span class="comment">//丢弃被设置的属性</span></span><br><span class="line">        Channels.setDiscard(channel);</span><br><span class="line">        <span class="keyword">if</span> (asyncHandler <span class="keyword">instanceof</span> AsyncHandlerExtensions)</span><br><span class="line">            AsyncHandlerExtensions<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">asyncHandler</span>).<span class="title">onConnectionOffer</span>(<span class="title">channel</span>)</span>;</span><br><span class="line">            <span class="comment">//尝试塞进pool里</span></span><br><span class="line">        <span class="keyword">if</span> (channelPool.offer(channel, partitionKey)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxConnectionsPerHostEnabled)</span><br><span class="line">                <span class="comment">//我没明白这个映射到底是干嘛用的</span></span><br><span class="line">                channelId2PartitionKey.putIfAbsent(channel, partitionKey);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//被pool驳回，就直接关闭掉！！</span></span><br><span class="line">            closeChannel(channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//已经死亡或者不是长连接，直接关闭！！</span></span><br><span class="line">        closeChannel(channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=#f28080>到这里，关于channel已经接近尾声了，细心的童鞋可能发现，信号量呢？！不用释放么？！其实在关闭channel的时候，已经释放了，这是因为 <strong>ChannelGroup</strong> 的作用，在将channel注册(add方法)到group的时候，已经在其上面加了关闭的监听器，一旦close就执行remove，实例化 <strong>ChannelGroup</strong> 时已经将<code>remove(channel)</code>重写，可以倒回去看是不是已经释放了信号量，也可以看看 <strong>ChannelGroup</strong> 源码是不是在<code>add</code>时候添加了监听器。</font></p><p>不过，这里只是接近尾声，没意味就结束了，还有存活的channel被塞到 <strong>ChannelPool</strong> 进行生命的倒计时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPool</span> <span class="keyword">implements</span> <span class="title">ChannelPool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Object, ConcurrentLinkedDeque&lt;IdleChannel&gt;&gt; partitions = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;ChannelId, ChannelCreation&gt; channelId2Creation;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean isClosed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Timer nettyTimer;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> connectionTtl;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> connectionTtlEnabled;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxIdleTime;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> maxIdleTimeEnabled;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> cleanerPeriod;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PoolLeaseStrategy poolLeaseStrategy;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultChannelPool</span><span class="params">(<span class="keyword">int</span> maxIdleTime,//</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> connectionTtl,//</span></span></span><br><span class="line"><span class="function"><span class="params">            PoolLeaseStrategy poolLeaseStrategy,//</span></span></span><br><span class="line"><span class="function"><span class="params">            Timer nettyTimer,//</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> cleanerPeriod)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.maxIdleTime = maxIdleTime;</span><br><span class="line">      <span class="keyword">this</span>.connectionTtl = connectionTtl;</span><br><span class="line">      connectionTtlEnabled = connectionTtl &gt; <span class="number">0</span>;</span><br><span class="line">      channelId2Creation = connectionTtlEnabled ? <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;() : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.nettyTimer = nettyTimer;</span><br><span class="line">      maxIdleTimeEnabled = maxIdleTime &gt; <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">this</span>.poolLeaseStrategy = poolLeaseStrategy;</span><br><span class="line">      <span class="comment">//在cleanerPeriod清理周期时间、connectionTtl连接存活时间、maxIdleTime最大空闲时间中选择最小的</span></span><br><span class="line">      <span class="keyword">this</span>.cleanerPeriod = Math.min(cleanerPeriod定时清理周期, Math.min(connectionTtlEnabled ? connectionTtl : Integer.MAX_VALUE, maxIdleTimeEnabled ? maxIdleTime : Integer.MAX_VALUE));</span><br><span class="line">      <span class="comment">//如果开启了连接存活时间，或者最大空闲时间，则实例化空闲channel检测</span></span><br><span class="line">      <span class="keyword">if</span> (connectionTtlEnabled || maxIdleTimeEnabled)</span><br><span class="line">          scheduleNewIdleChannelDetector(<span class="keyword">new</span> IdleChannelDetector());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleNewIdleChannelDetector</span><span class="params">(TimerTask task)</span> </span>&#123;</span><br><span class="line">      nettyTimer.newTimeout(task, cleanerPeriod, TimeUnit.MILLISECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IdleChannelDetector</span> <span class="keyword">implements</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">      <span class="comment">//挖出已经不满足条件的channel</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> List&lt;IdleChannel&gt; <span class="title">expiredChannels</span><span class="params">(ConcurrentLinkedDeque&lt;IdleChannel&gt; partition, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">          List&lt;IdleChannel&gt; idleTimeoutChannels = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">for</span> (IdleChannel idleChannel : partition) &#123;</span><br><span class="line">              <span class="comment">//空闲时间是否过期</span></span><br><span class="line">              <span class="keyword">boolean</span> isIdleTimeoutExpired = isIdleTimeoutExpired(idleChannel, now);</span><br><span class="line">              <span class="comment">//channel是否还活跃</span></span><br><span class="line">              <span class="keyword">boolean</span> isRemotelyClosed = isRemotelyClosed(idleChannel.channel);</span><br><span class="line">              <span class="comment">//存活时间是否过期</span></span><br><span class="line">              <span class="keyword">boolean</span> isTtlExpired = isTtlExpired(idleChannel.channel, now);</span><br><span class="line">              <span class="comment">//满足其中一个条件，加入即将被关闭的channel队列</span></span><br><span class="line">              <span class="keyword">if</span> (isIdleTimeoutExpired || isRemotelyClosed || isTtlExpired) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (idleTimeoutChannels == <span class="keyword">null</span>)</span><br><span class="line">                      idleTimeoutChannels = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">                  idleTimeoutChannels.add(idleChannel);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> idleTimeoutChannels != <span class="keyword">null</span> ? idleTimeoutChannels : Collections.&lt;IdleChannel&gt; emptyList();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//关闭expiredChannels筛选出来的队列，并返回一个已被close的channel队列</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> List&lt;IdleChannel&gt; <span class="title">closeChannels</span><span class="params">(List&lt;IdleChannel&gt; candidates)</span> </span>&#123;</span><br><span class="line">          List&lt;IdleChannel&gt; closedChannels = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candidates.size(); i++) &#123;</span><br><span class="line">              IdleChannel idleChannel = candidates.get(i);</span><br><span class="line">              <span class="comment">//如果未被占有，则直接close；如果中间出现有被占有的channel，实例化closedChannels，并将之前被close的channel塞进其中</span></span><br><span class="line">              <span class="keyword">if</span> (idleChannel.takeOwnership()) &#123;</span><br><span class="line">                  close(idleChannel.channel);</span><br><span class="line">                  <span class="keyword">if</span> (closedChannels != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      closedChannels.add(idleChannel);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="comment">//注意，这里只会被执行一次，closedChannels被实例化后不会再执行</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (closedChannels == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  closedChannels = <span class="keyword">new</span> ArrayList&lt;&gt;(candidates.size());</span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                      closedChannels.add(candidates.get(j));</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果closedChannels为null，代表已经关闭candidates所有channel，原封不动返回</span></span><br><span class="line">          <span class="comment">//如果closedChannels非null，代表被占用的channel没有close并继续存活在candidates，所以返回被close了的channel队列closedChannels</span></span><br><span class="line">          <span class="keyword">return</span> closedChannels != <span class="keyword">null</span> ? closedChannels : candidates;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (isClosed.get())</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">//检测器的启动时间</span></span><br><span class="line">          <span class="keyword">long</span> start = unpreciseMillisTime();</span><br><span class="line">          <span class="keyword">int</span> closedCount = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">int</span> totalCount = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">//遍历每个路由的被塞到ChannelPool的channel队列</span></span><br><span class="line">          <span class="keyword">for</span> (ConcurrentLinkedDeque&lt;IdleChannel&gt; partition : partitions.values()) &#123;</span><br><span class="line">              List&lt;IdleChannel&gt; closedChannels = closeChannels(expiredChannels(partition, start));</span><br><span class="line">              <span class="comment">//非空且开启了连接存活时间的channel且被close的channel，全部从channelId2Creation和partition中去除</span></span><br><span class="line">              <span class="keyword">if</span> (!closedChannels.isEmpty()) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (connectionTtlEnabled) &#123;</span><br><span class="line">                      <span class="keyword">for</span> (IdleChannel closedChannel : closedChannels)</span><br><span class="line">                          channelId2Creation.remove(channelId(closedChannel.channel));</span><br><span class="line">                  &#125;</span><br><span class="line">                  partition.removeAll(closedChannels);</span><br><span class="line">                  closedCount += closedChannels.size();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//退出并继续下一轮检测</span></span><br><span class="line">          scheduleNewIdleChannelDetector(timeout.task());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存放空闲channel</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IdleChannel</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Channel channel;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> start;</span><br><span class="line">      <span class="keyword">final</span> AtomicBoolean owned = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">      IdleChannel(Channel channel, <span class="keyword">long</span> start) &#123;</span><br><span class="line">          <span class="keyword">this</span>.channel = assertNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">          <span class="keyword">this</span>.start = start;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">takeOwnership</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> owned.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;...&#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//存放channel的创建时间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelCreation</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> creationTime;</span><br><span class="line">      <span class="keyword">final</span> Object partitionKey;</span><br><span class="line">      ChannelCreation(<span class="keyword">long</span> creationTime, Object partitionKey) &#123;</span><br><span class="line">          <span class="keyword">this</span>.creationTime = creationTime;</span><br><span class="line">          <span class="keyword">this</span>.partitionKey = partitionKey;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里才是channel的终结！！！</p><p>channel被终结了，但有些还存活的channel还在请求的路上，还有很重要的两点没说到，就是 <strong>请求超时</strong> 和 <strong>读取超时</strong>。<br>每个<code>NettyResponseFuture</code>都持有一个<code>TimeoutsHolder</code>来计算 <strong>requestTimeout</strong> 和 <strong>readTimeout</strong> 是否过期。在ResponseFuture获取连接后，以及获取成功向服务器发送数据后，都会分别启动请求超时和读取超时两个定时器。通过阅读源码，可以发现 <strong>requestTimeout</strong> 其实是包括了 <strong>readTimeout</strong>，如果请求剩余时间小于读取超时时间时，<code>startReadTimeout</code>是不会启动readTimeout定时器的。下面只贴上<code>TimeoutsHolder</code>的部分源码，<code>RequestTimeoutTimerTask</code>和<code>ReadTimeoutTimerTask</code>可以自行阅读。</p><p><font color=#f28080>对于这两个参数，需要说明一点就是，一旦超时过期，channel和future都会被close掉，如果读超设置比请超长则是无意义的，只会以requestTimeout为准。</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutsHolder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean cancelled = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Timer nettyTimer;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> NettyRequestSender requestSender;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> requestTimeoutMillisTime;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> readTimeoutValue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> NettyResponseFuture&lt;?&gt; nettyResponseFuture;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Timeout requestTimeout;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">volatile</span> Timeout readTimeout;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TimeoutsHolder</span><span class="params">(Timer nettyTimer, NettyResponseFuture&lt;?&gt; nettyResponseFuture, NettyRequestSender requestSender, AsyncHttpClientConfig config)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.nettyTimer = nettyTimer;</span><br><span class="line">      <span class="keyword">this</span>.nettyResponseFuture = nettyResponseFuture;</span><br><span class="line">      <span class="keyword">this</span>.requestSender = requestSender;</span><br><span class="line">      <span class="keyword">this</span>.readTimeoutValue = config.getReadTimeout();</span><br><span class="line">      <span class="keyword">int</span> requestTimeoutInMs = nettyResponseFuture.getTargetRequest().getRequestTimeout();</span><br><span class="line">      <span class="comment">//每个请求都可以独立设置请求超时时间</span></span><br><span class="line">      <span class="keyword">if</span> (requestTimeoutInMs == <span class="number">0</span>) &#123;</span><br><span class="line">          requestTimeoutInMs = config.getRequestTimeout();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (requestTimeoutInMs != -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//请求的到期时间，启动请求超时定时器</span></span><br><span class="line">          requestTimeoutMillisTime = unpreciseMillisTime() + requestTimeoutInMs;</span><br><span class="line">          requestTimeout = newTimeout(<span class="keyword">new</span> RequestTimeoutTimerTask(nettyResponseFuture, requestSender, <span class="keyword">this</span>, requestTimeoutInMs), requestTimeoutInMs);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          requestTimeoutMillisTime = -<span class="number">1L</span>;</span><br><span class="line">          requestTimeout = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startReadTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (readTimeoutValue != -<span class="number">1</span>) &#123;</span><br><span class="line">          startReadTimeout(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">startReadTimeout</span><span class="params">(ReadTimeoutTimerTask task)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//如果requestTimeout不为null，或者requestTimeout还没有过期并且读取超时时间&lt;请求剩余时间</span></span><br><span class="line">      <span class="keyword">if</span> (requestTimeout == <span class="keyword">null</span> || (!requestTimeout.isExpired() &amp;&amp; readTimeoutValue &lt; (requestTimeoutMillisTime - unpreciseMillisTime()))) &#123;</span><br><span class="line">          <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">              task = <span class="keyword">new</span> ReadTimeoutTimerTask(nettyResponseFuture, requestSender, <span class="keyword">this</span>, readTimeoutValue);</span><br><span class="line">          &#125;</span><br><span class="line">          Timeout readTimeout = newTimeout(task, readTimeoutValue);</span><br><span class="line">          <span class="keyword">this</span>.readTimeout = readTimeout;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">          task.clean();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后最后最后。。。</p><p>来总结一下ahc的连接池实现，很明显的一点整个过程都是对<code>Channel</code>的管理，而且对于连接的抢占则使用了<code>Semaphore</code>，这再方便不过了！！！对于信号量的释放，Netty的<code>ChannelGroup</code>有很大的功劳，它提供了最优雅的方式关闭channel并且释放信号量。除此之外，一堆的超时限制任务需要一个定时任务容器执行，Netty又提供了一个在面对大量任务依然稳坐泰山的<code>HashedWheelTimer</code>，有机会专门来说说这一个。还有就是<code>DefaultChannelPool</code>对存活时间的检测，实在是通俗易懂，而且基于前面说的几点，实现起来也相当方便。</p><p>如果遇到基于netty的网络编程开发，对于连接资源的管理ahc确实提供了一套不错的思路，不仅对客户端，服务端也是可以试一试的！</p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学Clojure—不可变性与惰性</title>
      <link href="/2017/01/29/20170129-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%E4%B8%8E%E6%83%B0%E6%80%A7/"/>
      <url>/2017/01/29/20170129-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%E4%B8%8E%E6%83%B0%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>在前面有简易说到不可变性是咋回事，这里要稍微理性一些认识不可变性中结构化共享的概念。结构化共享可以使数据结构少占内存，clojure还提供了更节省内存的方法—惰性。</p><hr><ul><li><h3 id="数据也有“版本树”？"><a href="#数据也有“版本树”？" class="headerlink" title="数据也有“版本树”？"></a><font color=#0099ff>数据也有“版本树”？</font></h3></li></ul><p>Clojure的任何值都是不可变的，引用可以任意赋值。即只有可变引用，没有可变对象。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> a '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> a (<span class="name"><span class="builtin-name">conj</span></span> <span class="number">1</span> a))<span class="comment">;=(5 1 2 3 4)</span></span><br></pre></td></tr></table></figure><p>数据的不可变性给多线程场景下的数据共享带来不少福利，因为数据是持久永恒不变的，所以线程间不必担心彼此修改了数据而导致程序不确定性。如果对象是可变的，那么就会像java，需要一堆工具和大部分精力去保证数据对每个线程来说都是正确的，极其不便。</p><p>数据是不可变的，那我要是需要修改数据，怎么办？之前说了，对不可变数据做任何修改，数据都会重新“拷贝”出一份，赋给新的引用。这里说的“拷贝”不是真的把数据复制一份，而是开头说的结构化共享。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;继续上面的list</span></span><br><span class="line"><span class="comment">;好比a和b共享'(1 2 3 4)部分</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> a '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> b (<span class="name"><span class="builtin-name">conj</span></span> a <span class="number">5</span>))<span class="comment">;=(5 1 2 3 4)</span></span><br><span class="line"><span class="comment">;做一下校验</span></span><br><span class="line">(<span class="name">identical?</span> a (<span class="name"><span class="builtin-name">next</span></span> b))<span class="comment">;=true</span></span><br><span class="line"><span class="comment">;在这个简单例子的视图可见，5确实添加在链表，但指向5的指针是b，指针a没有任何偏移。</span></span><br><span class="line"><span class="comment">; b    a</span></span><br><span class="line"><span class="comment">; |    |</span></span><br><span class="line"><span class="comment">;[5]--[1]--[2]--[3]--[4]</span></span><br></pre></td></tr></table></figure><p>列表的结构化共享并不复杂，很容易理解。map则会复杂很多，<code>sorted-map</code>由红黑树实现，<code>array-map</code>、<code>hash-map</code>等由Trie树实现。</p><p>搞个二叉树来简单说明一下map的结构化。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> xconj [t v]</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">    (<span class="name"><span class="builtin-name">nil?</span></span> t) &#123;<span class="symbol">:val</span> v <span class="symbol">:L</span> <span class="literal">nil</span> <span class="symbol">:R</span> <span class="literal">nil</span>&#125;</span><br><span class="line">    (<span class="name"><span class="builtin-name">&lt;</span></span> v (<span class="symbol">:val</span> t)) &#123;<span class="symbol">:val</span> (<span class="symbol">:val</span> t)</span><br><span class="line">                    <span class="symbol">:L</span> (<span class="name">xconj</span> (<span class="symbol">:L</span> t) v)</span><br><span class="line">                    <span class="symbol">:R</span> (<span class="symbol">:R</span> t)&#125;</span><br><span class="line">    <span class="symbol">:else</span>          &#123;<span class="symbol">:val</span> (<span class="symbol">:val</span> t)</span><br><span class="line">                   <span class="symbol">:L</span> (<span class="symbol">:L</span> t)</span><br><span class="line">                   <span class="symbol">:R</span> (<span class="name">xconj</span> (<span class="symbol">:R</span> t) v)&#125;))</span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> tree1 (<span class="name">xconj</span> <span class="literal">nil</span> <span class="number">5</span>))<span class="comment">;=&#123;:val 5, :L nil, :R nil&#125;</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> tree1 (<span class="name">xconj</span> tree1 <span class="number">3</span>))<span class="comment">;=&#123;:val 5, :L &#123;:val 3, :L nil, :R nil&#125;, :R nil&#125;</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> tree1 (<span class="name">xconj</span> tree1 <span class="number">2</span>))<span class="comment">;=&#123;:val 5, :L &#123;:val 3, :L &#123;:val 2, :L nil, :R nil&#125;, :R nil&#125;, :R nil&#125;</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> tree2 (<span class="name">xconj</span> tree1 <span class="number">7</span>))<span class="comment">;=&#123;:val 5, :L &#123;:val 3, :L &#123;:val 2, :L nil, :R nil&#125;, :R nil&#125;, :R &#123;:val 7, :L nil, :R nil&#125;&#125;</span></span><br><span class="line"><span class="comment">;&#123;:val 5, :L &#123;:val 3, :L &#123;:val 2, :L &#123;:val 1, :L nil, :R nil&#125;, :R nil&#125;, :R nil&#125;, :R &#123;:val 7, :L nil, :R nil&#125;&#125;</span></span><br><span class="line"><span class="comment">;&#123;:val 5, :L &#123;:val 3, :L &#123;:val 2, :L &#123;:val 1, :L &#123;:val 0, :L nil, :R nil&#125;, :R nil&#125;, :R nil&#125;, :R nil&#125;, :R &#123;:val 7, :L nil, :R nil&#125;&#125;</span></span><br><span class="line"><span class="comment">;&#123;:val 5, :L &#123;:val 3, :L &#123;:val 2, :L &#123;:val 1, :L &#123;:val 0, :L nil, :R nil&#125;, :R nil&#125;, :R nil&#125;, :R &#123;:val 4, :L nil, :R nil&#125;&#125;, :R &#123;:val 7, :L nil, :R nil&#125;&#125;</span></span><br><span class="line"><span class="comment">;两棵树的形状大致如下：</span></span><br><span class="line"><span class="comment">;   tree1            tree2</span></span><br><span class="line"><span class="comment">;    [5]              [5]</span></span><br><span class="line"><span class="comment">;   |   |            |   |</span></span><br><span class="line"><span class="comment">;  [3]  nil         [3] [7]</span></span><br><span class="line"><span class="comment">; |                |   </span></span><br><span class="line"><span class="comment">;[2]              [2]  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">;取tree1和tree2的左边比较，结果是相等的</span></span><br><span class="line">(<span class="name">identical?</span> (<span class="symbol">:L</span> tree1) (<span class="symbol">:L</span> tree2))<span class="comment">;=true</span></span><br><span class="line"><span class="comment">;   tree1</span></span><br><span class="line"><span class="comment">;    [5]</span></span><br><span class="line"><span class="comment">;   |     tree2</span></span><br><span class="line"><span class="comment">;  [3] --- [5]</span></span><br><span class="line"><span class="comment">; |          |   </span></span><br><span class="line"><span class="comment">;[2]        [7]</span></span><br></pre></td></tr></table></figure><p>上面的简易二叉树例子，可以发现：</p><p>1、数据结果每做一次修改，至少新增一个节点；</p><p>2、未被修改的另一边分支不会被复杂(比如[2]-[3])，可应用整棵树及其分支；</p><p>3、整个过程是线程安全的，多线程同时改变tree1，tree1依然是那棵树；</p><p>不同引用与这个结构化共享的数据形成了“版本树”，每个引用各自对应一个版本的数据。结构化共享是支持不变量所必须的，不然一直复制数据迟早会把内存撑爆。</p><ul><li><h3 id="让数据更懒惰～"><a href="#让数据更懒惰～" class="headerlink" title="让数据更懒惰～"></a><font color=#0099ff>让数据更懒惰～</font></h3></li></ul><p>上面说到的结构化共享，作用于修改不变量时节省内存。但在处理大数据量是，单凭结构化共享是远远不够，十万八千里都不止！例如声明一个长列表是很耗性能的，完全实例化需要的内存可能非常多，花费的时间可能相当长，如果实例化过程中使用递归，完全会导致栈溢出。</p><p>举个例子，把一个向量转为多个cons嵌套。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> rec-step [[x &amp; rest]]</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> x</span><br><span class="line">    [x (<span class="name">rec-step</span> rest)]</span><br><span class="line">    []))</span><br><span class="line"><span class="comment">;长度只有10，很容易就实例化全部元素</span></span><br><span class="line">(<span class="name">rec-step</span> [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>])<span class="comment">;=[0 [1 [2 [3 [4 [5 [6 [7 [8 [9 []]]]]]]]]]]</span></span><br><span class="line"><span class="comment">;假如需要20000个元素，长度不仅很长，而且实例化函数并非尾递归，未完全实例化就栈溢出。</span></span><br><span class="line">(<span class="name">rec-step</span> (<span class="name"><span class="builtin-name">range</span></span> <span class="number">20000</span>))<span class="comment">;StackOverflowError   clojure.lang.LongRange.next (LongRange.java:142)</span></span><br></pre></td></tr></table></figure><p>所以clojure给我提供了<code>lazy-seq</code>宏，用于生成惰性序列。惰性序列是干吗用的呢？当声明一个惰性序列后，里面的元素只有被调用到时才会被实例化，这样内存不会被一时间的大量数据耗尽，程序也不会长时间阻塞在实例化列表元素。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;好比这个生成区间列表的函数</span></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> simple-lst [i limit]</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> limit i) (<span class="name"><span class="builtin-name">conj</span></span> (<span class="name">simple-lst</span> (<span class="name"><span class="builtin-name">inc</span></span> i) limit) i)</span><br><span class="line">        (<span class="name"><span class="builtin-name">&lt;</span></span> limit i) <span class="literal">nil</span></span><br><span class="line">        <span class="symbol">:else</span> (<span class="name"><span class="builtin-name">list</span></span> i)))</span><br><span class="line"><span class="comment">;理想结果是(0 1 2 3 .... 9999999 10000000)，然而并不是</span></span><br><span class="line"><span class="comment">;一不小心就 StackOverflowError   clojure.lang.Numbers$LongOps.lt (Numbers.java:521)</span></span><br><span class="line">(<span class="name">simple-lst</span> <span class="number">0</span> <span class="number">10000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;来个惰性序列版的</span></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> lazy-simple-lst [i limit]</span><br><span class="line">  (<span class="name"><span class="builtin-name">lazy-seq</span></span></span><br><span class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&gt;=</span></span> limit i)</span><br><span class="line">      (<span class="name"><span class="builtin-name">cons</span></span> i (<span class="name">lazy-simple-lst</span> (<span class="name"><span class="builtin-name">inc</span></span> i) limit)))))</span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> a (<span class="name">lazy-simple-lst</span> <span class="number">0</span> <span class="number">10000000</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">class</span></span> a)<span class="comment">;=clojure.lang.LazySeq</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;由于惰性序列需要调用时才实例化元素，所以在类似获取序列长度就需要完全实例化，非常耗时！</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> lzy-lst (<span class="name">lazy-simple-lst</span> <span class="number">0</span> <span class="number">2000</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> lst (<span class="name">simple-lst</span> <span class="number">0</span> <span class="number">2000</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">time</span></span> (<span class="name"><span class="builtin-name">count</span></span> lzy-lst))<span class="comment">;="Elapsed time: 20.47562 msecs"</span></span><br><span class="line">(<span class="name"><span class="builtin-name">time</span></span> (<span class="name"><span class="builtin-name">count</span></span> lst))<span class="comment">;="Elapsed time: 0.274659 msecs"</span></span><br></pre></td></tr></table></figure><p><font color=#f28080>lazy-seq的next和rest操作结果也是有区别的。</font>每取一次seq时，rest都会完全按照我们的本意，一个一个实例化出来；next则不然，它为了确保下一次seq是否为nil，会额外实例化至少一个元素，即next返回的序列，至少惰性延迟一个元素。当我们需要尽可能的惰性序列时，则用rest。在一般情况下，用next还是比较保险的，但如果每实例化一个元素都很费劲的话，显然rest实现完全惰性是不二选择!</p><p>虽然惰性序列能保证大数据量不会被必须一次性完全实例化而导致内存爆，但数据被逐个调用后，如果不放弃头部，迟早还是会奔溃。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;编译器会自行推断lazy-seq是否需要保持头，如果不需要，会自动逐渐清理垃圾。</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [r (<span class="name">lazy-simple-lst</span> <span class="number">0</span> <span class="number">1</span>e8)] (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">first</span></span> r) (<span class="name"><span class="builtin-name">last</span></span> r)))</span><br><span class="line"><span class="comment">;否则，一直持有序列头部，会使被实例化的部分无法释放，占用内存，直到StackOverflowError或OutOfMemoryError。尽管编译器可能会优化值的运算顺序，但也是要保证在纯函数下，所以丢弃头是惯用法，最好是这样做！</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [r (<span class="name">lazy-simple-lst</span> <span class="number">0</span> <span class="number">1</span>e8)] (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">last</span></span> r) (<span class="name"><span class="builtin-name">first</span></span> r)))<span class="comment">;=OutOfMemoryError GC overhead limit exceeded  user/lazy-simple-lst</span></span><br></pre></td></tr></table></figure><p>惰性是个好东西！</p><ul><li><h3 id="分块序列"><a href="#分块序列" class="headerlink" title="分块序列"></a><font color=#0099ff>分块序列</font></h3></li></ul><p>clojure有个很值得一提的技术，夹在一次性完全实例化和逐一实例化的惰性之间，就是分块序列，意思是每一次实例化一定宽度的元素(称“分块窗口”)。分块序列在某些时候，其综合性能要比惰性序列要高，毕竟惰性的“一次一个”实例化的消耗还是不容小视的。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> gimme #(<span class="name"><span class="builtin-name">do</span></span> (<span class="name">print</span> \. %)))</span><br><span class="line"><span class="comment">;现在只需要第一个元素，但可以看到依然实例化整个区间</span></span><br><span class="line">(<span class="name"><span class="builtin-name">take</span></span> <span class="number">1</span> (<span class="name"><span class="builtin-name">map</span></span> gimme (<span class="name"><span class="builtin-name">range</span></span> <span class="number">32</span>)))<span class="comment">;=. 0. 1. 2. 3. 4. 5. 6. 7. 8 ... 24. 25. 26. 27. 28. 29. 30. 31</span></span><br><span class="line"><span class="comment">;同样只需要第一个元素，整个区间长度为65，但只实例化前32个元素</span></span><br><span class="line">(<span class="name"><span class="builtin-name">take</span></span> <span class="number">1</span> (<span class="name"><span class="builtin-name">map</span></span> gimme (<span class="name"><span class="builtin-name">range</span></span> <span class="number">65</span>)))<span class="comment">;=. 0. 1. 2. 3. 4. 5. 6. 7. 8 ... 24. 25. 26. 27. 28. 29. 30. 31</span></span><br><span class="line"><span class="comment">;当我们想获取第33个元素时，实例化了两个分块窗口(0-31,32-63)，64未被求值</span></span><br><span class="line">(<span class="name"><span class="builtin-name">take</span></span> <span class="number">1</span> (<span class="name"><span class="builtin-name">drop</span></span> <span class="number">32</span> (<span class="name"><span class="builtin-name">map</span></span> gimme (<span class="name"><span class="builtin-name">range</span></span> <span class="number">65</span>))))<span class="comment">;=. 0. 1. 2. 3. 4. 5. 6. 7. 8 ... 56. 57. 58. 59. 60. 61. 62. 63</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 函数编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clojure </tag>
            
            <tag> 教程 </tag>
            
            <tag> 并发编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学Clojure—集合与数据结构</title>
      <link href="/2017/01/23/20170123-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2017/01/23/20170123-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>这个很重要，不需要多说，clojure提供了vector、list、queue、set、map这几种数据结构，来看看它们的基本操作。</p><hr><ul><li><h3 id="非写入硬盘的数据持久化"><a href="#非写入硬盘的数据持久化" class="headerlink" title="非写入硬盘的数据持久化"></a><font color=#0099ff>非写入硬盘的数据持久化</font></h3></li></ul><p>这里说的数据持久化，指的是不变量，即值是不能被改变的。值的不可变，使得我们不需要担心值更新所带来的不确定性，在并发场景下不需要花费过多精力维护数据的准确性。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;声明list</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> lst1 (<span class="name"><span class="builtin-name">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line"><span class="comment">;添加新元素，它重新生产一个“新列表”</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> lst2 (<span class="name"><span class="builtin-name">conj</span></span> lst <span class="number">5</span>))<span class="comment">;=(5 1 2 3 4)</span></span><br><span class="line"><span class="comment">;lst引用依旧指向(1 2 3 4)</span></span><br><span class="line">lst1 ;=(1 2 3 4)</span><br></pre></td></tr></table></figure><p>为达到值的不可变，而创建一个新值，可能会对此认为这实在浪费内存空间，每次改变值都要重新复制一份出来。</p><p>其实不是的，用过git的伙伴都知道，即使在文件里加个空格都会生成一个新的版本号，clojure对值的管理与此有一些类似。假如你对<code>lst1</code>做任何增删改，所有元素都会存在于它原本的历史版本中，并且每个版本间都共享结构元素。元素5存在于<code>lst2</code>这个版本中，<code>(1 2 3 4)</code>则<code>lst1</code>与<code>lst2</code>共享。所有版本会形成一棵数，管理map也是如此，只不过版本树会更加复杂。</p><ul><li><h3 id="它叫做向量，不叫数组"><a href="#它叫做向量，不叫数组" class="headerlink" title="它叫做向量，不叫数组"></a><font color=#0099ff>它叫做向量，不叫数组</font></h3></li></ul><p>在clojure我们管它叫vector，不叫array，尽管都以数字作为索引，它是不可变，它的字面量是<code>[]</code>。</p><p>如何创建向量呢？</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;我们可以这样创建一个vector，直接使用字面量</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> vec1 [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>])</span><br><span class="line"><span class="comment">;用vec来引入某个集合的元素，如果是个map，vec2会是个多维向量，至少二维</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> vec2 (<span class="name"><span class="builtin-name">vec</span></span> (<span class="name"><span class="builtin-name">range</span></span> <span class="number">5</span>)))</span><br><span class="line"><span class="comment">;显然，是往一个vector塞另外一个集合</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> vec3 (<span class="name"><span class="builtin-name">into</span></span> vec1 (<span class="name"><span class="builtin-name">range</span></span> <span class="number">6</span> <span class="number">10</span>)))</span><br></pre></td></tr></table></figure><p>可以限制vector为基础数据类型的集合，只要使用<code>vector-of</code>函数即可，支持<code>:int</code>、<code>:long</code>、<code>:float</code>、<code>:double</code>、<code>:byte</code>、<code>:short</code>、<code>:boolean</code>、<code>:char</code>这些基础类型。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">into</span></span> (<span class="name">vector-of</span> <span class="symbol">:int</span>) [Math/PI <span class="number">2</span> <span class="number">1.4</span>])<span class="comment">;=[3 2 1]</span></span><br><span class="line">(<span class="name"><span class="builtin-name">into</span></span> (<span class="name">vector-of</span> <span class="symbol">:char</span>) [<span class="number">100</span> <span class="number">102</span> <span class="number">104</span>])<span class="comment">;=[\d \f \h]</span></span><br><span class="line">(<span class="name"><span class="builtin-name">into</span></span> (<span class="name">vector-of</span> <span class="symbol">:boolean</span>) [<span class="literal">false</span> <span class="literal">true</span> <span class="number">1</span> <span class="literal">nil</span>])<span class="comment">;=[false true true false]</span></span><br><span class="line">(<span class="name"><span class="builtin-name">into</span></span> (<span class="name">vector-of</span> <span class="symbol">:long</span>) [<span class="string">"string"</span> <span class="string">"number"</span> <span class="number">10000</span>])</span><br><span class="line"><span class="comment">;=ClassCastException java.lang.String cannot be cast to java.lang.Number</span></span><br></pre></td></tr></table></figure><p>有索引，自然可以用下标获取元素，有<code>nth</code>、<code>get</code>、向量自身作为函数三种方式，每种都有那么一点不同。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> nil_vec <span class="literal">nil</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> empty_vec [])</span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> char_vec [\a \b \c \d \f])</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">nth</span></span> nil_vec <span class="number">3</span>)<span class="comment">;=nil</span></span><br><span class="line">(<span class="name"><span class="builtin-name">nth</span></span> empty_vec <span class="number">3</span>)<span class="comment">;=IndexOutOfBoundsException</span></span><br><span class="line">(<span class="name"><span class="builtin-name">nth</span></span> char_vec <span class="number">3</span>)<span class="comment">;=\d</span></span><br><span class="line"><span class="comment">;支持not find参数，找不到元素则返回该实参</span></span><br><span class="line">(<span class="name"><span class="builtin-name">nth</span></span> char_vec <span class="number">100</span> <span class="symbol">:no!</span>)<span class="comment">;=:no!</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">get</span></span> nil_vec <span class="number">3</span>)<span class="comment">;=nil</span></span><br><span class="line">(<span class="name"><span class="builtin-name">get</span></span> empty_vec <span class="number">3</span>)<span class="comment">;=nil</span></span><br><span class="line">(<span class="name"><span class="builtin-name">get</span></span> char_vec <span class="number">3</span>)<span class="comment">;=\d</span></span><br><span class="line"><span class="comment">;同上</span></span><br><span class="line">(<span class="name"><span class="builtin-name">get</span></span> char_vec <span class="number">100</span> <span class="symbol">:no!</span>)<span class="comment">;=:no!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;clojure有个奇妙的特性，就是集合本身可以作为函数，返回自己内部的元素</span></span><br><span class="line">(<span class="name">nil_vec</span> <span class="number">3</span>)<span class="comment">;=NullPointerException</span></span><br><span class="line">(<span class="name">empty_vec</span> <span class="number">3</span>)<span class="comment">;=IndexOutOfBoundsException</span></span><br><span class="line">(<span class="name">char_vec</span> <span class="number">3</span>)<span class="comment">;=\d</span></span><br><span class="line"><span class="comment">;然而，它并不支持上面两种方式支持的not find参数</span></span><br></pre></td></tr></table></figure><p><font size=2 color=#f28080>以上三种并没有那个最好，更多时候需要具体到业务场景，又或者依据个人喜好。</font></p><p>那么来看看怎么修改元素。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> num_vec [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>])</span><br><span class="line"><span class="comment">;直接修改对于下标的元素</span></span><br><span class="line">(<span class="name"><span class="builtin-name">assoc</span></span> num_vec <span class="number">2</span> <span class="string">"string"</span>)<span class="comment">;=[1 2 "string" 4 5]</span></span><br><span class="line"><span class="comment">;这个则是使用一个函数去改变对应下标的元素</span></span><br><span class="line">(<span class="name">update</span> num_vec <span class="number">2</span> * <span class="number">100</span>)<span class="comment">;=[1 2 300 4 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;遇到多维向量，也提供了get-in、assoc-in、update-in三个函数改变或获取被嵌套的元素</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> num_vec2 [[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>] [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>] [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]])</span><br><span class="line">(<span class="name"><span class="builtin-name">get-in</span></span> num_vec2 [<span class="number">1</span> <span class="number">2</span>])<span class="comment">;=6</span></span><br><span class="line">(<span class="name"><span class="builtin-name">get-in</span></span> num_vec2 [<span class="number">1</span> <span class="number">6</span>])<span class="comment">;=nil</span></span><br><span class="line"><span class="comment">;支持not find参数</span></span><br><span class="line">(<span class="name"><span class="builtin-name">get-in</span></span> num_vec2 [<span class="number">1</span> <span class="number">6</span>] <span class="symbol">:no!</span>)<span class="comment">;=:no!</span></span><br><span class="line">(<span class="name">assoc-in</span> num_vec2 [<span class="number">1</span> <span class="number">2</span>] \s)<span class="comment">;=[[1 2 3] [4 5 \s] [7 8 9]]</span></span><br><span class="line"><span class="comment">;追加到最后一项，如果[1 4]以上则会抛出IndexOutOfBoundsException</span></span><br><span class="line">(<span class="name">assoc-in</span> num_vec2 [<span class="number">1</span> <span class="number">3</span>] \s)<span class="comment">;=[[1 2 3] [4 5 6 \s] [7 8 9]]</span></span><br><span class="line">(<span class="name"><span class="builtin-name">update-in</span></span> num_vec2 [<span class="number">1</span> <span class="number">2</span>] * <span class="number">100</span>)<span class="comment">;=[[1 2 3] [4 5 600] [7 8 9]]</span></span><br><span class="line">(<span class="name"><span class="builtin-name">update-in</span></span> num_vec2 [<span class="number">1</span> <span class="number">3</span>] * <span class="number">100</span>)<span class="comment">;=NullPointerException</span></span><br></pre></td></tr></table></figure><p>vector提供了三个函数，使其支持栈操作，分别是<code>peek</code>返回栈顶、<code>pop</code>除去栈顶、<code>conj</code>推入栈，由于vector是不可变的，所以并不像以往的pop和push完全一样。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> my_stack [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>])</span><br><span class="line">(<span class="name"><span class="builtin-name">peek</span></span> my_stack)<span class="comment">;=5</span></span><br><span class="line">(<span class="name"><span class="builtin-name">pop</span></span> my_stack)<span class="comment">;=[1 2 3 4]</span></span><br><span class="line">(<span class="name"><span class="builtin-name">conj</span></span> my_stack \s)<span class="comment">;=[1 2 3 4 5 \s]</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="是Lisp都喜欢的list"><a href="#是Lisp都喜欢的list" class="headerlink" title="是Lisp都喜欢的list"></a><font color=#0099ff>是Lisp都喜欢的list</font></h3></li></ul><p>list是单链表结构，即每个节点都有指向下一个节点的指针，且知道距离末端的长度，它同样不可变，添加删除都发生在最左端。</p><p>我们可以这样创建list：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span>)</span><br><span class="line">'(1 2 3 4)</span><br></pre></td></tr></table></figure><p>也提供了<code>conj</code>和<code>cons</code>两种方式添加元素，两者返回的结果有所不同，神奇的是，连参数顺序都不一样！！<br> <figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;conj返回的结果与它的第一个参数同构，意思是传入seq返回seq，传入list返回list</span></span><br><span class="line"><span class="comment">;yep!'(1 2)是个list</span></span><br><span class="line">(<span class="name"><span class="builtin-name">list?</span></span> (<span class="name"><span class="builtin-name">conj</span></span> '(<span class="number">1</span> <span class="number">2</span>) <span class="number">3</span>))<span class="comment">;=true</span></span><br><span class="line">(<span class="name"><span class="builtin-name">seq?</span></span> (<span class="name"><span class="builtin-name">conj</span></span> '(<span class="number">1</span> <span class="number">2</span>) <span class="number">3</span>))<span class="comment">;=true</span></span><br><span class="line"><span class="comment">;(range 2)是个seq</span></span><br><span class="line">(<span class="name"><span class="builtin-name">list?</span></span> (<span class="name"><span class="builtin-name">conj</span></span> (<span class="name"><span class="builtin-name">range</span></span> <span class="number">2</span>) <span class="number">3</span>))<span class="comment">;=false</span></span><br><span class="line">(<span class="name"><span class="builtin-name">seq?</span></span> (<span class="name"><span class="builtin-name">conj</span></span> (<span class="name"><span class="builtin-name">range</span></span> <span class="number">2</span>) <span class="number">3</span>))<span class="comment">;=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;cons则返回seq，不过第二参数传入list还是seq</span></span><br><span class="line">(<span class="name"><span class="builtin-name">list?</span></span> (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">3</span> '(<span class="number">1</span> <span class="number">2</span>)))<span class="comment">;=false</span></span><br><span class="line">(<span class="name"><span class="builtin-name">seq?</span></span> (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">3</span> '(<span class="number">1</span> <span class="number">2</span>)))<span class="comment">;=true</span></span><br><span class="line">(<span class="name"><span class="builtin-name">list?</span></span> (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">3</span> (<span class="name"><span class="builtin-name">range</span></span> <span class="number">2</span>)))<span class="comment">;=false</span></span><br><span class="line">(<span class="name"><span class="builtin-name">seq?</span></span> (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">3</span> (<span class="name"><span class="builtin-name">range</span></span> <span class="number">2</span>)))<span class="comment">;=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;在对list操作的话，conj无疑是最正确的最为高效的</span></span><br></pre></td></tr></table></figure></p><p>对list的取值函数<code>first</code>、<code>next</code>和<code>rest</code>，完全可以把list作为栈使用。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> nil_list <span class="literal">nil</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> empty_list '())</span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> one_item_list '(<span class="number">1</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> num_list '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">first</span></span> nil_list)<span class="comment">;=nil</span></span><br><span class="line">(<span class="name"><span class="builtin-name">first</span></span> empty_list)<span class="comment">;=nil</span></span><br><span class="line">(<span class="name"><span class="builtin-name">first</span></span> num_list)<span class="comment">;=1</span></span><br><span class="line"><span class="comment">;若无则返回nil</span></span><br><span class="line">(<span class="name"><span class="builtin-name">next</span></span> nil_list)<span class="comment">;=nil</span></span><br><span class="line">(<span class="name"><span class="builtin-name">next</span></span> empty_list)<span class="comment">;=nil</span></span><br><span class="line">(<span class="name"><span class="builtin-name">next</span></span> one_item_list)<span class="comment">;=nil</span></span><br><span class="line">(<span class="name"><span class="builtin-name">next</span></span> num_list)<span class="comment">;=(2 3 4 5)</span></span><br><span class="line"><span class="comment">;若无则返回空list</span></span><br><span class="line">(<span class="name"><span class="builtin-name">rest</span></span> nil_list)<span class="comment">;=()</span></span><br><span class="line">(<span class="name"><span class="builtin-name">rest</span></span> empty_list)<span class="comment">;=()</span></span><br><span class="line">(<span class="name"><span class="builtin-name">rest</span></span> one_item_list)<span class="comment">;=()</span></span><br><span class="line">(<span class="name"><span class="builtin-name">rest</span></span> num_list)<span class="comment">;=(2 3 4 5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;list是可以使用pop和peek的，但由于已经提供了上面三个函数，而且当pop用在empty_list会抛出异常，所以强烈建议用first、next和rest</span></span><br></pre></td></tr></table></figure><p><font color=#f28080>强调一点，list不支持索引查找！</font></p><ul><li><h3 id="集合！不能有重复元素！"><a href="#集合！不能有重复元素！" class="headerlink" title="集合！不能有重复元素！"></a><font color=#0099ff>集合！不能有重复元素！</font></h3></li></ul><p>set，即集合，与数学上的集合同样有三种特性-确定性、互异性、无序性，没有薛定谔的元素，也没有重复的元素，也没有先后关系的元素（这还说不定呢）。</p><p>怎么创建set？</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">set</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>])<span class="comment">;=#&#123;1 4 3 2&#125;</span></span><br><span class="line">(<span class="name">set</span> &#123;<span class="symbol">:a</span> <span class="number">1</span> <span class="symbol">:b</span> <span class="number">2</span>&#125;)<span class="comment">;=#&#123;[:b 2] [:a 1]&#125;</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> num_set #&#123;<span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span>&#125;)</span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> entry_set #&#123;[<span class="symbol">:b</span> <span class="number">2</span>] [<span class="symbol">:a</span> <span class="number">1</span>]&#125;)</span><br><span class="line"></span><br><span class="line">(<span class="name">set</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>] '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))<span class="comment">;=#&#123;[1 2 3]&#125;，vector视同为list</span></span><br><span class="line">(<span class="name">set</span> [] &#123;&#125; #&#123;&#125; ())<span class="comment">;=#&#123;[] &#123;&#125; #&#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>查询获取set内元素！</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;set作为函数</span></span><br><span class="line">(<span class="name">#</span>&#123;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; <span class="number">3</span>)<span class="comment">;=3</span></span><br><span class="line">(<span class="name"><span class="builtin-name">get</span></span> #&#123;<span class="symbol">:a</span> <span class="symbol">:b</span> <span class="symbol">:c</span>&#125; <span class="symbol">:d</span>)<span class="comment">;=nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;contains?查询元素是否存在</span></span><br><span class="line">(<span class="name"><span class="builtin-name">contains?</span></span> #&#123;<span class="symbol">:a</span> <span class="symbol">:b</span> <span class="symbol">:c</span> <span class="symbol">:d</span>&#125; <span class="symbol">:d</span>)<span class="comment">;=true</span></span><br><span class="line">(<span class="name"><span class="builtin-name">contains?</span></span> #&#123;<span class="symbol">:a</span> <span class="symbol">:b</span> <span class="symbol">:c</span> <span class="symbol">:d</span>&#125; <span class="symbol">:e</span>)<span class="comment">;=false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;顺序集合sorted-set</span></span><br><span class="line">(<span class="name"><span class="builtin-name">sorted-set</span></span> <span class="symbol">:c</span> <span class="symbol">:d</span> <span class="symbol">:a</span> <span class="symbol">:b</span>)<span class="comment">;=#&#123;:a :b :c :d&#125;</span></span><br><span class="line">(<span class="name"><span class="builtin-name">sorted-set</span></span> [<span class="number">1</span> <span class="number">2</span>] [<span class="number">4</span> <span class="number">5</span>] [<span class="number">2</span> <span class="number">3</span>])<span class="comment">;=#&#123;[1 2] [2 3] [4 5]&#125;</span></span><br><span class="line"><span class="comment">;sorted-set在默认情况下，对元素类型有潜在的混淆，比如number与string无法一起排序，添加元素时也容易出现类型混淆</span></span><br><span class="line">(<span class="name"><span class="builtin-name">sorted-set</span></span> <span class="string">"a"</span> <span class="number">1</span> <span class="number">2</span> <span class="string">"0"</span>)<span class="comment">;=ClassCastException java.lang.String cannot be cast to java.lang.Number</span></span><br></pre></td></tr></table></figure><p><font size=2 color=#f28080><code>contains?</code>这个函数实际上是查找健值是否存在，这就表明set实际上也是map实现的，而它的键值与值相同。在这补充一点，set与vector都是基于map实现，但<code>contains?</code>在vector是无效的，因为它是以索引为键值，故<code>(contains? [:a :b :c] 2)</code>才能返回true，按元素值查找始终返回false。</font></p><p>关于set的集合计算没打算讲，见<code>clojure.set/intersection</code>、<code>clojure.set/union</code>、<code>clojure.set/difference</code>的API。</p><ul><li><h3 id="map！重中之重！"><a href="#map！重中之重！" class="headerlink" title="map！重中之重！"></a><font color=#0099ff>map！重中之重！</font></h3></li></ul><p>map可能是clojure被应用最广的数据结构，不管你是否知情，比如用set时实际上用了map。</p><p>有几样map，<code>hash-map</code>、<code>array-map</code>和<code>sorted-map</code>，不同的创建方式，返回也会是不同类型的map。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;直接用字面量创建map，它是个array-map</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> a_array_map &#123;<span class="symbol">:a</span> <span class="number">1</span> <span class="symbol">:b</span> <span class="number">2</span> <span class="symbol">:c</span> <span class="number">3</span> <span class="symbol">:d</span> <span class="number">4</span>&#125;)</span><br><span class="line">(<span class="name"><span class="builtin-name">class</span></span> a_array_map)<span class="comment">;=clojure.lang.PersistentArrayMap</span></span><br><span class="line"><span class="comment">;显示创建array-map</span></span><br><span class="line">(<span class="name">array-map</span> <span class="symbol">:a</span> <span class="number">1</span> <span class="symbol">:b</span> <span class="number">2</span>)<span class="comment">;=&#123;:a 1, :b 2&#125;</span></span><br><span class="line"><span class="comment">;用zipmap创建也是个array-map，在clojure 1.2则是个hash-map</span></span><br><span class="line">(<span class="name"><span class="builtin-name">zipmap</span></span> [<span class="symbol">:a</span> <span class="symbol">:b</span> <span class="symbol">:c</span>] [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>])<span class="comment">;=&#123;:a 1, :b 2, :c 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;hash-map创建一个HashMap</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> a_hash_map (<span class="name"><span class="builtin-name">hash-map</span></span> <span class="symbol">:a</span> <span class="number">1</span> <span class="symbol">:b</span> <span class="number">2</span> <span class="symbol">:c</span> <span class="number">3</span> <span class="symbol">:d</span> <span class="number">4</span>))<span class="comment">;=&#123;:c 3, :b 2, :d 4, :a 1&#125;</span></span><br><span class="line">(<span class="name"><span class="builtin-name">class</span></span> a_hash_map)<span class="comment">;=clojure.lang.PersistentHashMap</span></span><br><span class="line">(<span class="name"><span class="builtin-name">apply</span></span> hash-map [<span class="symbol">:a</span> <span class="number">1</span> <span class="symbol">:b</span> <span class="number">2</span> <span class="symbol">:c</span> <span class="number">3</span> <span class="symbol">:d</span> <span class="number">4</span>])<span class="comment">;=&#123;:c 3, :b 2, :d 4, :a 1&#125;</span></span><br></pre></td></tr></table></figure><p><code>hash-map</code>的键值是无法指定顺序的，<code>array-map</code>则是按照插入顺序，只有<code>sorted-map</code>的键值能依照默认或我们提供的特定顺序进行排序。不过有一点，因为<code>sorted-map</code>键值需要遵循特定顺序，所以对键值的类型也有所限定，不再像其他两个类型的map一样支持异构。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">sorted-map</span></span> <span class="symbol">:d</span> <span class="number">1</span> <span class="symbol">:a</span> <span class="number">3</span> <span class="symbol">:o</span> <span class="number">9</span> <span class="symbol">:c</span> <span class="string">"d"</span>)<span class="comment">;=&#123;:a 3, :c "d", :d 1, :o 9&#125;</span></span><br><span class="line"><span class="comment">;键值类型不一致而无法比较，会直接抛出异常</span></span><br><span class="line">(<span class="name"><span class="builtin-name">sorted-map</span></span> <span class="symbol">:d</span> <span class="number">1</span> <span class="symbol">:a</span> <span class="number">3</span> <span class="symbol">:o</span> <span class="number">9</span> <span class="string">"d"</span> <span class="string">"d"</span>)<span class="comment">;=ClassCastException clojure.lang.Keyword cannot be cast to java.lang.String</span></span><br><span class="line"><span class="comment">;可以自定义比较器来创建sorted-map，即sorted-map-by函数</span></span><br><span class="line">(<span class="name"><span class="builtin-name">sorted-map-by</span></span></span><br><span class="line">  #(<span class="name"><span class="builtin-name">let</span></span> [[x y]</span><br><span class="line">         (<span class="name"><span class="builtin-name">map</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [z]</span><br><span class="line">                (<span class="name">Integer/valueOf</span> (<span class="name"><span class="builtin-name">last</span></span> (<span class="name">.split</span> z <span class="string">"-"</span>)))) [%<span class="number">1</span> %<span class="number">2</span>])]</span><br><span class="line">     (<span class="name"><span class="builtin-name">compare</span></span> x y)) <span class="string">"tom-12"</span> <span class="symbol">:BJ</span> <span class="string">"jim-24"</span> <span class="symbol">:GZ</span> <span class="string">"anj-6"</span> <span class="symbol">:SZ</span>)<span class="comment">;=&#123;"anj-6" :SZ, "tom-12" :BJ, "jim-24" :GZ&#125;</span></span><br></pre></td></tr></table></figure><p>获取map的某个值也是用get，map本身也可以作为函数且接受一个参数，键值(只能为keyword类型)同样可以作为函数且接受一个map。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> person &#123;</span><br><span class="line">             <span class="symbol">:name</span> <span class="string">"Mark Volkmann"</span></span><br><span class="line">             <span class="symbol">:address</span> &#123;</span><br><span class="line">                       <span class="symbol">:street</span> <span class="string">"644 Glen Summit"</span></span><br><span class="line">                       <span class="symbol">:city</span> <span class="string">"St. Charles"</span></span><br><span class="line">                       <span class="symbol">:state</span> <span class="string">"Missouri"</span></span><br><span class="line">                       <span class="symbol">:zip</span> <span class="number">63304</span>&#125;</span><br><span class="line">             <span class="symbol">:employer</span> &#123;</span><br><span class="line">                        <span class="symbol">:name</span> <span class="string">"Object Computing, Inc."</span></span><br><span class="line">                        <span class="symbol">:address</span> &#123;</span><br><span class="line">                                  <span class="symbol">:street</span> <span class="string">"12140 Woodcrest Executive Drive, Suite 250"</span></span><br><span class="line">                                  <span class="symbol">:city</span> <span class="string">"Creve Coeur"</span></span><br><span class="line">                                  <span class="symbol">:state</span> <span class="string">"Missouri"</span></span><br><span class="line">                                  <span class="symbol">:zip</span> <span class="number">63141</span>&#125;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">get</span></span> person <span class="symbol">:name</span>)<span class="comment">;="Mark Volkmann"</span></span><br><span class="line">(<span class="name"><span class="builtin-name">get</span></span> (<span class="name"><span class="builtin-name">get</span></span> person <span class="symbol">:employer</span>) name)<span class="comment">;="Object Computing, Inc."</span></span><br><span class="line"></span><br><span class="line">(<span class="name">person</span> <span class="symbol">:name</span>)<span class="comment">;="Mark Volkmann"</span></span><br><span class="line">((<span class="name">person</span> <span class="symbol">:employer</span>) <span class="symbol">:name</span>)<span class="comment">;="Object Computing, Inc."</span></span><br><span class="line"></span><br><span class="line">(<span class="symbol">:name</span> person)<span class="comment">;="Mark Volkmann"</span></span><br><span class="line">(<span class="symbol">:name</span> (<span class="symbol">:employer</span> person))<span class="comment">;="Object Computing, Inc."</span></span><br><span class="line"><span class="comment">;因为键值作为函数，所以可以当作组合函数而使用'-&gt;'宏；反之，map作为函数则不行。</span></span><br><span class="line"><span class="comment">;第一个参数是第二个参数的实参，获取到子map后传递到给后面的键值</span></span><br><span class="line">(<span class="name"><span class="builtin-name">-&gt;</span></span> person <span class="symbol">:employer</span> <span class="symbol">:name</span>)<span class="comment">;="Object Computing, Inc."</span></span><br></pre></td></tr></table></figure><p>给map修改添加键值对的函数与set说到的几个函数一样，<code>assoc-in</code>、<code>update-in</code>和<code>assoc</code>。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">assoc-in</span> person [<span class="symbol">:employer</span> <span class="symbol">:address</span> <span class="symbol">:city</span>] <span class="string">"Clayton"</span>)</span><br><span class="line"><span class="comment">;如果键值不存在，则新添进去</span></span><br><span class="line">(<span class="name">assoc-in</span> person [<span class="symbol">:employer</span> <span class="symbol">:address</span> <span class="symbol">:phone</span>] <span class="string">"13700000000"</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">update-in</span></span> person [<span class="symbol">:employer</span> <span class="symbol">:address</span> <span class="symbol">:zip</span>] str <span class="string">"-1234"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;需要注意一点，当map的键值是数字类型时，在有序map和hashmap或arraymap上做assoc操作结果是有可能不同的。(在《clojure编程乐趣》有说到)</span></span><br><span class="line">(<span class="name"><span class="builtin-name">assoc</span></span> &#123;<span class="number">1</span> <span class="symbol">:int</span>&#125; <span class="number">1.0</span> <span class="symbol">:float</span>)<span class="comment">;=&#123;1 :int, 1.0 :float&#125;</span></span><br><span class="line"><span class="comment">;有序集合中，键值相等则认为是同一个</span></span><br><span class="line">(<span class="name"><span class="builtin-name">assoc</span></span> (<span class="name"><span class="builtin-name">sorted-map</span></span> <span class="number">1</span> <span class="symbol">:int</span>) <span class="number">1.0</span> <span class="symbol">:float</span>)<span class="comment">;=&#123;1 :float&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 函数编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clojure </tag>
            
            <tag> 教程 </tag>
            
            <tag> 并发编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学Clojure—函数与高阶函数</title>
      <link href="/2017/01/21/20170121-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%87%BD%E6%95%B0%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
      <url>/2017/01/21/20170121-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%87%BD%E6%95%B0%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>本来这应该放在递归之前的，不过没什么影响，反而对闭包的理解有帮助。把函数作为第一等公民的clojure，自然会给函数提供吊炸天的功能，使其变得吊炸天，写出更吊炸天的闭包！例如串行调用的组合函数、偏函数和柯里化、以及高阶函数等等。</p><hr><ul><li><h3 id="函数的结果传给下一个函数"><a href="#函数的结果传给下一个函数" class="headerlink" title="函数的结果传给下一个函数"></a><font color=#0099ff>函数的结果传给下一个函数</font></h3></li></ul><p>有时候我们一个数据，需要依次传给一个函数处理后，传递给另外一个函数继续处理，多次传递形成函数链。</p><p>假如在一堆没有换行符的字符串中找某个人名以及他的年龄，可能需要这样的函数链。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;为了方便，假如只找第一个</span></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> find-name&amp;age [names] (<span class="name"><span class="builtin-name">vec</span></span> (<span class="name">.split</span></span><br><span class="line">                                   (<span class="name"><span class="builtin-name">first</span></span></span><br><span class="line">                                     (<span class="name">re-seq</span> #<span class="string">"\w*-\d*"</span> names))</span><br><span class="line">                                   <span class="string">"-"</span>)))</span><br><span class="line">(<span class="name">find-name&amp;age</span> <span class="string">"tom-42tim-24jim-12"</span>)<span class="comment">;=[tom 42]</span></span><br><span class="line"><span class="comment">;上面find-name&amp;age [names]实在写得难看，一条链下来的函数多得要死不说，单单圆括号就实在让人生畏。</span></span><br></pre></td></tr></table></figure><p>clojure为我们提供了一个可以省去那么多没必要圆括号的函数-<code>comp</code>！！</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;comp从右到左依次接受上一个函数的返回值，最后一个函数则接受comp外的实参</span></span><br><span class="line">((<span class="name"><span class="builtin-name">comp</span></span> vec #(<span class="name">.split</span> % <span class="string">"-"</span>) first re-seq) #<span class="string">"\w*-\d*"</span> <span class="string">"tom-42tim-24jim-12"</span>)<span class="comment">;=[tom 42]</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="实在不想每次都传那么多个参数！"><a href="#实在不想每次都传那么多个参数！" class="headerlink" title="实在不想每次都传那么多个参数！"></a><font color=#0099ff>实在不想每次都传那么多个参数！</font></h3></li></ul><p>假如你的代码里总是需要<code>(+ 101 1 2 ? ? ?)</code>这样的函数的，偏函数可以让你传入某些固定的实参并返回一个需要传入剩余参数的新函数。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;传入101 1 2三个实参</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> my_+ (<span class="name"><span class="builtin-name">partial</span></span> + <span class="number">101</span> <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line"><span class="comment">;传入剩余参数</span></span><br><span class="line">(<span class="name">my_+</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)<span class="comment">;=114</span></span><br></pre></td></tr></table></figure><p>说到偏函数，自然会想到柯里化，然而。.</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> rematch [rex]</span><br><span class="line">  #(<span class="name">re-seq</span> rex %))</span><br><span class="line"><span class="comment">;括号没法省略，柯里化？算了吧！可以用变参就用变参吧！</span></span><br><span class="line">((<span class="name">rematch</span> #<span class="string">"\w*-\d*"</span>) <span class="string">"tom-42tim-24jim-12"</span>)</span><br></pre></td></tr></table></figure><ul><li><h3 id="传入或返回一个函数"><a href="#传入或返回一个函数" class="headerlink" title="传入或返回一个函数"></a><font color=#0099ff>传入或返回一个函数</font></h3></li></ul><p>函数作为实参传入另外一个函数，后者则是一个高阶函数。clojure提供了许多高阶函数，例如<code>apply</code>、<code>map</code>、<code>filter</code>等。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">map</span></span> + [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>] [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>])<span class="comment">;=(2 4 6)</span></span><br><span class="line">(<span class="name"><span class="builtin-name">apply</span></span> + [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>])<span class="comment">;=10</span></span><br><span class="line"><span class="comment">;匿名函数是高阶函数的一个重要组成部分，临时作为实参，尤其作为返回值。</span></span><br><span class="line">(<span class="name"><span class="builtin-name">map</span></span> #(<span class="name"><span class="builtin-name">name</span></span> %) [<span class="symbol">:a</span> <span class="symbol">:b</span> <span class="symbol">:c</span>])<span class="comment">;=("a" "b" "c")</span></span><br></pre></td></tr></table></figure><p>上面的一个例子<code>rematch [rex]</code>就是一个把函数作为返回值的高阶函数。</p><ul><li><h3 id="绝妙的闭包"><a href="#绝妙的闭包" class="headerlink" title="绝妙的闭包"></a><font color=#0099ff>绝妙的闭包</font></h3></li></ul><p>在之前出现过的例子，有不少已经体现了闭包这个概念。</p><p>闭包什么意思呢？简单且不严谨的说，就是返回一个函数，然后这个函数可随意访问定义它的上下文的局部量。<code>A()</code>定义并返回<code>B()</code>，且<code>B()</code>可以返回<code>A()</code>中声明的局部量，那么调用<code>A()</code>时，得到一个闭包函数。偏函数和柯里化是一种闭包。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;函数中定义并返回一个匿名函数</span></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> rematch2 [content]</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [rex]</span><br><span class="line">    <span class="comment">;匿名函数可以随意返回上下文(即rematch2内)的局部量content</span></span><br><span class="line">    (<span class="name">re-seq</span> rex (<span class="name"><span class="builtin-name">str</span></span> content <span class="string">"///0099ff"</span>))))</span><br><span class="line">((<span class="name">rematch2</span> <span class="string">"tom-42tim-24jim-12"</span>) #<span class="string">"\d+"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 函数编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clojure </tag>
            
            <tag> 教程 </tag>
            
            <tag> 并发编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学Clojure—循环与尾递归</title>
      <link href="/2017/01/19/20170119-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%B0%BE%E9%80%92%E5%BD%92/"/>
      <url>/2017/01/19/20170119-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%B0%BE%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>Lisp语言中，循环不像Java提供<code>for</code>、<code>while</code>等语法，经典用法还是使用递归，clojure也有提供loop循环。在clojure中，递归、循环息息相关的工具<code>recur</code>，它的存在跟clojure实现在jvm之上有所关系，其原因也跟Java为什么有<code>for</code>、<code>while</code>等语法相关。</p><hr><ul><li><h3 id="recur是什么？怎么用？"><a href="#recur是什么？怎么用？" class="headerlink" title="recur是什么？怎么用？"></a><font color=#0099ff>recur是什么？怎么用？</font></h3></li></ul><p><code>recur</code>相对于clojure的宏和函数来说，是个十分底层的程序控制操作，用于循环或递归。可以在不消耗堆栈的情况下，回到函数或循环体的最顶端。</p><p>例如在函数中使用<code>recur</code>实现递归：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;实至名归的尾递归！</span></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> my_dec [x]</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">0</span>)</span><br><span class="line">    x</span><br><span class="line">    <span class="comment">;如果大于0，则回到my_dec，重新进入</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name"><span class="builtin-name">dec</span></span> x))))</span><br></pre></td></tr></table></figure><p>又或者是loop循环：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;看起来还不如上面的递归呢！～</span></span><br><span class="line">(<span class="name"><span class="builtin-name">loop</span></span> [x <span class="number">100</span>]</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">0</span>)</span><br><span class="line">    x</span><br><span class="line">    (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name"><span class="builtin-name">dec</span></span> x))))</span><br></pre></td></tr></table></figure><p><font color=#f28080><code>recur</code>一定要放在结尾位置！不然clojure编译时会报错！比如我在<code>my_dec [x]</code>的<code>if</code>包多一层<code>int</code>会怎样？</font></p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> my_dec [x]</span><br><span class="line">  (<span class="name"><span class="builtin-name">int</span></span> (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">0</span>)</span><br><span class="line">         x</span><br><span class="line">         (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name"><span class="builtin-name">dec</span></span> x)))))</span><br><span class="line"><span class="comment">;CompilerException java.lang.UnsupportedOperationException: Can only recur from tail position</span></span><br></pre></td></tr></table></figure><p><font color=#f28080>显然编译不了，异常信息告诉你，你的<code>recur</code>不是放在结束位置，因为<code>if</code>返回值之后还有其他动作。</font></p><ul><li><h3 id="为什么尾递归不是真正的尾递归？"><a href="#为什么尾递归不是真正的尾递归？" class="headerlink" title="为什么尾递归不是真正的尾递归？"></a><font color=#0099ff>为什么尾递归不是真正的尾递归？</font></h3></li></ul><p>上面的递归递减的例子才是真正的尾递归！为啥？</p><p>ok！在<a href="http://huangzehong.me/2017/01/17/20170117-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">定义函数</a>有个计算阶乘的例子。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">letfn</span></span> [(<span class="name">factorial</span> [x]</span><br><span class="line">          (<span class="name">factorial_2</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>) x))</span><br><span class="line">        (<span class="name">factorial_2</span> [x y]</span><br><span class="line">          (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">1</span>)</span><br><span class="line">            y</span><br><span class="line">            (<span class="name">factorial_2</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>) (<span class="name"><span class="builtin-name">*</span></span> x y))))]</span><br><span class="line">  #(<span class="name">factorial</span> %))</span><br></pre></td></tr></table></figure><p>如果在Java中实现“尾递归”，我可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  <span class="keyword">return</span> factorial(x - <span class="number">1</span>, sum * x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用Java的循环，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jvm没有实现尾递归优化支持，一大半原因是有了for等循环体，就觉得没必要吧。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(;x &gt; <span class="number">1</span>; x--)</span><br><span class="line">    y = y * x;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要先知道的是，jvm不知道为毛，一直不想实现尾调用优化；所以<code>int factorial(x, sum)</code>虽然代码是尾递归格式，但并没什么卵用，这对于运行在它上面的函数式编程语言也是个坑！</p><p>正因为如此，在jvm上运行的clojure自然支持不了<code>factorial[x y]</code>这样的隐式尾递归，但提供了<code>recur</code>这个十分底层的工具（类似于goto），让我们显示地表示出尾递归。顺便说一句，同样运行在jvm的scala实现了尾递归，虽然十分有限，只支持严格尾递归，不明白clojure为啥也不搞一个。</p><ul><li><h3 id="clojure还有其他循环"><a href="#clojure还有其他循环" class="headerlink" title="clojure还有其他循环"></a><font color=#0099ff>clojure还有其他循环</font></h3></li></ul><p>尽管<code>recur</code>能帮你实现高效的尾递归，但依然需要谨慎，适当时候才使用。并不是因为有副作用，而是clojure提供了支持某些循环的宏，例如<code>dotimes</code>、<code>doseq</code>、<code>while</code>（他们底层也是<code>recur</code>），这已经能够满足大多时候的需求了。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">dotimes</span></span> [i <span class="number">10</span>]</span><br><span class="line">  (<span class="name">println</span> <span class="string">"number:"</span> i))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> j <span class="number">10</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">while</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> j <span class="number">0</span>)</span><br><span class="line">  (<span class="name">println</span> <span class="string">"number:"</span> j)</span><br><span class="line">  (<span class="name"><span class="builtin-name">def</span></span> j (<span class="name"><span class="builtin-name">dec</span></span> j)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 函数编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clojure </tag>
            
            <tag> 教程 </tag>
            
            <tag> 并发编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学Clojure—定义函数</title>
      <link href="/2017/01/17/20170117-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/"/>
      <url>/2017/01/17/20170117-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>严格来说，Lisp是一种多范式语言，不仅仅是函数式编程，也可面向对象，也可面向过程，但它的特性确实在函数式编程中更为出色些。Clojure作为Lisp家族中的一员，继承祖先的优良传统，也有自己的特色，特别在“函数是第一公民”的原则上。比如匿名函数的递归，在Common Lisp只能自定义宏实现，在Scheme优雅不少，但也好看不到哪去。</p><hr><ul><li><h3 id="定义有名字的函数"><a href="#定义有名字的函数" class="headerlink" title="定义有名字的函数"></a><font color=#0099ff>定义有名字的函数</font></h3></li></ul><p>定义函数可以<code>defn</code>声明有名字的函数，最后一条表达式的结果作为返回值，<code>defn</code>后面是函数名，<code>[]</code>则是参数。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> i_am_fn [x y]</span><br><span class="line">  (<span class="name"><span class="builtin-name">*</span></span> x y))</span><br><span class="line"></span><br><span class="line"><span class="comment">;clojure的函数重载，只更参数个数有关，与参数类型无关。</span></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> i_am_fn [x y z]</span><br><span class="line">  (<span class="name">println</span> x <span class="string">"+"</span> y <span class="string">"+"</span> z <span class="string">"="</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">*</span></span> x y z)</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> x y z))</span><br><span class="line"></span><br><span class="line"><span class="comment">;或者可以这样写</span></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> i_am_fn</span><br><span class="line">  ([x y]</span><br><span class="line">    (<span class="name"><span class="builtin-name">*</span></span> x y))</span><br><span class="line">  ([x y z]</span><br><span class="line">    (<span class="name">println</span> x <span class="string">"+"</span> y <span class="string">"+"</span> z <span class="string">"="</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">*</span></span> x y z)</span><br><span class="line">    (<span class="name"><span class="builtin-name">+</span></span> x y z)))</span><br></pre></td></tr></table></figure><ul><li><h3 id="定义‘没有’名字的函数—匿名函数"><a href="#定义‘没有’名字的函数—匿名函数" class="headerlink" title="定义‘没有’名字的函数—匿名函数"></a><font color=#0099ff>定义‘没有’名字的函数—匿名函数</font></h3></li></ul><p>定义匿名函数则用<code>fn</code>，同样最后一条表达式的结果作为返回值，<code>fn</code>后面也可以有函数名（可选），<code>[]</code>里是参数列表。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">fn</span></span> [x y]</span><br><span class="line">  (<span class="name">println</span> <span class="string">"i don't kown!!!"</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> x y))</span><br></pre></td></tr></table></figure><p>匿名函数也可以重载，这在匿名函数的递归或互相调用十分有用！我们来看看下面使用递归实现阶乘。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;方式一：</span></span><br><span class="line"><span class="comment">;先看给予匿名函数一个函数名，可以重载两个参数长度不一样的函数。</span></span><br><span class="line"><span class="comment">;factorial[x]调用factorial[x y]，而factorial[x y]做尾递归，并返回给factorial[x]</span></span><br><span class="line"><span class="comment">;但这种写法有个缺点，就是同时暴露了[x]和[x y]两个函数，而我们只需要[x]即可</span></span><br><span class="line">(<span class="name"><span class="builtin-name">fn</span></span> factorial</span><br><span class="line">  ([x]</span><br><span class="line">    (<span class="name">factorial</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>) x))</span><br><span class="line">  ([x y]</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">1</span>)</span><br><span class="line">      y</span><br><span class="line">      (<span class="name">factorial</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>) (<span class="name"><span class="builtin-name">*</span></span> x y)))))</span><br><span class="line"></span><br><span class="line"><span class="comment">;方式二：</span></span><br><span class="line"><span class="comment">;也许我们可以用偏函数？将上面的factorial[x]抽取出来，为factorial[x y]再做一层匿名函数。</span></span><br><span class="line"><span class="comment">;#是函数的字面量</span></span><br><span class="line">(<span class="name">#</span>((<span class="name"><span class="builtin-name">fn</span></span> factorial [x y]</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">1</span>)</span><br><span class="line">       y</span><br><span class="line">       (<span class="name">factorial</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>) (<span class="name"><span class="builtin-name">*</span></span> y x)))) % <span class="number">1</span>) <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;方式三：</span></span><br><span class="line"><span class="comment">;letfn是一种类似于let本地绑定的局部函数声明，可以声明多个本地函数，离开letfn则失效。</span></span><br><span class="line"><span class="comment">;形式上于第一种方式相似，但又有很大不同。</span></span><br><span class="line"><span class="comment">;1、声明的本地函数不一定是重载函数，你看第一种方式，并不能有两个参数长度相同的函数，而letfn允许，只需要函数名不同即可</span></span><br><span class="line"><span class="comment">;2、在最后的返回值，你可以选择暴露哪个函数，而其他函数则私有化</span></span><br><span class="line">(<span class="name"><span class="builtin-name">letfn</span></span> [(<span class="name">factorial</span> [x]</span><br><span class="line">          (<span class="name">factorial_2</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>) x))</span><br><span class="line">        (<span class="name">factorial_2</span> [x y]</span><br><span class="line">          (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">1</span>)</span><br><span class="line">            y</span><br><span class="line">            (<span class="name">factorial_2</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>) (<span class="name"><span class="builtin-name">*</span></span> x y))))]</span><br><span class="line">  #(<span class="name">factorial</span> %))</span><br></pre></td></tr></table></figure><p><font size=2 color=#f28080>上面有个细节需要注意，就是factorial的尾递归，在jvm上不是真正的尾递归，因为虚拟机并没有提供尾调用优化，与普通递归并无二样，以后会说到<code>recur</code>实现尾递归。</font></p><p>三种不同形式的匿名函数递归，显然第一种是最不可取的！论灵活性的话，我自己比较喜欢第三种，用<code>letfn</code>实现，递归中如果有其他独立的算法模块，可以单独作为一个私有方法，提高可读性。不过，若非必要，还是声明普通函数吧！</p><ul><li><h3 id="函数参数的解构"><a href="#函数参数的解构" class="headerlink" title="函数参数的解构"></a><font color=#0099ff>函数参数的解构</font></h3></li></ul><p>参数列表的解构，与<code>let</code>大同小异，可以参考<a href="http://huangzehong.me/2017/01/15/20170115-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" target="_blank" rel="noopener">基本语法</a>。</p><p>先来看看函数可变参数，<code>&amp;</code>字符后跟随的是除去前面参数所剩余的参数列表。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> i_am_fn [x &amp; rest]</span><br><span class="line">  (<span class="name"><span class="builtin-name">apply</span></span> str rest))</span><br><span class="line"><span class="comment">;rest则表示除第一个参数1，剩余的[2 3 4 5 6]</span></span><br><span class="line">(<span class="name">i_am_fn</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)<span class="comment">;="23456"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;也可以表示可变参数</span></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> i_am_fn_2 [&amp; rest] <span class="comment">;也可以[&amp; [rest]]，这样函数至多接受一个参数</span></span><br><span class="line">  &#123;<span class="symbol">:user-id</span> (<span class="name"><span class="builtin-name">or</span></span> rest</span><br><span class="line">              (<span class="name">java.util.UUID/randomUUID</span>))&#125;)</span><br><span class="line">(<span class="name">i_am_fn_2</span> <span class="string">"string"</span> <span class="symbol">:keyname</span> <span class="number">123</span>)<span class="comment">;=&#123;:user-id ("string" :keyname 123)&#125;</span></span><br><span class="line">(<span class="name">i_am_fn_2</span>)<span class="comment">;=&#123;:user-id #uuid"d38aaef2-d5d2-4e86-850e-b29c18b870b5"&#125;</span></span><br></pre></td></tr></table></figure><p>有时候，函数的一些参数并非必要传入，clojure允许我们为参数设置默认值，而这些能被设置默认值的参数叫做关键字参数。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> a_man [username &amp; &#123;<span class="symbol">:keys</span> [email times]</span><br><span class="line">                                    <span class="comment">;设置默认值，如果没有传入值的话，传nil是有效的。</span></span><br><span class="line">                                    <span class="symbol">:or</span> &#123;times (<span class="name">java.util.Date.</span>) email <span class="string">"740762239@qq.com"</span>&#125;&#125;]</span><br><span class="line">  &#123;<span class="symbol">:username</span> username <span class="symbol">:email</span> email <span class="symbol">:time</span> times&#125;)</span><br><span class="line"><span class="comment">;没有被设为关键字参数的参数，则必须要传入！例如username。</span></span><br><span class="line">(<span class="name">a_man</span> <span class="string">"i am man"</span>)</span><br><span class="line"><span class="comment">;=&#123;:username "i am man", :email "740762239@qq.com", :time #inst"2017-01-19T14:25:41.806-00:00"&#125;</span></span><br><span class="line">(<span class="name">a_man</span> <span class="string">"i am man"</span> <span class="symbol">:email</span> <span class="string">"777@qq.com"</span> <span class="symbol">:times</span> <span class="string">"2017-01-17 21:23:53"</span>)</span><br><span class="line"><span class="comment">;=&#123;:username "i am man", :email "777@qq.com", :time "2017-01-17 21:23:53"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;可能会有点不明白上面关键字参数，其实它就是map的解构</span></span><br><span class="line"><span class="comment">;等同于</span></span><br><span class="line"><span class="comment">;只不过，源于优雅，建议用:keys罢了</span></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> a_man [username &amp; &#123;email <span class="symbol">:email</span></span><br><span class="line">                         times <span class="symbol">:times</span></span><br><span class="line">                         <span class="symbol">:or</span> &#123;times (<span class="name">java.util.Date.</span>) email <span class="string">"740762239@qq.com"</span>&#125;&#125;]</span><br><span class="line">  &#123;<span class="symbol">:username</span> username <span class="symbol">:email</span> email <span class="symbol">:time</span> times&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 函数编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clojure </tag>
            
            <tag> 教程 </tag>
            
            <tag> 并发编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学Clojure—基本语法</title>
      <link href="/2017/01/15/20170115-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2017/01/15/20170115-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>为了全面学习函数式编程语言，之前尝试了scala，不得不承认它的入门门槛略高。于是乎，决定从古老的新语言Clorue入手，作为Lisp的一种方言，语法上无疑是古老的，但它又运行在JVM上且有一些不错的机制，无疑是门新语言。</p><hr><ul><li><h3 id="满篇的括号"><a href="#满篇的括号" class="headerlink" title="满篇的括号"></a><font color=#0099ff>满篇的括号</font></h3></li></ul><p>Lisp语法最大特点就是一堆圆括号，任何函数调用都以“(”开始、“)”结束，函数名或函数本身与参数在括号里呈现前缀表达法。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">3</span>) <span class="comment">;=4</span></span><br><span class="line">(<span class="name">add</span> <span class="number">3</span> <span class="number">5</span>) <span class="comment">;=8</span></span><br><span class="line">(<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">=</span></span> <span class="number">1</span> <span class="number">2</span>) (<span class="name"><span class="builtin-name">&gt;</span></span> <span class="number">4</span> <span class="number">6</span>)) <span class="comment">;=false</span></span><br><span class="line"><span class="comment">;下面为匿名函数</span></span><br><span class="line">(<span class="name">#</span>(<span class="name"><span class="builtin-name">apply</span></span> * %) '(<span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)) <span class="comment">;=360</span></span><br></pre></td></tr></table></figure><p>除了圆括号外，也有方括号“[]”，在clojure中，它既可以是向量的字面量，也可是函数的参数列表。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> a_vector [<span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span>]) <span class="comment">;=#'user/a_vector</span></span><br><span class="line"><span class="comment">;或者是个函数的参数列表</span></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> a_function [param1 param2]</span><br><span class="line">  (<span class="name"><span class="builtin-name">do</span></span></span><br><span class="line">    (<span class="name">print</span> <span class="string">"i am function"</span>)))</span><br></pre></td></tr></table></figure><p>当然少不了花括号“{}”，在Map与Set两种数据结构的字面量中体现。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="symbol">:key1</span> val1 <span class="symbol">:key2</span> val2&#125;<span class="comment">;这是Map</span></span><br><span class="line">#&#123; 1 2 3 &#125; ;这是个Set</span><br></pre></td></tr></table></figure><p>扯句无关的，在最原始的Lisp中几乎只有圆括号，例如与之最相近的一种方言Common Lisp。</p><ul><li><h3 id="优先级取决于括号"><a href="#优先级取决于括号" class="headerlink" title="优先级取决于括号"></a><font color=#0099ff>优先级取决于括号</font></h3></li></ul><p>与其他语言一样，括号总伴随着表达式求值的优先级。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> (<span class="name"><span class="builtin-name">-</span></span> <span class="number">4</span> <span class="number">2</span>) (/ <span class="number">10</span> <span class="number">5</span>)) (<span class="name"><span class="builtin-name">-</span></span> <span class="number">1</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">4</span> <span class="number">5</span>)) <span class="number">2</span>) <span class="comment">;=5</span></span><br></pre></td></tr></table></figure><p>在Lisp语言中，我们通常很容易获知代码的优先级，正如代码本身就是一棵抽象语法树，能快速知道最先被求值的是哪个节点。代码自身等同于AST，我们称之为“同像性”。</p><p>正因Clojure的“同像性”，也为它自己带来其他语言没有的特性—可以自定义语法糖，即自定义宏。</p><ul><li><h3 id="括号外的一些符号—字面量"><a href="#括号外的一些符号—字面量" class="headerlink" title="括号外的一些符号—字面量"></a><font color=#0099ff>括号外的一些符号—字面量</font></h3></li></ul><p>要知道，Clojure是一种语法极其简易的语言，括号外也有一些能使代码简明易懂的符号，它们被叫做“字面量”。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;字符串字面量</span></span><br><span class="line"><span class="string">"i am string"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;数字字面量</span></span><br><span class="line"><span class="number">54321</span> <span class="comment">;十进制，clojure只有long和double类型</span></span><br><span class="line"><span class="number">10.1111333</span> <span class="comment">;double</span></span><br><span class="line">16rffa ;十六进制</span><br><span class="line">2r101 ;二进制</span><br><span class="line"></span><br><span class="line"><span class="comment">;其他基本类型</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">\c ;字符</span><br><span class="line"></span><br><span class="line"><span class="comment">;""前面加个#就是正则表达式</span></span><br><span class="line">(<span class="name">re-seq</span> #<span class="string">"\d*-\w+"</span> <span class="string">"omg123-string"</span>) <span class="comment">;=("123-string")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;关键字</span></span><br><span class="line"><span class="comment">;在Map数据结构中，关键字字面量是很有用的数据类型</span></span><br><span class="line"><span class="symbol">:keyname</span> <span class="comment">;=:keyname 代表自己</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;数据结构字面量</span></span><br><span class="line"><span class="comment">;map</span></span><br><span class="line">&#123;<span class="symbol">:key1</span> val1 <span class="symbol">:key2</span> val2&#125;</span><br><span class="line"><span class="comment">;list</span></span><br><span class="line">'(1 3 4 5 :keyname "item")</span><br><span class="line"><span class="comment">;vector</span></span><br><span class="line">[<span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="symbol">:keyname</span> <span class="string">"item"</span>]</span><br><span class="line"><span class="comment">;set</span></span><br><span class="line">#&#123;1 2 3&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">;与表达式、函数相关的字面量</span></span><br><span class="line"><span class="comment">;clojure有个叫quote的东西，它被用来阻止表达式求值，其字面量为'</span></span><br><span class="line"><span class="comment">;可理解为只是个简单声明一个list，这与上面说到的同像性有关</span></span><br><span class="line">'(+ 1 3) ;=(+ 1 3) ;变成了一个list，其中+等同于另外两个元素，被作为一个值塞进list中</span><br><span class="line"></span><br><span class="line"><span class="comment">;函数的字面量 #</span></span><br><span class="line">#(+ %1 %2) ;代表了一个匿名函数</span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> my_add #(<span class="name"><span class="builtin-name">+</span></span> %<span class="number">1</span> %<span class="number">2</span>)) <span class="comment">;将匿名函数赋值给my_add</span></span><br><span class="line">(<span class="name">my_add</span> <span class="number">1</span> <span class="number">3</span>) <span class="comment">;=4</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="代码块以及值的作用域"><a href="#代码块以及值的作用域" class="headerlink" title="代码块以及值的作用域"></a><font color=#0099ff>代码块以及值的作用域</font></h3></li></ul><p>每个函数调用都有圆括号包裹起开，执行多条语句同样需要一个圆括号。一个括号里的多条语句，叫做代码块。<br>clojure用宏<code>do</code>来依次执行代码块中的语句，且以最后的语句的结果作为返回值。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">do</span></span></span><br><span class="line">  (<span class="name">println</span> <span class="string">"1 + 2"</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>在fn、defn、let、loop、try等语义中，已经隐式使用了do，所以并不需要显示声明调用do。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> no_do []</span><br><span class="line">  ((<span class="name">println</span> <span class="string">"1 + 2"</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> <span class="number">2</span> <span class="number">4</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p>与代码块息息相关的还有值的作用域，上面用def定义的值，都可在其命名空间全局访问。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">ns</span></span> i_am_namespace)</span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> x_in_i_am_namespace) <span class="comment">;=#'i_am_namespace/x_in_i_am_namespace</span></span><br></pre></td></tr></table></figure><p>有时我们需要局部域的值，clojure为我们提供let，叫做本地绑定。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> z <span class="string">"def_z"</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [x (<span class="name"><span class="builtin-name">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span><br><span class="line">      y (<span class="name"><span class="builtin-name">vector</span></span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span>)]</span><br><span class="line">  (<span class="name"><span class="builtin-name">do</span></span></span><br><span class="line">    <span class="comment">;do something</span></span><br><span class="line">    (<span class="name">println</span> z)</span><br><span class="line">    (<span class="name"><span class="builtin-name">conj</span></span> x z)))</span><br><span class="line"></span><br><span class="line">(<span class="name">println</span> z)<span class="comment">;=def_z</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;报错，x只在定义它的let内有效</span></span><br><span class="line">(<span class="name">println</span> x)<span class="comment">;=CompilerException java.lang.RuntimeException: Unable to resolve symbol: x in this context</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="入参也可以很方便—let参数的解构"><a href="#入参也可以很方便—let参数的解构" class="headerlink" title="入参也可以很方便—let参数的解构"></a><font color=#0099ff>入参也可以很方便—let参数的解构</font></h3></li></ul><p>clojure有两类重要的数据结构list和map，参数很多时候也需要接受这种数据结构。</p><p>有时我们需要若干参数整合或求值。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;如果只是打印出1+2等式出来，也许我们会这样写</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [x <span class="number">1</span></span><br><span class="line">      y <span class="number">2</span></span><br><span class="line">      r <span class="string">"1 + 2 ="</span>]</span><br><span class="line">      (<span class="name">println</span> r (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;显然一个个去赋值，看起来很蠢，也不方便，clojure允许这样写。</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [[x y r] '(<span class="number">1</span> <span class="number">2</span> <span class="string">"1 + 2 ="</span>)]</span><br><span class="line">  (<span class="name">println</span> r (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;倘若我们只需要计算一个长列表中的几项元素，可以这样写</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [[x y z r] '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="string">"i am string"</span> <span class="number">4</span> <span class="number">5</span>)]</span><br><span class="line">  (<span class="name">println</span> r)</span><br><span class="line">  (<span class="name">println</span> (<span class="name"><span class="builtin-name">+</span></span> x y z)))</span><br><span class="line"><span class="comment">;或者</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [[a b c _ d e] '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="string">"i am string"</span> <span class="number">4</span> <span class="number">5</span>)]</span><br><span class="line">  (<span class="name">println</span> (<span class="name"><span class="builtin-name">+</span></span> a b c d e)))</span><br></pre></td></tr></table></figure><p>这种对列表或向量解构，叫做顺序解构。</p><p>还有一种，叫做map解构。顾名思义，是对map进行解构。</p><p>让我们先定义个比较复杂的map，一名员工的家庭地址和单位地址。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> person &#123;</span><br><span class="line">             <span class="symbol">:name</span> <span class="string">"Mark Volkmann"</span></span><br><span class="line">             <span class="symbol">:address</span> &#123;</span><br><span class="line">                       <span class="symbol">:street</span> <span class="string">"644 Glen Summit"</span></span><br><span class="line">                       <span class="symbol">:city</span> <span class="string">"St. Charles"</span></span><br><span class="line">                       <span class="symbol">:state</span> <span class="string">"Missouri"</span></span><br><span class="line">                       <span class="symbol">:zip</span> <span class="number">63304</span>&#125;</span><br><span class="line">             <span class="symbol">:employer</span> &#123;</span><br><span class="line">                        <span class="symbol">:name</span> <span class="string">"Object Computing, Inc."</span></span><br><span class="line">                        <span class="symbol">:address</span> &#123;</span><br><span class="line">                                  <span class="symbol">:street</span> <span class="string">"12140 Woodcrest Executive Drive, Suite 250"</span></span><br><span class="line">                                  <span class="symbol">:city</span> <span class="string">"Creve Coeur"</span></span><br><span class="line">                                  <span class="symbol">:state</span> <span class="string">"Missouri"</span></span><br><span class="line">                                  <span class="symbol">:zip</span> <span class="number">63141</span>&#125;&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">;根据一个已知的map结构，我们打印这个叫Mark的哥们在哪里工作。</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [&#123;name <span class="symbol">:name</span></span><br><span class="line">       &#123;emp_name <span class="symbol">:name</span>&#125; <span class="symbol">:employer</span></span><br><span class="line">       &#123;&#123;emp_street <span class="symbol">:street</span>&#125; <span class="symbol">:address</span>&#125; <span class="symbol">:employer</span>&#125; person]</span><br><span class="line">    (<span class="name">println</span> name <span class="string">"work in"</span> emp_name))</span><br><span class="line"><span class="comment">;这种结构方式有个相当不错的用处，当你确定一个json模型时，可以方便地对其进行处理计算。</span></span><br><span class="line"><span class="comment">;当然，也有难以预料的时候，也许模型中某个值缺失了，let的结构又能帮你设置默认值。</span></span><br><span class="line"><span class="comment">;:or可以帮你为不确定的健值设置默认值，它负责判断该健是否存在、值是否为nil</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [&#123;name <span class="symbol">:name</span></span><br><span class="line">       phone <span class="symbol">:phone</span></span><br><span class="line">       &#123;emp_name <span class="symbol">:name</span>&#125; <span class="symbol">:employer</span></span><br><span class="line">       &#123;&#123;emp_street <span class="symbol">:street</span>&#125; <span class="symbol">:address</span>&#125; <span class="symbol">:employer</span></span><br><span class="line">      <span class="symbol">:or</span> &#123;phone <span class="string">"13700000000"</span>&#125;&#125; person]</span><br><span class="line">    (<span class="name">println</span> name <span class="string">"work in"</span> emp_name <span class="string">"\nThe phone:"</span> phone))</span><br></pre></td></tr></table></figure><p>这里只说到let的结构，还有函数参数的结构，于此大同小异，等专门说到函数定义再聊。</p>]]></content>
      
      
      <categories>
          
          <category> 函数编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clojure </tag>
            
            <tag> 教程 </tag>
            
            <tag> 并发编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedIn的Parseq + ning.httpclient异步请求框架的使用</title>
      <link href="/2016/12/02/20161202-LinkedIn%E7%9A%84Parseq-ning-httpclient%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/12/02/20161202-LinkedIn%E7%9A%84Parseq-ning-httpclient%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Parseq是Linkedin的一个异步框架，目前来说是个封装的较好而且易用的异步框架。除了普通的数据处理外，还支持网络请求、消息队列等。</p><hr><h2 id="1-Maven配置"><a href="#1-Maven配置" class="headerlink" title="1. Maven配置"></a>1. Maven配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.linkedin.parseq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parseq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.linkedin.parseq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parseq-http-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-创建以及关闭线程池引擎Engine"><a href="#2-创建以及关闭线程池引擎Engine" class="headerlink" title="2. 创建以及关闭线程池引擎Engine"></a>2. 创建以及关闭线程池引擎Engine</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService taskService;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ScheduledExecutorService timerService;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Engine engine;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JsonMapper mapper = <span class="keyword">new</span> JsonMapper();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> numCores = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="comment">//可伸缩的线程池</span></span><br><span class="line">    taskService = <span class="keyword">new</span> ThreadPoolExecutor(numCores, numCores * <span class="number">2</span>, <span class="number">30</span>, TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">100</span>), <span class="keyword">new</span> CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    timerService = Executors.newScheduledThreadPool(numCores);</span><br><span class="line">    engine = <span class="keyword">new</span> EngineBuilder().setTaskExecutor(taskService).setTimerScheduler(timerService).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"shutdown engine"</span>);</span><br><span class="line">                engine.shutdown();</span><br><span class="line">                    engine.awaitTermination(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (taskService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"shutdown taskService"</span>);</span><br><span class="line">            taskService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timerService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"shutdown timerService"</span>);</span><br><span class="line">            timerService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-创建简单请求任务Task"><a href="#3-创建简单请求任务Task" class="headerlink" title="3. 创建简单请求任务Task"></a>3. 创建简单请求任务Task</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Post任务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> taskName</span></span><br><span class="line"><span class="comment"> *            任务名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment"> *            目标链接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> *            查询参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> headers</span></span><br><span class="line"><span class="comment"> *            报头</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> body</span></span><br><span class="line"><span class="comment"> *            报文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Task&lt;String&gt; <span class="title">createPostTask</span><span class="params">(String taskName, String url, List&lt;Param&gt; params, Map&lt;String, String&gt; headers, String body)</span> </span>&#123;</span><br><span class="line">                                    <span class="comment">//设置重试机制</span></span><br><span class="line">    Task&lt;String&gt; reusableTask = Task.withRetryPolicy(createRetryPolicy(), () -&gt; &#123;</span><br><span class="line">        <span class="comment">//final WrappedRequestBuilder builder = HttpClient.get(url); //Get请求</span></span><br><span class="line">        <span class="keyword">final</span> WrappedRequestBuilder builder = HttpClient.post(url);</span><br><span class="line">        <span class="keyword">if</span> (body != <span class="keyword">null</span>)</span><br><span class="line">            builder.setBody(body);</span><br><span class="line">        <span class="keyword">if</span> (headers != <span class="keyword">null</span>)</span><br><span class="line">            headers.entrySet().forEach(entry -&gt; builder.addHeader(entry.getKey(), entry.getValue()));</span><br><span class="line">        <span class="keyword">if</span> (params != <span class="keyword">null</span>)</span><br><span class="line">            builder.addQueryParams(params);</span><br><span class="line">        <span class="keyword">return</span> builder.task().map(taskName, Response::getResponseBody)</span><br><span class="line">                <span class="comment">//超时会抛出java.util.concurrent.TimeoutException</span></span><br><span class="line">                .withTimeout(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//错误处理，出现异常错误，则默认输出</span></span><br><span class="line">    .recover(e -&gt; <span class="string">"&#123;\"success:\":false&#125;"</span>);</span><br><span class="line">    <span class="keyword">return</span> reusableTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-合并简单任务，以及任务结果处理"><a href="#4-合并简单任务，以及任务结果处理" class="headerlink" title="4.合并简单任务，以及任务结果处理"></a>4.合并简单任务，以及任务结果处理</h2><p>回调接口，用以合并处理请求结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskResultHandler</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//SpringMvc异步请求</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(DeferredResult&lt;GwResult&gt; deferredResult, String result)</span> </span>&#123;</span><br><span class="line">        deferredResult.setResult(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数式接口注释</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskResultHandler1</span> <span class="keyword">extends</span> <span class="title">TaskResultHandler</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">handle</span><span class="params">(String result)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskResultHandler2</span> <span class="keyword">extends</span> <span class="title">TaskResultHandler</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">handle</span><span class="params">(String result1, String result2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..................n个TaskResultHandler.................</span></span><br></pre></td></tr></table></figure><p>任务的合并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并任务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> taskName</span></span><br><span class="line"><span class="comment"> *            任务名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment"> *            任务结果处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Task&lt;String&gt; <span class="title">merge</span><span class="params">(String taskName, Task&lt;String&gt; task1, Task&lt;String&gt; task2, TaskResultHandler2 handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Task.par(task1, task2)</span><br><span class="line">        <span class="comment">//合并处理两个任务结果</span></span><br><span class="line">        .map(taskName, (result1, result2) -&gt; handler.handle(result1, result2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Task&lt;String&gt; <span class="title">merge</span><span class="params">(String taskName, Task&lt;String&gt; task1, Task&lt;String&gt; task2, Task&lt;String&gt; task3,</span></span></span><br><span class="line"><span class="function"><span class="params">TaskResultHandler3 handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Task.par(task1, task2, task3)</span><br><span class="line">         <span class="comment">//合并处理三个任务结果</span></span><br><span class="line">        .map(taskName,(result1, result2, result3) -&gt; handler.handle(result1, result2, result3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..................n个merge方法.................</span></span><br></pre></td></tr></table></figure><p>任务开跑！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Task&lt;String&gt; task, TaskResultHandler1 handler, DeferredResult&lt;GwResult&gt; deferredResult)</span> </span>&#123;</span><br><span class="line">    engine.run(task.map(<span class="string">"runTask1"</span>, (result) -&gt; handler.handle(result))</span><br><span class="line">            .andThen(result -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (deferredResult != <span class="keyword">null</span>)</span><br><span class="line">                    handler.setResult(deferredResult, result);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    log.info(result);</span><br><span class="line">             &#125;).recover(e -&gt; &#123;</span><br><span class="line">                    <span class="comment">//输出系统错误结果</span></span><br><span class="line">                    deferredResult.setResult(gwResult);</span><br><span class="line">                    <span class="keyword">return</span> mapper.toJson(gwResult);</span><br><span class="line">            &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Task&lt;String&gt; task1, Task&lt;String&gt; task2, TaskResultHandler2 handler,</span></span></span><br><span class="line"><span class="function"><span class="params">DeferredResult&lt;GwResult&gt; deferredResult)</span> </span>&#123;</span><br><span class="line">    Task&lt;String&gt; tasks = merge(<span class="string">"runTask2"</span>, task1, task2, handler)</span><br><span class="line">        <span class="comment">//setResultElsePrintLog与上面的方法相同</span></span><br><span class="line">        .andThen(setResultElsePrintLog(handler, deferredResult))</span><br><span class="line">        <span class="comment">////recoverHandle与上面的方法相同</span></span><br><span class="line">        .recover(recoverHandle(deferredResult));</span><br><span class="line">    engine.run(tasks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..................n个run方法.................</span></span><br></pre></td></tr></table></figure><h2 id="5-异常处理以及重试机制"><a href="#5-异常处理以及重试机制" class="headerlink" title="5.异常处理以及重试机制"></a>5.异常处理以及重试机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RetryPolicy <span class="title">createRetryPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RetryPolicyBuilder().setTerminationPolicy(TerminationPolicy.limitAttempts(<span class="number">3</span>))</span><br><span class="line">        <span class="comment">// .setErrorClassifier(null)</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开源框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 异步框架 </tag>
            
            <tag> parseq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Java集合框架-来看看LinkedHashMap是啥!</title>
      <link href="/2016/10/03/20161003-%E6%B5%85%E8%B0%88Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E6%9D%A5%E7%9C%8B%E7%9C%8BLinkHashMap%E6%98%AF%E5%95%A5/"/>
      <url>/2016/10/03/20161003-%E6%B5%85%E8%B0%88Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E6%9D%A5%E7%9C%8B%E7%9C%8BLinkHashMap%E6%98%AF%E5%95%A5/</url>
      
        <content type="html"><![CDATA[<p>跳槽后，就没怎么看jdk，趁着十一看回点集合框架。我们知道HashMap是无序的，jdk也给我们提供了算是有序的HashMap，即LinkedHashMap。然而它只保留了操作的相对有序，而非TreeMap的Key自然有序。</p><hr><p>LinkedHashMap显然继承了HashMap的绝大部分特性，新Entry则添加了<code>before</code>和<code>after</code>两个指针，以及维护Entry链表的方法。需要说明的是，HashMap.Entry的单链表无关，那只是用于解决hash冲突而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LinkedHashMap entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//提供了双链表的指针</span></span><br><span class="line">  Entry&lt;K,V&gt; before, after;</span><br><span class="line"></span><br><span class="line">  Entry(<span class="keyword">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除元素，改变头尾指针</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      before.after = after;</span><br><span class="line">      after.before = before;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//链表头追加元素</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</span><br><span class="line">      after  = existingEntry;</span><br><span class="line">      before = existingEntry.before;</span><br><span class="line">      before.after = <span class="keyword">this</span>;</span><br><span class="line">      after.before = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 记录访问，即使将最新一次访问放在链表头部</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">      LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">      <span class="comment">//构造方法能够设置该值</span></span><br><span class="line">      <span class="keyword">if</span> (lm.accessOrder) &#123;</span><br><span class="line">          lm.modCount++;</span><br><span class="line">          remove();</span><br><span class="line">          addBefore(lm.header);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">      remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写了get方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</span><br><span class="line">  <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//访问记录</span></span><br><span class="line">  e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.addEntry(hash, key, value, bucketIndex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//移除最近且使用次数最少的元素</span></span><br><span class="line">  Entry&lt;K,V&gt; eldest = header.after;</span><br><span class="line">  <span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;</span><br><span class="line">      removeEntryForKey(eldest.key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多了将Entry添加到双链表头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">  HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">  Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, old);</span><br><span class="line">  table[bucketIndex] = e;</span><br><span class="line">  <span class="comment">//在此</span></span><br><span class="line">  e.addBefore(header);</span><br><span class="line">  size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写该方法，可以实现lru，可以参考ehcache的SpoolingLinkedHashMap</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断value是否存在显然方便好多，直接遍历双链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value==<span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Entry e = header.after; e != header; e = e.after)</span><br><span class="line">          <span class="keyword">if</span> (e.value==<span class="keyword">null</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (Entry e = header.after; e != header; e = e.after)</span><br><span class="line">          <span class="keyword">if</span> (value.equals(e.value))</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 集合框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> LinkedHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux－awk编程</title>
      <link href="/2016/07/28/20160728-Linux%EF%BC%8Dawk%E7%BC%96%E7%A8%8B/"/>
      <url>/2016/07/28/20160728-Linux%EF%BC%8Dawk%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>awk是个刁到不行的文本处理命令，查看生产环境日志时，简直就是神操！<br>新增：awk的数组</p><hr><ul><li><h3 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h3></li></ul><p>基本格式就这两种</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk -F<span class="string">'&lt;默认是空格，这里可正则表达式也可字符&gt;'</span> <span class="string">'commands'</span> file(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以用管道，</span></span><br><span class="line">ll -t | awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span></span><br></pre></td></tr></table></figure><p>通常awk做文本处理前还需要做一次过滤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">awk -F<span class="string">':'</span> <span class="string">'/&lt;正则表达式or普通字符串&gt;/&#123;print $1&#125;'</span> /ect/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如，我先用SQL为关键字做一次过滤</span></span><br><span class="line">awk -F<span class="string">':'</span> <span class="string">'/SQL/&#123;print $1, $5&#125;'</span> /etc/passwd</span><br><span class="line"><span class="comment">#_mysql MySQL Server</span></span><br><span class="line"><span class="comment">#_postgres PostgreSQL Server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在匹配有zF字符的文本</span></span><br><span class="line">awk -F<span class="string">':'</span> <span class="string">'/[zF]/&#123;print $1, $5&#125;'</span> /etc/passwd</span><br><span class="line"><span class="comment">#_ftp FTP Daemon</span></span><br><span class="line"><span class="comment">#_timezone AutoTimeZoneDaemon</span></span><br><span class="line"><span class="comment">#_krbfast Kerberos FAST Account</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="awk编程"><a href="#awk编程" class="headerlink" title="awk编程"></a>awk编程</h3></li></ul><p>awk同样支持编程的形式来处理文本，以便在shell脚本中使用。</p><p>关于awk的BEGIN与END</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BEGIN后面的表达式，在awk扫描时运行，END后面的表达式在awk扫描后运行，例子在后面</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;commands预处理&#125; &#123;commands开始扫描&#125;; END&#123;commands扫描后&#125;'</span> file(s)</span><br></pre></td></tr></table></figure><p>awk也支持条件语句和循环语句，语法与C相近。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 条件语句</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">command</span>) &#123;</span><br><span class="line">  //commands</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">command</span>) &#123;</span><br><span class="line">  //commands</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  //commands</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环语句</span></span><br><span class="line"><span class="comment"># while、do/while、for、break、continue等关键字，都与C相同！</span></span><br><span class="line"><span class="keyword">for</span>(commands; commands; commands) &#123;</span><br><span class="line">  //commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">awk -F<span class="string">':'</span> <span class="string">'BEGIN&#123;</span></span><br><span class="line"><span class="string">  count = 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  name[count] = $1; count++;</span></span><br><span class="line"><span class="string">&#125;; END &#123;</span></span><br><span class="line"><span class="string">  for(i = 0; i &lt; NR; i++) &#123;</span></span><br><span class="line"><span class="string">    if(name[i] != "root")</span></span><br><span class="line"><span class="string">      print "编号", i, "名字", name[i];</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;'</span> /ect/passwd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awk </tag>
            
            <tag> linux </tag>
            
            <tag> 文本处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Java集合框架－比较HashMap与Hashtable</title>
      <link href="/2016/07/16/20160716-%E6%B5%85%E8%B0%88Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%8D%E6%AF%94%E8%BE%83HashMap%E4%B8%8EHashtable/"/>
      <url>/2016/07/16/20160716-%E6%B5%85%E8%B0%88Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%8D%E6%AF%94%E8%BE%83HashMap%E4%B8%8EHashtable/</url>
      
        <content type="html"><![CDATA[<p>Hashtable实际上就是一个线程安全的HashMap，不过它是个遗留下来的过气类，其性能也并比不少ConcurrentHashMap。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap默认长度是1&lt;&lt;4 aka 16</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//很明显，HashMap没有synchronized，并不线程安全。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure the value is not null</span></span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//HashMap的key允许一个null</span></span><br><span class="line">    <span class="comment">//HashMap源码：return putForNullKey(value);</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">  Entry tab[] = table;</span><br><span class="line">  <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">  <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">      V old = e.value;</span><br><span class="line">      e.value = value;</span><br><span class="line">      <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">    <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">    rehash();</span><br><span class="line">    tab = table;</span><br><span class="line">    hash = hash(key);</span><br><span class="line">    index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Creates the new entry.</span></span><br><span class="line">  Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">  tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">  count++;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//if (key == null)</span></span><br><span class="line">  <span class="comment">//  return getForNullKey();HashMap的key有null值</span></span><br><span class="line">  Entry tab[] = table;</span><br><span class="line">  <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">  <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 集合框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Hashtable </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Java集合框架－瞧瞧LinkedArray源码，查询效率为何如此低下？</title>
      <link href="/2016/06/28/20160628%EF%BC%8D%E6%B5%85%E8%B0%88Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%8D%E7%9E%A7%E7%9E%A7LinkedArray%E6%BA%90%E7%A0%81%EF%BC%8C%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E4%B8%BA%E4%BD%95%E5%A6%82%E6%AD%A4%E4%BD%8E%E4%B8%8B%EF%BC%9F/"/>
      <url>/2016/06/28/20160628%EF%BC%8D%E6%B5%85%E8%B0%88Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%8D%E7%9E%A7%E7%9E%A7LinkedArray%E6%BA%90%E7%A0%81%EF%BC%8C%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E4%B8%BA%E4%BD%95%E5%A6%82%E6%AD%A4%E4%BD%8E%E4%B8%8B%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>平时用惯ArrayList插入查询，无视性能而忽略了LinkedArray，今日也反省反省，研究了一下<br>LinkedArray和ArrayList源码。其实理解两者原理和区别并不难，都是简单数据结构的应用。</p><hr><h2 id="LinkedArray源码"><a href="#LinkedArray源码" class="headerlink" title="LinkedArray源码"></a>LinkedArray源码</h2><p>双链表的好处就是有前后指针，插入只需要更新指针指向，随机查询则需要遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  linkLast(e);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个很好理解了，往列表尾端添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//现最后一个元素</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">  <span class="comment">//即将添加的元素</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">//last指针向后移</span></span><br><span class="line">  last = newNode;</span><br><span class="line">  <span class="comment">//没有尾元素</span></span><br><span class="line">  <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">    first = newNode;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//原尾元素next指向新下一个元素</span></span><br><span class="line">    l.next = newNode;</span><br><span class="line">  size++;</span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//检查index是否越界，是则抛出运行时异常IndexOutOfBoundsException</span></span><br><span class="line">  checkPositionIndex(index);</span><br><span class="line">  <span class="comment">//同add(E element)</span></span><br><span class="line">  <span class="keyword">if</span> (index == size)</span><br><span class="line">    linkLast(element);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//succ元素的前任prev</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">  <span class="comment">//新元素成功插入succ与其前任prev中间</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">  <span class="comment">//于是succ的现任prev是新元素e</span></span><br><span class="line">  succ.prev = newNode;</span><br><span class="line">  <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">    first = newNode;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pred.next = newNode;</span><br><span class="line">  size++;</span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">  <span class="comment">//类似二分法遍历，没什么好说的，size &gt;&gt; 1 aka size/2</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    Node&lt;E&gt; x = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">      x = x.next;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;E&gt; x = last;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">      x = x.prev;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  checkElementIndex(index);</span><br><span class="line">  <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ArrayList源码"><a href="#ArrayList源码" class="headerlink" title="ArrayList源码"></a>ArrayList源码</h2><p>往数组末尾插入元素当然快，但随机插入可就不一定了，需要将子数组往后移且或扩容（LinkedArray不<br>需要扩容）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//主要功能是扩容</span></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//就是说，即使你在ArrayList(int initialCapacity)传小于10的值，elementData最小长度依然是10</span></span><br><span class="line">  <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容！！！</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//这是ArrayList插入操作性能差的罪魁祸首</span></span><br><span class="line">  System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">    size - index);</span><br><span class="line">  elementData[index] = element;</span><br><span class="line">  size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="稍微总结一下"><a href="#稍微总结一下" class="headerlink" title="稍微总结一下"></a>稍微总结一下</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList需要随机插入时，可以转为new LinkedList(new ArrayList());</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>();</span><br><span class="line">  addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedList需要随机查询时，可以转为new ArrayList(new LinkedList());</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">  elementData = c.toArray();</span><br><span class="line">  size = elementData.length;</span><br><span class="line">  <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">  <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 集合框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> LinkedArray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Java集合框架－看看HashMap源码，了解它是咋运作的?</title>
      <link href="/2016/06/28/20160628%EF%BC%8D%E6%B5%85%E8%B0%88Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%8D%E7%9C%8B%E7%9C%8BHashMap%E6%BA%90%E7%A0%81%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%AE%83%E6%98%AF%E5%92%8B%E8%BF%90%E4%BD%9C%E7%9A%84/"/>
      <url>/2016/06/28/20160628%EF%BC%8D%E6%B5%85%E8%B0%88Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%8D%E7%9C%8B%E7%9C%8BHashMap%E6%BA%90%E7%A0%81%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%AE%83%E6%98%AF%E5%92%8B%E8%BF%90%E4%BD%9C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>初探HashMap源码，显然要理解它的运作并不难，只要基本掌握哈希桶这种数据结构。本文只在源码上对<code>get(K key)</code>和<code>put(K key, V value)</code>进行解读，并了解HashMap的原理。我看的是jdk1.7的源码！</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">  threshold = initialCapacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在HashMap类中无用</span></span><br><span class="line">  init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化哈希槽</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//threshold只是作为标准值，下面求一个略大于标准值的容量</span></span><br><span class="line">  <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">  <span class="comment">//负载因子折算threshold</span></span><br><span class="line">  threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//注意Entry本身是链表结构（即桶），table只是桶的列表</span></span><br><span class="line">  table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">  <span class="comment">//初始化hashseed</span></span><br><span class="line">  initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert number &gt;= 0 : "number must be non-negative";</span></span><br><span class="line">  <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">    ? MAXIMUM_CAPACITY</span><br><span class="line">      <span class="comment">//number-1两倍，取最高位1的值</span></span><br><span class="line">      : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//key为null时，hash为0，即table[0]</span></span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">//该方法的代码段与下面一致，i＝0</span></span><br><span class="line">    <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">  <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">  <span class="comment">//计算下标</span></span><br><span class="line">  <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">  <span class="comment">//获取对于hash的桶，e!=null则下一个entry</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">    Object k;</span><br><span class="line">    <span class="comment">//比对key值，若key存在则体会value，并返回旧value</span></span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      e.value = value;</span><br><span class="line">      <span class="comment">//貌似毫无用处</span></span><br><span class="line">      e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//key值不存在则插入</span></span><br><span class="line">  addEntry(hash, key, value, i);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//entry数满标准值，且该槽点不为null。为什么这样判断？因为大于threshold，不代表bucket已经用完，size只是entry的数量</span></span><br><span class="line">  <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">    <span class="comment">//重设标准值，扩容</span></span><br><span class="line">    resize(<span class="number">2</span> * table.length);</span><br><span class="line">    <span class="comment">//重新计算hash</span></span><br><span class="line">    hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//重新计算下表</span></span><br><span class="line">    bucketIndex = indexFor(hash, table.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">  Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">  <span class="comment">//把新entry插入链表头</span></span><br><span class="line">  table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">  size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> getForNullKey();</span><br><span class="line">  Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//前面说过key为null时，hash为0</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> e.value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">  <span class="comment">//获取hash对应的bucket，遍历Entry</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">      Object k;</span><br><span class="line">      <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Entry[] oldTable = table;</span><br><span class="line">  <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">  <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">    threshold = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">  transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">  table = newTable;</span><br><span class="line">  threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 集合框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式－状态模式</title>
      <link href="/2016/05/20/20160520-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/05/20/20160520-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>现实生活中，操作某一固定事物，可能会触发不同状态，例如电灯的开关。代码中也用相类似的情况，调用某对象的同一方法或多个方法，会触发对象内部的某个状态，而这个状态会影响你下一步可能调用的方法。我们这一次就讲讲状态模式。</p><hr><ul><li><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3></li></ul><p>我们的上下文<code>Light</code>类有<code>click()</code>方法，可以通过该方法改变电灯的状态<code>State</code>类，分别由<code>On</code>类、<code>Off</code>类两种状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> State state;</span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Light</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.state = state;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//通常客户端代码并不会对此方法感兴趣，这只是为了触发下面click方法时，能随即改变状态</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.state = state;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//客户端代码感兴趣的方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchLight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   state.printAndChange(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//还可能有更复杂的形式</span></span><br><span class="line"> <span class="comment">//public void click1() &#123;state.printAndChange1(this);&#125;</span></span><br><span class="line"> <span class="comment">//上下文提供多个方法调用，同时也多可更多对状态间的变换。下面再举个例子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">printAndChange</span><span class="params">(Light context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">On</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAndChange</span><span class="params">(Light context)</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"灯关了！"</span>);</span><br><span class="line">   <span class="comment">//改变与之相反的状态</span></span><br><span class="line">   context.setState(<span class="keyword">new</span> Off());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Off</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAndChange</span><span class="params">(Light context)</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"灯开着呢！"</span>);</span><br><span class="line">   <span class="comment">//同上</span></span><br><span class="line">   context.setState(<span class="keyword">new</span> On());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatePattern</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   Light light = <span class="keyword">new</span> Light(<span class="keyword">new</span> Off());</span><br><span class="line">   light.switchLight();</span><br><span class="line">   light.switchLight();</span><br><span class="line">   light.switchLight();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来个稍微复杂一点的例子，假如电灯有两档亮度，那又如何？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> State state;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Light</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.state = state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.state = state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//下一档</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shiftNextGear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">state.forward(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//上一档</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shiftPrevGrear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">state.reverse(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Light context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(Light context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Off</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Light context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否已经关闭，若是则无法拨打上一档</span></span><br><span class="line"><span class="keyword">if</span>(context.getState() <span class="keyword">instanceof</span> Off) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(Light context)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"电灯一档亮度！"</span>);</span><br><span class="line">context.setState(<span class="keyword">new</span> FirGear());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirGear</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Light context)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"电灯关了！"</span>);</span><br><span class="line">context.setState(<span class="keyword">new</span> Off());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(Light context)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"电灯二档亮度！"</span>);</span><br><span class="line">context.setState(<span class="keyword">new</span> SecGear());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecGear</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Light context)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"电灯一档亮度！"</span>);</span><br><span class="line">context.setState(<span class="keyword">new</span> FirGear());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(Light context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否已经最高档，若是则无法拨打下一档</span></span><br><span class="line"><span class="keyword">if</span>(context.getState() <span class="keyword">instanceof</span> SecGear) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatePattern</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Light light = <span class="keyword">new</span> Light(<span class="keyword">new</span> Off());</span><br><span class="line">light.shiftNextGear();</span><br><span class="line">light.shiftNextGear();</span><br><span class="line">light.shiftPrevGrear();</span><br><span class="line">light.shiftPrevGrear();</span><br><span class="line">light.shiftPrevGrear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后打印出来的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">电灯一档亮度！</span><br><span class="line">电灯二档亮度！</span><br><span class="line">电灯一档亮度！</span><br><span class="line">电灯关了！</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException</span><br><span class="line">at Off.reverse(StatePattern.java:41)</span><br><span class="line">at Light.shiftPrevGrear(StatePattern.java:28)</span><br><span class="line">at StatePattern.main(StatePattern.java:9)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式－策略模式</title>
      <link href="/2016/05/19/20160519-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/05/19/20160519-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>前面聊过模版方法，在一个算法中某步骤有多套实现时，可以很有效替换算法步骤。那如果在一套代码中有多种策略呢？更换策略是否还要更改原有的代码？这次说说策略模式。</p><hr><ul><li><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3></li></ul><p>OK，我们现在有个<code>ChooseStrategy</code>类要完成某个功能，只需调用<code>execute()</code>即可，该功能有用到两种策略分别是<code>SimpleStrategy</code>、<code>SpecialStrategy</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChooseStrategy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Strategy strategy = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ChooseStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... code ...</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.strategy != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.strategy.fuck();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... code ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fuck</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"这是个简单的策略！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpecialStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"这是个特殊的策略！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对每种策略都了如指掌的情况下，我们能根据不同情况设置不同的策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPattern</span>  </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ChooseStrategy choose = <span class="keyword">new</span> ChooseStrategy(<span class="keyword">new</span> SimpleStrategy());</span><br><span class="line">    choose.execute();</span><br><span class="line">    choose.setStrategy(<span class="keyword">new</span> SpecialStrategy());</span><br><span class="line">    choose.execute();</span><br><span class="line">    choose.setStrategy(<span class="keyword">null</span>);</span><br><span class="line">    choose.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="JDK中的策略模式"><a href="#JDK中的策略模式" class="headerlink" title="JDK中的策略模式"></a>JDK中的策略模式</h3></li></ul><p><code>java.util.Collections</code>类的静态方法<code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>就是策略模式，实现<code>Comparator</code>接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">  Object[] a = list.toArray();</span><br><span class="line">  Arrays.sort(a, (Comparator)c);</span><br><span class="line">  ListIterator i = list.listIterator();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;a.length; j++) &#123;</span><br><span class="line">    i.next();</span><br><span class="line">    i.set(a[j]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>Comparator</code>接口，跟<a href="/2016/04/30/20160429-设计模式－模版方法/">模板方法</a>很相似，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Dick</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dick o1, Dick o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o2.getSize() - o1.getSize();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dick</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dick</span><span class="params">(String name, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.size = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.size = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Dick [name="</span> + name + <span class="string">", size="</span> + size + <span class="string">"cm]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestComparator</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Dick[] fuckers = &#123;<span class="keyword">new</span> Dick(<span class="string">"张三"</span>, <span class="number">17</span>),</span><br><span class="line"><span class="keyword">new</span> Dick(<span class="string">"李四"</span>, <span class="number">14</span>),</span><br><span class="line"><span class="keyword">new</span> Dick(<span class="string">"王五"</span>, <span class="number">29</span>),</span><br><span class="line"><span class="keyword">new</span> Dick(<span class="string">"老六"</span>, <span class="number">22</span>),</span><br><span class="line"><span class="keyword">new</span> Dick(<span class="string">"赵七"</span>, <span class="number">11</span>)&#125;;</span><br><span class="line">List&lt;Dick&gt; dicks = <span class="keyword">new</span> ArrayList&lt;Dick&gt;();</span><br><span class="line">Arrays.sort(fuckers);</span><br><span class="line"><span class="keyword">for</span>(Dick fucker : fuckers)</span><br><span class="line">dicks.add(fucker);</span><br><span class="line">Collections.sort(dicks, <span class="keyword">new</span> SizeComparator());</span><br><span class="line">    <span class="comment">// [Dick [name=王五, size=29cm], Dick [name=老六, size=22cm], Dick [name=张三, size=17cm], Dick [name=李四, size=14cm], Dick [name=赵七, size=11cm]]</span></span><br><span class="line">System.out.println(dicks);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式－职责链模式</title>
      <link href="/2016/05/15/20160515-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/05/15/20160515-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>我们总有请假的时候，每个单位可能制度都不一样，但都对请假时间长短有规定不同流程。例如0.5-1天假向经理报告，2-3天假向hr报告，3以上的假期需总经理或老板签字等等。既然有这种状况，程序也务必会遇到此类情况，要说的就是处理此类问题时可能用到的设计模式——职责链模式。</p><hr><ul><li><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3></li></ul><p>示例，当前我有个请假的请求发送至上司，≤5天由<code>SimpleRequestHandler</code>处理，反之，<code>SpecialRequestHandler</code>处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> day;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(String name, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.day = day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDay</span><span class="params">(<span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.day = day;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理器抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Handler successor;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Handler <span class="title">getSuccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.successor = successor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> String <span class="title">handle</span><span class="params">(Request request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简易请求处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleRequestHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加强健壮性，防止没有后续处理器而报空指针</span></span><br><span class="line"><span class="keyword">if</span>(request.getDay() &lt; <span class="number">5</span> &amp;&amp; getSuccessor() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getSuccessor().handle(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> request.getName() + <span class="string">"请≤5天假&gt;&gt;&gt;&gt;&gt;批准"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊请求处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialRequestHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> request.getName() + <span class="string">"请≥5天假&gt;&gt;&gt;&gt;&gt;批准"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainOfResponsibility</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TOM请≤5天假&gt;&gt;&gt;&gt;&gt;批准</span></span><br><span class="line">Request request = <span class="keyword">new</span> Request(<span class="string">"TOM"</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//TIM请≥5天假&gt;&gt;&gt;&gt;&gt;批准</span></span><br><span class="line">    Request request = <span class="keyword">new</span> Request(<span class="string">"TIM"</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">Handler handler = <span class="keyword">new</span> SimpleRequestHandler();</span><br><span class="line">handler.setSuccessor(<span class="keyword">new</span> SpecialRequestHandler());</span><br><span class="line">System.out.println(handler.handle(request));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有上面main方法的三句代码可见的，对于每个请求来说，只需要面对一个处理器即可，大大的降低请求与处理的耦合。除此之外，也能让每个处理器有机会处理请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Handler handler = <span class="keyword">new</span> SimpleRequestHandler();</span><br><span class="line">handler.setSuccessor(<span class="keyword">new</span> SpecialRequestHandler());</span><br><span class="line">handler.handle(<span class="keyword">new</span> Request(<span class="string">"TOM"</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><ul><li><h3 id="JDK中的职责链模式"><a href="#JDK中的职责链模式" class="headerlink" title="JDK中的职责链模式"></a>JDK中的职责链模式</h3></li></ul><h1 id="doFilter没能完全看懂，看懂了再来补偿"><a href="#doFilter没能完全看懂，看懂了再来补偿" class="headerlink" title="doFilter没能完全看懂，看懂了再来补偿"></a>doFilter没能完全看懂，看懂了再来补偿</h1>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式－观察者模式</title>
      <link href="/2016/05/12/20160512-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/05/12/20160512-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>业务总会有环环相扣的联动，一环变化会引发后续环的变动。一个对象的变化，可能会引发一个或多个对象的变化，今天我就要说的能引用此种场景的设计模式——观察者模式。</p><hr><ul><li><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3></li></ul><p>说实在话，观察者模式只是比较直观的手段——“注册—通知—注销”，响应某个对象变化的手段并不止如此。并且，我对该模式的某个小细节一直存在疑惑，下面会说到。</p><p>先给出一个模版。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主题消息实体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubjectEntity</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String code;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String observerName;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SubjectEntity</span><span class="params">(String code, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.code = code;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.code = code;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getObserverName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> observerName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObserverName</span><span class="params">(String observerName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.observerName = observerName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"SubjectEntity [code="</span> + code + <span class="string">", name="</span> + name + <span class="string">", observerName="</span> + observerName + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被观察者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">observers.add(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">observers.remove(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">(SubjectEntity entity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(Observer observer : observers) &#123;</span><br><span class="line">observer.update(entity);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(SubjectEntity entity)</span> </span>&#123;</span><br><span class="line">entity.setName(<span class="string">"fuck dick!!!"</span>);</span><br><span class="line">notifyObserver(entity);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//观察者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(SubjectEntity entity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(SubjectEntity entity)</span> </span>&#123;</span><br><span class="line">System.out.println(entity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里把<code>SubjectEntity</code>类作为消息的全部，最后也是把该对象传递到<code>notifyObserver(SubjectEntity entity)</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPattern</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SimpleSubject subject = <span class="keyword">new</span> SimpleSubject();</span><br><span class="line">subject.addObserver(<span class="keyword">new</span> SimpleObserver());</span><br><span class="line">subject.addObserver(<span class="keyword">new</span> SimpleObserver());</span><br><span class="line">subject.action(<span class="keyword">new</span> SubjectEntity(<span class="string">"001"</span>, <span class="string">"001"</span>));</span><br><span class="line">subject.action(<span class="keyword">new</span> SubjectEntity(<span class="string">"002"</span>, <span class="string">"001"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="我的疑惑"><a href="#我的疑惑" class="headerlink" title="我的疑惑"></a>我的疑惑</h3></li></ul><p>假设我传递消息是被观察者本身的话，又如何？即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Subject subject)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Subject</code>类的通知方法当然要更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(Observer observer : observers) &#123;</span><br><span class="line">observer.update(subject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是乎，当我们实现<code>update(Subject subject)</code>时，就有可能出现这种情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">subject.notifyObserver(subject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👿👿👿👿👿这让我情何以堪？？？？</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC拦截器Interceptor</title>
      <link href="/2016/05/11/20160511-SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor/"/>
      <url>/2016/05/11/20160511-SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor/</url>
      
        <content type="html"><![CDATA[<p>SpringMVC拦截器是个非常好用的东西，对于每个请求有分别对进入控制器前、执行控制器后渲染之前、渲染之后的行为都能拦截。通常我们用拦截器实现了权限管理、MyBatis分页功能等。</p><hr><ul><li><h3 id="实现HandlerInterceptor接口"><a href="#实现HandlerInterceptor接口" class="headerlink" title="实现HandlerInterceptor接口"></a>实现<code>HandlerInterceptor</code>接口</h3></li></ul><p>拦截器一般直接实现<code>HandlerInterceptor</code>接口，Spring也只处理该类型的拦截器。有些文章说也可以选择继承<code>HandlerInterceptorAdapter</code>抽象类，此方式我强烈不建议，不仅因为该类并不是严格的拦截器接口，也浪费了继承位置，并且<code>afterConcurrentHandlingStarted</code>方法在其实并没有什么卵用，Spring完全调用不到该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FuckInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//进入控制器之前执行,若为false,不执行控制器.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//出控制器后,若有新页面并未渲染之前执行</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//整个请求结束之后</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===============================================================</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerInterceptorAdapter</span> <span class="keyword">implements</span> <span class="title">AsyncHandlerInterceptor</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncHandlerInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">afterConcurrentHandlingStarted</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="实现WebRequestInterceptor接口"><a href="#实现WebRequestInterceptor接口" class="headerlink" title="实现WebRequestInterceptor接口"></a>实现<code>WebRequestInterceptor</code>接口</h3></li></ul><p>其次还有实现<code>WebRequestInterceptor</code>接口的方式，为<code>WebRequest</code>已经封装<code>HttpServletRequest</code>的全部常用操作。但此类拦截器并不能让如上述拦截器一般，停止请求继续进行，所以通常只做请求的预备工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FuckInterceptor</span> <span class="keyword">implements</span> <span class="title">WebRequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//进入控制器之前执行.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preHandle</span><span class="params">(WebRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//出控制器后,若有新页面并未渲染之前执行</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(WebRequest request, ModelMap model)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//整个请求结束之后</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(WebRequest request, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebRequest</span> <span class="keyword">extends</span> <span class="title">RequestAttributes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getHeader</span><span class="params">(String headerName)</span></span>;</span><br><span class="line"></span><br><span class="line">String[] getHeaderValues(String headerName);</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator&lt;String&gt; <span class="title">getHeaderNames</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getParameter</span><span class="params">(String paramName)</span></span>;</span><br><span class="line"></span><br><span class="line">String[] getParameterValues(String paramName);</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator&lt;String&gt; <span class="title">getParameterNames</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">Map&lt;String, String[]&gt; getParameterMap();</span><br><span class="line"></span><br><span class="line"><span class="function">Locale <span class="title">getLocale</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getContextPath</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getRemoteUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Principal <span class="title">getUserPrincipal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isUserInRole</span><span class="params">(String role)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSecure</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkNotModified</span><span class="params">(<span class="keyword">long</span> lastModifiedTimestamp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkNotModified</span><span class="params">(String etag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkNotModified</span><span class="params">(String etag, <span class="keyword">long</span> lastModifiedTimestamp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getDescription</span><span class="params">(<span class="keyword">boolean</span> includeClientInfo)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h3></li></ul><p>引用标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlns:mvc="http://www.springframework.org/schema/mvc"</span><br><span class="line">xsi:schemaLocation="http://www.springframework.org/schema/mvc</span><br><span class="line">  http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span><br></pre></td></tr></table></figure><p>配置拦截器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用bean定义一个Interceptor，直接定义在mvc:interceptors根下面的Interceptor将拦截所有的请求 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/fuck/**"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义在mvc:interceptor下面的表示是对特定的请求才进行拦截的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.bayes.interceptor.WechatInterceptor"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式－组合模式</title>
      <link href="/2016/05/09/20160509-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/05/09/20160509-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>如何用一个对象表达一棵树？如何用一个对象遍历一棵树的所有节点？这是我们下面要讨论的一个设计模式——组合模式。该模式其实并不常见，也不常用，但需要解决树形的数据结构时，它是极佳的解决方法。</p><hr><ul><li><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3></li></ul><p>为末节点<code>Leaf</code>和非末节点即组件<code>Composite</code>声明接口<code>Component</code>。<br>注意到接口又添加删除方法，用来添加单个或多个零件所构的组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> String code;</span><br><span class="line"><span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Component</span><span class="params">(String code, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.code = code;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">printInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//末节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String code, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(code, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我是纯粹的零件，没有添加删除</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印零件信息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">printInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.code + <span class="string">":"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非末节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Composite</span><span class="params">(String code, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(code, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Component&gt; components = <span class="keyword">new</span> ArrayList&lt;Component&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//我是组件，必须添加删除</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">components.add(component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">components.remove(component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历零件信息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">printInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringBuffer info = <span class="keyword">new</span> StringBuffer(<span class="keyword">this</span>.code + <span class="string">":"</span> + <span class="keyword">this</span>.name).append(<span class="string">"--&gt;"</span>);</span><br><span class="line"><span class="keyword">for</span>(Component component : <span class="keyword">this</span>.components)</span><br><span class="line">info.append(component.printInfo()).append(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">return</span> info.substring(<span class="number">0</span>, info.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咱们可联想一下树形部门结构是咋样的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">总经理</span><br><span class="line">--- 人事部</span><br><span class="line">---A组</span><br><span class="line">--- 王五</span><br><span class="line">--- B司</span><br><span class="line">--- 研发部</span><br><span class="line">--- 产品A研发</span><br><span class="line">--- 张三</span><br><span class="line">--- 产品B研发</span><br><span class="line">--- 李四</span><br><span class="line">--- 市场部</span><br></pre></td></tr></table></figure><p>于是乎。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeTemplate</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Component general = <span class="keyword">new</span> Composite(<span class="string">"001"</span>, <span class="string">"总经理"</span>);</span><br><span class="line">Component hr = <span class="keyword">new</span> Composite(<span class="string">"101"</span>, <span class="string">"人事部"</span>);</span><br><span class="line">Component tech = <span class="keyword">new</span> Composite(<span class="string">"102"</span>, <span class="string">"研发部"</span>);</span><br><span class="line">Component market = <span class="keyword">new</span> Composite(<span class="string">"103"</span>, <span class="string">"市场部"</span>);</span><br><span class="line">Leaf leaf = <span class="keyword">new</span> Leaf(<span class="string">"10101"</span>, <span class="string">"张三"</span>);</span><br><span class="line">Leaf leaf2 = <span class="keyword">new</span> Leaf(<span class="string">"10202"</span>, <span class="string">"李四"</span>);</span><br><span class="line">Leaf leaf3 = <span class="keyword">new</span> Leaf(<span class="string">"10303"</span>, <span class="string">"王五"</span>);</span><br><span class="line">hr.add(leaf);</span><br><span class="line">tech.add(leaf2);</span><br><span class="line">market.add(leaf3);</span><br><span class="line">general.add(hr);</span><br><span class="line">general.add(tech);</span><br><span class="line">general.add(market);</span><br><span class="line"><span class="comment">// 001:总经理:&#123;101:人事部:&#123;10101:张三&#125;,102:研发部:&#123;10202:李四&#125;,103:市场部:&#123;10303:王五&#125;&#125;</span></span><br><span class="line">System.out.println(general.printInfo());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="JDK中的组合模式"><a href="#JDK中的组合模式" class="headerlink" title="JDK中的组合模式"></a>JDK中的组合模式</h3></li></ul><p>JDK中的<code>java.util.ArrayList</code>类中有<code>addAll</code>、<code>removeAll</code>就有组合模式的效果，尽管最后表现出来的依然是一维数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">       ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">       System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">       size += numNew;</span><br><span class="line">       <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">       <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">               <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                   elementData[w++] = elementData[r];</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">           <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">           <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">               System.arraycopy(elementData, r,</span><br><span class="line">                                elementData, w,</span><br><span class="line">                                size - r);</span><br><span class="line">               w += size - r;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">               <span class="comment">// clear to let GC do its work</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                   elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">               modCount += size - w;</span><br><span class="line">               size = w;</span><br><span class="line">               modified = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> modified;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式－适配器与装饰器的比较</title>
      <link href="/2016/05/08/20160508-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E9%80%82%E9%85%8D%E5%99%A8%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2016/05/08/20160508-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E9%80%82%E9%85%8D%E5%99%A8%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>前面已经说到了适配器和装饰器两种模式，两种怎么看都一样的，其实它们龙凤双胞胎。</p><hr><ul><li><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3></li></ul><p>咱们先来看看适配器模式的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">(Map&lt;String, String&gt; boby)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(Map&lt;String, String&gt; boby)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, String&gt; entry : boby.entrySet()) &#123;</span><br><span class="line">list.add(entry.getKey() + <span class="string">"-"</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">adaptee.simpleRequest((String[]) list.toArray());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被适配</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleRequest</span><span class="params">(String[] boby)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上诉代码，这只纯粹一个被适配者和适配器的关系，那假如被适配者又是另外一个被适配者的适配器呢？呵呵～～</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">(Map&lt;String, String&gt; boby)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配器一号</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Target2 adaptee;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Target2 adaptee)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(Map&lt;String, String&gt; boby)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, String&gt; entry : boby.entrySet()) &#123;</span><br><span class="line">list.add(entry.getKey() + <span class="string">"-"</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">adaptee.simpleRequest((String[]) list.toArray());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simpleRequest</span><span class="params">(String[] boby)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配器二号，又被适配器一号适配</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target2</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Adaptee2 adaptee2;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Adaptee</span><span class="params">(Adaptee2 adaptee2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.adaptee2 = adaptee2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleRequest</span><span class="params">(String[] boby)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被适配者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dickRequest</span><span class="params">(String[] boby)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterTemplate</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Target target = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee(<span class="keyword">new</span> Adaptee2()));</span><br><span class="line">target.request(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咱们来看，<code>Adaptee</code>适配<code>Adaptee2</code>的同时，也被<code>Adapter</code>所适配，最终在main方法中的代码呈现给我们的是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Target target = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee(<span class="keyword">new</span> Adaptee2()));</span><br></pre></td></tr></table></figure><ul><li><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3></li></ul><p>跟装饰器并没有什么两样。好吧，还是有区别的，让我们回头再看看装饰器怎样的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类（接口）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DecoratorTarget</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] bs)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorTargetSource</span> <span class="keyword">implements</span> <span class="title">DecoratorTarget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] bs)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源基类装饰器1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator1</span> <span class="keyword">implements</span> <span class="title">DecoratorTarget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> DecoratorTarget target;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Decorator1</span><span class="params">(DecoratorTarget target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] bs)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">target.read(bs);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源基类装饰器2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator2</span> <span class="keyword">implements</span> <span class="title">DecoratorTarget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> DecoratorTarget target;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Decorator2</span><span class="params">(DecoratorTarget target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] bs)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">target.read(bs);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源基类装饰器3</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator3</span> <span class="keyword">extends</span> <span class="title">Decorator1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Decorator3</span><span class="params">(DecoratorTarget target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(target);</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] bs)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">target.read(bs);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法中，是这样呈现的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DecoratorTarget target = <span class="keyword">new</span> Decorator1(<span class="keyword">new</span> Decorator3(<span class="keyword">new</span> Decorator2(<span class="keyword">new</span> DecoratorTargetSource())));</span><br></pre></td></tr></table></figure><p>OK！认真讨论一下装饰器的特点，装饰器与被装饰者通常是一个家族的，也就是它们派生于同个Object外的祖宗，包括源、装饰器本身。</p><ul><li><h3 id="为什么还要区分适配器与装饰器呢？"><a href="#为什么还要区分适配器与装饰器呢？" class="headerlink" title="为什么还要区分适配器与装饰器呢？"></a>为什么还要区分适配器与装饰器呢？</h3></li></ul><p>对比一下适配器，装饰器模式的<code>DecoratorTargetSource</code>几乎等同适配器模式的<code>Adaptee2</code>，它们的原理几乎是一样的，一个源头的接口需要修改或添加功能，则需要适配器或装饰器解决问题，不同的是不同适配器间往往没有血缘关系，而装饰器之间确实近亲关系甚至后代。</p><p>代码结构关系上，确实没什么必要区分开来，但它们的作用才能决定这一事情！<br>装饰器着重点在于，一个体系内的类的功能累加或修改，例如IO库。本来体系内的类已经有了很庞大复杂的继承关系，仅仅完善子类的功能而使用唯一的继承位置是浪费的，所以装饰器为体系的所有类提供了另一种继承方法，并且也为了类之间的相互适用。</p><p>适配器着重点在于，解决一个接口的不适用，也就是说它并不需要考虑继承体系内类的相互适用性，针对性强许多，倘若某个适配器确实还是需要一个适配器，你大可重写适配器（装饰器未必可以，你需要考虑体系其他类是否支持）。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式－装饰器模式</title>
      <link href="/2016/05/06/20160506-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/05/06/20160506-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>上一篇说到适配器模式，这次说它的同胞兄弟——装饰器模式。我们有时会遇到需要对类自身方法功能的累加，比如<code>FilterInputStream</code>需要<code>InputStream</code>其他子类的<code>read</code>上累加功能。</p><hr><ul><li><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3></li></ul><p>装饰器通常需要一个源，即你认为需要包装或基于此添加功能的类，源需要与装饰器同父类。</p><p>如下代码，源<code>DecoratorTargetSource</code>被实例化时并不需要传入任何<code>DecoratorTarget</code>类型，而<code>Decorator1</code>、<code>Decorator2</code>、<code>Decorator3</code>等装饰类实例化时需要<code>DecoratorTarget</code>类型对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类（接口）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DecoratorTarget</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] bs)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorTargetSource</span> <span class="keyword">implements</span> <span class="title">DecoratorTarget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] bs)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源基类装饰器1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator1</span> <span class="keyword">implements</span> <span class="title">DecoratorTarget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> DecoratorTarget target;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Decorator1</span><span class="params">(DecoratorTarget target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] bs)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">target.read(bs);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源基类装饰器2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator2</span> <span class="keyword">implements</span> <span class="title">DecoratorTarget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> DecoratorTarget target;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Decorator2</span><span class="params">(DecoratorTarget target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] bs)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">target.read(bs);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源基类装饰器3</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator3</span> <span class="keyword">extends</span> <span class="title">Decorator1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Decorator3</span><span class="params">(DecoratorTarget target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(target);</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] bs)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">target.read(bs);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorTemplate</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">DecoratorTarget target = <span class="keyword">new</span> Decorator1(<span class="keyword">new</span> Decorator3(<span class="keyword">new</span> Decorator2(<span class="keyword">new</span> DecoratorTargetSource())));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="JDK中的装饰器模式"><a href="#JDK中的装饰器模式" class="headerlink" title="JDK中的装饰器模式"></a>JDK中的装饰器模式</h3></li></ul><p>Java中最为人所知的装饰器模式，莫过于IO框架。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//装饰器FilterInputStream</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//装饰器BufferedInputStream，继承于FilterInputStream</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">getInIfOpen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">InputStream input = in;</span><br><span class="line"><span class="keyword">if</span> (input == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line"><span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">int</span> n = getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">            fill();</span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= count)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name != <span class="keyword">null</span> ? <span class="keyword">new</span> File(name) : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            security.checkRead(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (file.isInvalid()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"Invalid file path"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">        fd.incrementAndGetUseCount();</span><br><span class="line">        <span class="keyword">this</span>.path = name;</span><br><span class="line">        open(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(FileDescriptor fdObj)</span> </span>&#123;</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (fdObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            security.checkRead(fdObj);</span><br><span class="line">        &#125;</span><br><span class="line">        fd = fdObj;</span><br><span class="line">        path = <span class="keyword">null</span>;</span><br><span class="line">        fd.incrementAndGetUseCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述源码中，<code>FileInputStream</code>并没有参数包含<code>InputStream</code>类型，所以可以看成是一个源，那么<code>FilterInputStream</code>及其子类<code>BufferedInputStream</code>则是装饰器。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式－适配器模式</title>
      <link href="/2016/05/05/20160505-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/05/05/20160505-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>这次，我们来说说一个极其不常用到的模式——适配器模式。也并不是绝对极不常用，如果自个写框架之类的话，也许会变得很常用。怎么个常用法呢？在需要使用某个类时，其提供的接口并不是你所希望的，又或者说你还需处理接口返回的结果，你就可以用适配器模式解决此类问题。</p><hr><ul><li><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3></li></ul><p>当已存在的接口不满足需求时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">(Map&lt;String, String&gt; boby)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(Map&lt;String, String&gt; boby)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, String&gt; entry : boby.entrySet()) &#123;</span><br><span class="line">list.add(entry.getKey() + <span class="string">"-"</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">adaptee.simpleRequest((String[]) list.toArray());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被适配</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleRequest</span><span class="params">(String[] boby)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码可见，<code>Adaptee</code>的<code>simpleRequest(String[] boby)</code>并不满足<code>Map&lt;String, String&gt;</code>类型的参数，所以需要适配器<code>Adapter</code>的<code>request(Map&lt;String, String&gt; boby)</code>方法。<br>通常，我们并不会只针对某个子类做适配器，更多的是为一系列的子类(同一父类)做适配，例如上述代码<code>Adaptee</code>的子类们。</p><ul><li><h3 id="JDK中的适配器模式"><a href="#JDK中的适配器模式" class="headerlink" title="JDK中的适配器模式"></a>JDK中的适配器模式</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* File Descriptor - handle to the open file */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileDescriptor fd;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(FileDescriptor fdObj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        fd = fdObj;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name != <span class="keyword">null</span> ? <span class="keyword">new</span> File(name) : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">        fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            closed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Decrement the FD use count associated with the channel</span></span><br><span class="line"><span class="comment">             * The use count is incremented whenever a new channel</span></span><br><span class="line"><span class="comment">             * is obtained from this stream.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">           fd.decrementAndGetUseCount();</span><br><span class="line">           channel.close();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Decrement the FD use count associated with this stream</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> useCount = fd.decrementAndGetUseCount();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If FileDescriptor is still in use by another stream, the finalizer</span></span><br><span class="line"><span class="comment">         * will not close it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((useCount &lt;= <span class="number">0</span>) || !isRunningFinalize()) &#123;</span><br><span class="line">            close0();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.io.FileInputStream</code>已经是<code>FileDescriptor</code>的适配器，由三个构造方法可见，都需要传递或实例化<code>FileDescriptor</code>对象。</p><ul><li><h3 id="适配器模式与装饰器模式"><a href="#适配器模式与装饰器模式" class="headerlink" title="适配器模式与装饰器模式"></a>适配器模式与装饰器模式</h3></li></ul><p>适配器模式的类与类间的代码结构，跟装饰者模式是相似的，但有一点不一样的是，适配器与被适配者没有亲戚关系。装饰者模式会在下一篇讲到！</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式－桥接模式</title>
      <link href="/2016/05/03/20160503-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/05/03/20160503-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>   桥接模式在实际应用中，相比模板方法更为常见。在现实应用情况中，我们面对的是各种各样关系的维度，通过拼接不同维度能方便地实现不同功能，然而给我们的代码带来不少麻烦。一般地，我们面对关系复杂的维度，通常会使用树及林，其结果就是整片代码复杂的继承关系（有时也浪费了这个继承），桥接模式似乎能解决这个问题。</p><hr><ul><li><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3>惯例，不想画类图，直接上代码。</li></ul><p>我们如何用代码表述“一件某品牌的某商品”？<br>一般地，我们会如此表述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是一件商品！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifeGoods</span> <span class="keyword">extends</span> <span class="title">Goods</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是一件生活用品！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OfficialGoods</span> <span class="keyword">extends</span> <span class="title">Goods</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是一件办公用品！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brand1LifeGoods</span> <span class="keyword">extends</span> <span class="title">LifeGoods</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是一件品牌1产的生活用品！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brand2LifeGoods</span> <span class="keyword">extends</span> <span class="title">LifeGoods</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是一件品牌2产的生活用品！"</span>);</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brand1OfficialGoods</span> <span class="keyword">extends</span> <span class="title">OfficialGoods</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是一件品牌1产的办公用品！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brand2OfficialGoods</span> <span class="keyword">extends</span> <span class="title">OfficialGoods</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是一件品牌1产的办公用品！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yep!!!你没看错，就是这么恶心的继承关系，类图可以自己想象。<br>用桥接模式大概会成什么样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> Brand brand;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.brand = brand;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">brand.content();</span><br><span class="line">System.out.println(<span class="string">"商品！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifeGoods</span> <span class="keyword">extends</span> <span class="title">Goods</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">brand.content();</span><br><span class="line">System.out.println(<span class="string">"生活用品！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OfficialGoods</span> <span class="keyword">extends</span> <span class="title">Goods</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">brand.content();</span><br><span class="line">System.out.println(<span class="string">"办公用品！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ========================================= */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是一件"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brand1</span> <span class="keyword">extends</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是一件品牌1产的"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brand2</span> <span class="keyword">extends</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是一件品牌2产的"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>so？！用聚合！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bridge</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Goods goods = <span class="keyword">new</span> LifeGoods();</span><br><span class="line">goods.setBrand(<span class="keyword">new</span> Brand1());</span><br><span class="line">goods.content();</span><br><span class="line">goods.setBrand(<span class="keyword">new</span> Brand2());</span><br><span class="line">goods.content();</span><br><span class="line"></span><br><span class="line">goods = <span class="keyword">new</span> OfficialGoods();</span><br><span class="line">goods.setBrand(<span class="keyword">new</span> Brand2());</span><br><span class="line">goods.content();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>print &gt;&gt;&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是一件品牌1产的生活用品！</span><br><span class="line">这是一件品牌2产的生活用品！</span><br><span class="line">这是一件品牌2产的办公用品！</span><br></pre></td></tr></table></figure><p>显然桥接少了一堆的继承关系，客体之间更加清晰，降低了耦合。聚合后的<code>Bridge</code>类相比<code>Brand1LifeGoods</code>之类，前者留出了唯一的继承位置，可以让我们的<code>Bridge</code>做更多的事儿。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式－模板方法模式</title>
      <link href="/2016/04/30/20160429-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95/"/>
      <url>/2016/04/30/20160429-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8D%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>模板方法算是种较为常见的设计模式，同时对于大多数场景来说也很实用。在面临多算法交换更替使用的情况下，模板方法为你提供了各种算法的“开关”，提高算法的代码复用度。</p><hr><ul><li><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3></li></ul><p>不画类图了，直接上代码示例。</p><p>这是算法的模板抽象类，<code>process*()</code>是算法的每个步骤，<code>execute()</code>则是完整得执行算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PublicExecute</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"打印&gt;&gt;&gt;&gt;&gt;"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process3</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//执行算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">process2(process1());</span><br><span class="line">process3();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面有两个继承<code>PublicExecute</code>并实现其抽象方法的实现类，补充了算法的完整性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Execute1</span> <span class="keyword">extends</span> <span class="title">PublicExecute</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"完成&gt;&gt;&gt;&gt;&gt;Execute1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"打印&gt;&gt;&gt;&gt;&gt;"</span> + (i + <span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//算法2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Execute2</span> <span class="keyword">extends</span> <span class="title">PublicExecute</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"完成&gt;&gt;&gt;&gt;&gt;Execute2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码可见，<code>Execute1</code>实现了<code>process3()</code>，也同时重写<code>process2(int i)</code>；<code>Execute2</code>仅仅实现了<code>process3()</code>。</p><p>代码跑起！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我觉得模板方法应该不难看懂，说白了就是重写算法每个步骤的实现方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethod</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">PublicExecute execute1 = <span class="keyword">new</span> Execute1();</span><br><span class="line">PublicExecute execute2 = <span class="keyword">new</span> Execute2();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印&gt;&gt;&gt;&gt;&gt;100</span></span><br><span class="line"><span class="comment"> * 完成&gt;&gt;&gt;&gt;&gt;Execute1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">execute1.execute();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印&gt;&gt;&gt;&gt;&gt;0</span></span><br><span class="line"><span class="comment"> * 完成&gt;&gt;&gt;&gt;&gt;Execute2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//execute2.execute();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="JDK中的模板方法模式"><a href="#JDK中的模板方法模式" class="headerlink" title="JDK中的模板方法模式"></a>JDK中的模板方法模式</h3></li></ul><p>jdk可谓是设计模式之集大成，肯定少不了模板方法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arrays</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ComparableTimSort.sort(a);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** To be removed in a future release. */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">legacyMergeSort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">        Object[] aux = a.clone();</span><br><span class="line">        mergeSort(aux, a, <span class="number">0</span>, a.length, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Src is the source array that starts at index 0</span></span><br><span class="line"><span class="comment">     * Dest is the (possibly larger) array destination with a possible offset</span></span><br><span class="line"><span class="comment">     * low is the index in dest to start sorting</span></span><br><span class="line"><span class="comment">     * high is the end index in dest to end sorting</span></span><br><span class="line"><span class="comment">     * off is the offset to generate corresponding low, high in src</span></span><br><span class="line"><span class="comment">     * To be removed in a future release.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Object[] src,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Object[] dest,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> low,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> high,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> off)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Insertion sort on smallest arrays</span></span><br><span class="line">        <span class="keyword">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=low; i&lt;high; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;low &amp;&amp;</span><br><span class="line">                         ((Comparable) dest[j-<span class="number">1</span>]).compareTo(dest[j])&gt;<span class="number">0</span>; j--)</span><br><span class="line">                    swap(dest, j, j-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *略</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// If list is already sorted, just copy from src to dest.  This is an</span></span><br><span class="line">        <span class="comment">// optimization that results in faster sorts for nearly ordered lists.</span></span><br><span class="line">        <span class="keyword">if</span> (((Comparable)src[mid-<span class="number">1</span>]).compareTo(src[mid]) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.arraycopy(src, low, dest, destLow, length);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merge sorted halves (now in src) into dest</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=<span class="number">0</span>)</span><br><span class="line">                dest[i] = src[p++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dest[i] = src[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK中<code>java.util.Arrays</code>的<code>sort</code>方法就是典型的模版方法，而从私有方法<code>mergeSort</code>来看，为我们提供算法修改的方法则是<code>Object</code>的<code>compareTo</code>。</p><ul><li><h3 id="写个compareTo的例子"><a href="#写个compareTo的例子" class="headerlink" title="写个compareTo的例子"></a>写个<code>compareTo</code>的例子</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dick</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Dick</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dick</span><span class="params">(String name, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.size = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Dick [name="</span> + name + <span class="string">", size="</span> + size + <span class="string">"cm]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Comparable接口</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Dick o)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.size == o.getSize())</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.size &gt;= o.getSize())</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试、打印.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArraysSort</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Dick[] fuckers = &#123;<span class="keyword">new</span> Dick(<span class="string">"张三"</span>, <span class="number">17</span>),</span><br><span class="line"><span class="keyword">new</span> Dick(<span class="string">"李四"</span>, <span class="number">14</span>), </span><br><span class="line"><span class="keyword">new</span> Dick(<span class="string">"王五"</span>, <span class="number">29</span>), </span><br><span class="line"><span class="keyword">new</span> Dick(<span class="string">"老六"</span>, <span class="number">22</span>), </span><br><span class="line"><span class="keyword">new</span> Dick(<span class="string">"赵七"</span>, <span class="number">11</span>)&#125;;</span><br><span class="line">Arrays.sort(fuckers);</span><br><span class="line"><span class="keyword">for</span>(Dick fucker : fuckers)</span><br><span class="line">System.out.println(fucker);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dick [name&#x3D;赵七, size&#x3D;11cm]</span><br><span class="line">Dick [name&#x3D;李四, size&#x3D;14cm]</span><br><span class="line">Dick [name&#x3D;张三, size&#x3D;17cm]</span><br><span class="line">Dick [name&#x3D;老六, size&#x3D;22cm]</span><br><span class="line">Dick [name&#x3D;王五, size&#x3D;29cm]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无题小诗几首</title>
      <link href="/2016/04/29/20160429-%E5%B0%8F%E8%AF%97%E5%87%A0%E9%A6%96/"/>
      <url>/2016/04/29/20160429-%E5%B0%8F%E8%AF%97%E5%87%A0%E9%A6%96/</url>
      
        <content type="html"><![CDATA[<p>寅夜周遭化水音，<br>高山闻猴啼希心。<br>书中玉颜金屋在，<br>难及伊倾续人丁。</p><hr><p>墨针轻坠空谷径，<br>猿声不鸣唯泼猴。<br>周遭无烟闻足音，<br>数里幽兰迎哲心。</p><hr><p>寂听枯叶随风，寥闻冷夜微雨。<br>云散不见星辰，帘闭难掩孤灯。<br>人儿思甜入梦，影踪幻于无境。<br>独卧瞑望阳春，自为太乙归秋。</p><hr><p>明如夜里星辰，暗如日下人心。<br>醉于字里行间，迷于车马流川。<br>生在盛枝荫地，死在枯草荒土。</p><p>简直天差地别。</p><hr><p>清晨寒风未刺骨，<br>存储过程却凉透我心。</p><hr><p>墨云翻浪作白雨，无烟箐道闻弦声。<br>画中乐者清自闲，欲做竹丛屋中人。</p><p>墨雨无声。</p><hr><p>我的心死，只为你身体的真全。<br>我的泪干，只为你血液的流淌。<br>我的幻灭，只为你思想的实现。<br>我的下葬，只为你地上的长存。<br>我，只是另一个我的你。<br>生来老去，你我相依。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 小诗 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis+Spring整合</title>
      <link href="/2016/04/29/20160429-MyBatis-Spring%E6%95%B4%E5%90%88/"/>
      <url>/2016/04/29/20160429-MyBatis-Spring%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>MyBatis整合，PageHelper分页插件，Spring事物管理。</p><h4 id="MyBatis整合"><a href="#MyBatis整合" class="headerlink" title="MyBatis整合"></a>MyBatis整合</h4><p>在web.xml配置放jdbc.properties等配置文件的目录路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>PROP_HOME<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/Users/**/config<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在spring的spring-mvc.xml引入上面配的<code>PROP_HOME</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///$&#123;PROP_HOME&#125;/jdbc.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用c3p0配置连接池。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;mysql.url&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;mysql.username&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;mysql.password&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;mysql.driverClassName&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;mysql.maxPoolSize&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;mysql.minPoolSize&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;mysql.initialPoolSize&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdleTime"</span> <span class="attr">value</span>=<span class="string">"$&#123;mysql.maxIdleTime&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span> <span class="attr">value</span>=<span class="string">"$&#123;mysql.acquireIncrement&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span> <span class="attr">value</span>=<span class="string">"$&#123;mysql.maxStatements&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idleConnectionTestPeriod"</span> <span class="attr">value</span>=<span class="string">"$&#123;mysql.idleConnectionTestPeriod&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置MyBatis。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自动匹配Mapper映射文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath*:mappings/**/*apper.xml"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"com.bayes.entity"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"plugins"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.github.pagehelper.PageHelper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">dialect=mysql</span><br><span class="line">offsetAsPageNum=true</span><br><span class="line">rowBoundsWithCount=true</span><br><span class="line">pageSizeZero=true</span><br><span class="line">reasonable=false</span><br><span class="line">supportMethodsArguments=false</span><br><span class="line">returnPageInfo=always</span><br><span class="line">params=pageNum=pageHelperStart;pageSize=pageHelperRows;</span><br><span class="line"><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置MyBatis注解。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.bayes.mapper"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>jdbc.properties配置内容。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">mysql.url</span>=<span class="string">jdbc:mysql://*.*.*.*:3306/***?useUnicode:true&amp;characterEncoding:UTF-8&amp;allowMultiQueries:true&amp;noAccessToProcedureBodies=true</span></span><br><span class="line"><span class="meta">mysql.username</span>=<span class="string">***</span></span><br><span class="line"><span class="meta">mysql.password</span>=<span class="string">**#**</span></span><br><span class="line"><span class="meta">mysql.initialPoolSize</span>=<span class="string">20  </span></span><br><span class="line"><span class="meta">mysql.maxPoolSize</span>=<span class="string">100  </span></span><br><span class="line"><span class="meta">mysql.minPoolSize</span>=<span class="string">10  </span></span><br><span class="line"><span class="meta">mysql.maxIdleTime</span>=<span class="string">600  </span></span><br><span class="line"><span class="meta">mysql.acquireIncrement</span>=<span class="string">5  </span></span><br><span class="line"><span class="meta">mysql.maxStatements</span>=<span class="string">5  </span></span><br><span class="line"><span class="meta">mysql.idleConnectionTestPeriod</span>=<span class="string">60</span></span><br></pre></td></tr></table></figure><hr><h4 id="PageHelper分页插件集成Spring，以及使用"><a href="#PageHelper分页插件集成Spring，以及使用" class="headerlink" title="PageHelper分页插件集成Spring，以及使用"></a>PageHelper分页插件集成Spring，以及使用</h4><p>PageHelper集成配置已经在上述<code>配置MyBatis</code>给出。<br>官方github有详细文档，可参照。</p><hr><h4 id="配置Spring事物管理"><a href="#配置Spring事物管理" class="headerlink" title="配置Spring事物管理"></a>配置Spring事物管理</h4><p>配置Spring-jdbc事物。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>匹配符合规则的方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"bayesAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"save*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"del*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"apply*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"allAdviceServiceMethod"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.bayes.service.*.*(..))"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut-ref</span>=<span class="string">"allAdviceServiceMethod"</span> <span class="attr">advice-ref</span>=<span class="string">"bayesAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL5.6安装</title>
      <link href="/2016/04/29/20160429-MySQL5-6%E5%AE%89%E8%A3%85/"/>
      <url>/2016/04/29/20160429-MySQL5-6%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>只针对mysql5.6，其他版本mysql_install_db步骤可能有所不同.</p><h4 id="yum安装依赖包"><a href="#yum安装依赖包" class="headerlink" title="yum安装依赖包"></a>yum安装依赖包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yum install gcc-c++</span><br><span class="line">$ yum install cmake</span><br><span class="line">$ yum install make</span><br><span class="line">$ yum install bison.x86_64</span><br><span class="line">$ yum install ncurses-devel.x86_64</span><br></pre></td></tr></table></figure><h4 id="解压并编译mysql"><a href="#解压并编译mysql" class="headerlink" title="解压并编译mysql"></a>解压并编译mysql</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xzvf mysql.**.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql</span><br><span class="line">$ cmake .</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="常见用户组及用户"><a href="#常见用户组及用户" class="headerlink" title="常见用户组及用户"></a>常见用户组及用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ groupadd mysql</span><br><span class="line">$ useradd -r -g mysql mysql</span><br></pre></td></tr></table></figure><h4 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 777 scripts/mysql_install_db</span><br><span class="line">$ scripts/mysql_install_db --user=mysql --basedir=/usr/<span class="built_in">local</span>/mysql --datadir=/usr/<span class="built_in">local</span>/mysql/data</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL常见命令</title>
      <link href="/2016/04/29/20160429-MySQ%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
      <url>/2016/04/29/20160429-MySQ%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>一些常用的MySQL命令，个人工作中使用频率高的，既长又易忘。</p><hr><h4 id="创建数据库："><a href="#创建数据库：" class="headerlink" title="创建数据库："></a>创建数据库：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database if not exists &lt;db_name&gt; --- 数据库名称</span><br><span class="line">default charset utf8 --- 字符编码</span><br><span class="line">collate utf8_general_ci;--- 字符编码集</span><br></pre></td></tr></table></figure><hr><h4 id="修改root密码："><a href="#修改root密码：" class="headerlink" title="修改root密码："></a>修改root密码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set password for &#39;root&#39;@&#39;localhost&#39;&#x3D;password(&#39;newpass&#39;);</span><br><span class="line">mysql&gt; update user set password&#x3D;password(&#39;newpass&#39;) where user&#x3D;&#39;root&#39;</span><br></pre></td></tr></table></figure><hr><h4 id="用户权限："><a href="#用户权限：" class="headerlink" title="用户权限："></a>用户权限：</h4><p>添加并授权新用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant all on testDB.* to test@localhost identified by &#39;1234&#39;;</span><br><span class="line">mysql&gt; grant select,insert,update,delete,execute  </span><br><span class="line">on *.* to qmsys@&quot;localhost&quot; Identified by &quot;qmsys&quot;;</span><br></pre></td></tr></table></figure><p>刷新权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><p>查看权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show grants for &#39;&lt;user_name&gt;&#39;@&#39;%’;</span><br></pre></td></tr></table></figure><p>删除权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; REVOKE ALL PRIVILEGES ON *.* FROM &#39;&lt;user_name&gt;&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure><hr><h4 id="Event调度器："><a href="#Event调度器：" class="headerlink" title="Event调度器："></a>Event调度器：</h4><p>查看Event：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show events;</span><br><span class="line">mysql&gt; show create event &lt;name&gt;;</span><br></pre></td></tr></table></figure><p>开启Event：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL event_scheduler &#x3D; ON;</span><br></pre></td></tr></table></figure><p>或在my.cnf的[mysqld]下添加event_scheduler = ON</p><p>创建Event：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delimiter|</span><br><span class="line">CREATE DEFINER&#x3D;&#39;root&#39;;@&#39;%&#39; EVENT &#39;update_reform&#39;</span><br><span class="line">ON SCHEDULE EVERY 1 DAY STARTS TIMESTAMP(current_date(), &#39;00:30:00&#39;)</span><br><span class="line">ON COMPLETION PRESERVE ENABLE DO</span><br><span class="line">BEGIN</span><br><span class="line">&#x2F;*</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">END    </span><br><span class="line">|delimiter ;</span><br></pre></td></tr></table></figure><hr><h4 id="常见易忘函数："><a href="#常见易忘函数：" class="headerlink" title="常见易忘函数："></a>常见易忘函数：</h4><p>时间加减：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; date_add(tc.check_time, interval 3 month);</span><br></pre></td></tr></table></figure><p>day、hour、minute、second、microsecond、week、quarter、year</p><hr><h4 id="导出数据库："><a href="#导出数据库：" class="headerlink" title="导出数据库："></a>导出数据库：</h4><p>指定数据库全量导出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; mysqldump -u root --password&#x3D;&lt;password&gt; --events -R &lt;db_name&gt; &gt; &#x2F;root&#x2F;&lt;db_name&gt;.$(date &#39;+%Y%m%d&#39;).sql --lock-tables&#x3D;false</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于女权</title>
      <link href="/2016/04/27/20160427-%E5%85%B3%E4%BA%8E%E5%A5%B3%E6%9D%83/"/>
      <url>/2016/04/27/20160427-%E5%85%B3%E4%BA%8E%E5%A5%B3%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今经济发展，社会进步，人的观念也逐渐步入成熟的平和。然而宏观上步入平和，微观上可就不见得了，仍有不少观念的不平还是一如既往。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近有若干新闻是关于女性的，具体什么新闻在这不再提了，也没必要，千篇一律。新闻一发，立即被引出一片没完没了的“男女平等”、“女权主义”等关于女性的权利和社会地位的嚷嚷声。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今经济发展，社会进步，人的观念也逐渐步入成熟的平和。然而宏观上步入平和，微观上可就不见得了，仍有不少观念的不平还是一如既往。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近有若干新闻是关于女性的，具体什么新闻在这不再提了，也没必要，千篇一律。新闻一发，立即被引出一片没完没了的“男女平等”、“女权主义”等关于女性的权利和社会地位的嚷嚷声。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文明正在进步，社会对待女性也有了更多的尊重，继而有了礼让女性的“男士风度”、男士退让的“女士优先”等道德礼仪观念。“风度”和“优先”看起来似乎比“平等”、“女权”微观得多，同时也容易实践于生活当中。可两者间好像隔着什么东西？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;隔着矛盾！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“男士风度”是礼让于地位，“女士优先”是退让于机会，也就是说，女性需要“风度”来体现地位、“优先”来获得机会。既然宣传追求“平等”、“女权”，女性需要用“让”来获取地位或机会么？或者说，“平等”、“女权”二者同“让”并不该共存，甚至是对立的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使如此，我们可抛开“男女平等”、“女权主义”等安利人的字眼不讲，把“风度”和“优先”作为道德礼仪也并不成立，或者说不能作为一种要求，下面如果我们把道德与礼仪统一归为道德的话。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成之无罪，“万物都以永恒之泉水受礼，超于善恶之外，善恶不过是掠影，是阴翳，是流云。”这句话出自尼采的《查拉图斯特拉如是说》，意思是，万物生命本身无罪，且并不遵循道规律，立足于善恶之外。道德礼仪不是“自在之物”，“不存在凭自身成为道德的道德”，一切行为都是出自更深层的动机或需求，并非出于道德，道德只不过是对你某种行为的一种错解。简而言之，一个人对另一个人做出符合“道德”的行为，无非是出自动机而做；反之，不存在动机，就不存在道不道德的行为。回到前面说的“风度”、“优先”，我们业已把它们看作一种道德礼仪观念，自然符合上述：这么说，女性何必要求男性对她产生动机呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倘若道德礼仪是纯粹的，“风度”与“优先”也有悖于其出发点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二者的“让”，我们不妨看作同情的行为结果。每个人无论男女都是个体，都有成为强者的可能或意愿。我们视女性为同等，都渴望成为强者，都渴望获得地位、权利。此时，我们却因为女性的一时劣势，我们投以同情的眼光，这无疑给这些渴望变强的人儿的尊严一棍强击。是的，同情与自尊是对立的。那些成天把二者挂在嘴边的女性，只不过是些毫无尊严、只愿做男性依附品的奴性个体罢了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说了这么多，鄙夷了所谓“男士风度”、“女士优先”等虚伪观念，那究竟与现今所宣的“男女平等”、“女权主义”有何关？有！我觉得有关！拆楼重建总比危楼修补来得容易，颠覆腾空旧观念再宣新思想不是更好么？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;诚然，颠覆过去、思考现在、重估未来是当今社会问题最好的解决办法，可惜说起容易做来难。</p>]]></content>
      
      
      <categories>
          
          <category> 小文 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
