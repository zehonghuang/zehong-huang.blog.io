<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="哦：:"><title>asynchttpclient源码分析-基于Netty的连接池实现 | 作为客体的类库</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '0a5b9422135fcdf976ea589d63a28521';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><meta name="generator" content="Hexo 4.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">asynchttpclient源码分析-基于Netty的连接池实现</h1><a id="logo" href="/.">作为客体的类库</a><p class="description">JAVA与C/C++，专注中间件&amp;基础架构，欢迎技术交流，微信：hongframe</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">asynchttpclient源码分析-基于Netty的连接池实现</h1><div class="post-meta">Apr 3, 2017<span> | </span><span class="category"><a href="/categories/Netty/">Netty</a></span></div><div class="post-content"><p>最近项目重构，有了个机会更多接触一个有别于HttpAsyncClient的异步网络框架AsyncHttpClient，是个基于Netty的支持Http(s)或WebSocket协议的客户端。这东西有很多有趣的地方，特别是连接池的实现简单易懂，没有apache.hc的连接池实现那么蛋疼。如果想深入了解Netty用法的话，这是个不错的案例，很值得深究！</p>
<hr>
<p><strong>这里暂且仅关注连接池的实现，部分涉及Netty的channel输入输出处理、哈希轮定时器算法、事件轮询方式的区别，又或者信号量的使用等等，以后有机会会单独拿出来详解。</strong></p>
<p>由于是基Netty的实现的，所以连接池实际上就是对channel的管理控制，有趣的是整个管理只用到了信号量+一个定时检测器，略微复杂的也就定时检测的逻辑，其实现方式简单且很好理解，不像httpclient里各种队列各种信号量难以理解。</p>
<p>先上一个简单的例子，事实上使用起来也不复杂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AsyncHttpClient asyncHttpClient = Dsl</span><br><span class="line">            <span class="comment">//实例化所有池和检测器</span></span><br><span class="line">            .asyncHttpClient(</span><br><span class="line">                    Dsl.config()</span><br><span class="line">                    .setMaxConnections(<span class="number">500</span>)</span><br><span class="line">                    .setMaxConnectionsPerHost(<span class="number">50</span>)</span><br><span class="line">                    .setPooledConnectionIdleTimeout(<span class="number">6000</span>)</span><br><span class="line">                    .setConnectionTtl(<span class="number">500</span>)</span><br><span class="line">                    .setIoThreadsCount(<span class="number">100</span>)</span><br><span class="line">                    .setConnectTimeout(<span class="number">60000</span>)</span><br><span class="line">                    .setUseNativeTransport(</span><br><span class="line">                            System.getProperty(<span class="string">"os.name"</span>).toLowerCase().indexOf(<span class="string">"linux"</span>) &gt; <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Param&gt; params = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        params.add(<span class="keyword">new</span> Param(<span class="string">"keyfrom"</span>, <span class="string">"XXX"</span>));</span><br><span class="line"></span><br><span class="line">        asyncHttpClient</span><br><span class="line">                .prepareGet(<span class="string">"http://fanyi.youdao.com/openapi.do"</span>)</span><br><span class="line">                .addQueryParams(params)</span><br><span class="line">                <span class="comment">//这里进入发送请求阶段</span></span><br><span class="line">                .execute()</span><br><span class="line">                .toCompletableFuture()</span><br><span class="line">                <span class="comment">//超时报错，或请求异常，做容错处理，抛出一个Response</span></span><br><span class="line">                .exceptionally(t -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Response() &#123;...&#125;;</span><br><span class="line">                &#125;)</span><br><span class="line">                .thenAccept(rep -&gt; System.out.println(<span class="string">"RESPONSE BODY"</span> + rep.getResponseBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看看<code>DefaultAsyncHttpClientConfig</code>类的配置参数，这里只列出本文所需要的参数。有一点值得提一下，如果想了解Java怎么像clojure或者scala一样创建不可变对象，可以看看这个类的写法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeouts</span></span><br><span class="line"><span class="comment">//连接超时</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> connectTimeout;</span><br><span class="line"><span class="comment">//请求超时</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> requestTimeout;</span><br><span class="line"><span class="comment">//读取超时，含于请求时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> readTimeout;</span><br><span class="line"><span class="comment">//关闭Client前的静默时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> shutdownQuietPeriod;</span><br><span class="line"><span class="comment">//关闭超时</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> shutdownTimeout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// keep-alive</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> keepAlive;</span><br><span class="line"><span class="comment">//连接池空闲时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> pooledConnectionIdleTimeout;</span><br><span class="line"><span class="comment">//定时清理空闲连接的时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> connectionPoolCleanerPeriod;</span><br><span class="line"><span class="comment">//连接存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> connectionTtl;</span><br><span class="line"><span class="comment">//最大连接数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxConnections;</span><br><span class="line"><span class="comment">//每个路由的最大连接数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxConnectionsPerHost;</span><br><span class="line"><span class="comment">//用于channel超时处理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelPool channelPool;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> KeepAliveStrategy keepAliveStrategy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// internals</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String threadPoolName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> httpClientCodecMaxInitialLineLength;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> httpClientCodecMaxHeaderSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> httpClientCodecMaxChunkSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> chunkedFileChunkSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> webSocketMaxBufferSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> webSocketMaxFrameSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ChannelOption&lt;Object&gt;, Object&gt; channelOptions;</span><br><span class="line"><span class="comment">//时间轮询组类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup eventLoopGroup;</span><br><span class="line"><span class="comment">//是否用epoll，仅linux系统支持</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> useNativeTransport;</span><br><span class="line"><span class="comment">//用于Timeout处理，建议用默认Netty的HashedWheelTimer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Timer nettyTimer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AdditionalChannelInitializer httpAdditionalChannelInitializer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AdditionalChannelInitializer wsAdditionalChannelInitializer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResponseBodyPartFactory responseBodyPartFactory;</span><br><span class="line"><span class="comment">//其实就是EventLoopGroup指定的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ioThreadsCount;</span><br></pre></td></tr></table></figure>

<p>就从这里开始，开头主要实例化<code>ChannelManager</code>和<code>NettyRequestSender</code>以及<code>Timer</code>三个重要组件，<code>NettyRequestSender</code>用于发送请求以及向<code>ChannelManager</code>索取channel使用权，<code>Timer</code>则负责另外两个组件给他的检测任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dsl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncHttpClient <span class="title">asyncHttpClient</span><span class="params">(DefaultAsyncHttpClientConfig.Builder configBuilder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认客户端</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultAsyncHttpClient(configBuilder.build());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAsyncHttpClient</span> <span class="keyword">implements</span> <span class="title">AsyncHttpClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AsyncHttpClientConfig config;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean closed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">  <span class="comment">//Netty初始化的起点，Bootstrap与Channel池管理都在这里声明</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ChannelManager channelManager;</span><br><span class="line">  <span class="comment">//发送请求，以及向ChannelManager索取channel的使用权</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> NettyRequestSender requestSender;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> allowStopNettyTimer;</span><br><span class="line">  <span class="comment">//定时做超时处理</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Timer nettyTimer;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultAsyncHttpClient</span><span class="params">(AsyncHttpClientConfig config)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line"></span><br><span class="line">    allowStopNettyTimer = config.getNettyTimer() == <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//默认使用HashedWheelTimer</span></span><br><span class="line">    nettyTimer = allowStopNettyTimer ? newNettyTimer() :config.getNettyTimer();</span><br><span class="line">    <span class="comment">//下面两个是重点！！！</span></span><br><span class="line">    channelManager = <span class="keyword">new</span> ChannelManager(config, nettyTimer);</span><br><span class="line">    requestSender = <span class="keyword">new</span> NettyRequestSender(config, channelManager,nettyTimer, <span class="keyword">new</span> AsyncHttpClientState(closed));</span><br><span class="line">    <span class="comment">//给Bootstraps配置解析器，以及处理接收服务端发送的消息的处理器</span></span><br><span class="line">    channelManager.configureBootstraps(requestSender);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> Timer <span class="title">newNettyTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashedWheelTimer timer = <span class="keyword">new</span> HashedWheelTimer();</span><br><span class="line">    timer.start();</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是重中之重，网络配置、连接池、IO线程池、轮询方式都是在这儿产生的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AsyncHttpClientConfig config;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> allowReleaseEventLoopGroup;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Bootstrap httpBootstrap;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Bootstrap wsBootstrap;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> handshakeTimeout;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> IOException tooManyConnections;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> IOException tooManyConnectionsPerHost;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定时清理不符合标准的channel</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ChannelPool channelPool;</span><br><span class="line">  <span class="comment">//netty自带的用于管理channel的管理器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ChannelGroup openChannels;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Channel, Object&gt; channelId2PartitionKey = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">//是否开启最大总连接数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> maxTotalConnectionsEnabled;</span><br><span class="line">  <span class="comment">//最大连接数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Semaphore freeChannels;</span><br><span class="line">  <span class="comment">//是否开启每个路由最大连接数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> maxConnectionsPerHostEnabled;</span><br><span class="line">  <span class="comment">//每个路由最大连接数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Object, Semaphore&gt; freeChannelsPerHost = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> AsyncHttpClientHandler wsHandler;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ChannelManager</span><span class="params">(<span class="keyword">final</span> AsyncHttpClientConfig config, Timer nettyTimer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">    <span class="comment">//忽略一小段关于ssl的</span></span><br><span class="line">    <span class="comment">//ChannelPool是用于检测已经实例化的channel的健康状况，如果不合格会直接close掉</span></span><br><span class="line">    ChannelPool channelPool = config.getChannelPool();</span><br><span class="line">    <span class="keyword">if</span> (channelPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (config.isKeepAlive()) &#123;</span><br><span class="line">            <span class="comment">//这是默认使用的，事实上多数场景不需要我们自己实现</span></span><br><span class="line">            channelPool = <span class="keyword">new</span> DefaultChannelPool(config, nettyTimer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channelPool = NoopChannelPool.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.channelPool = channelPool;</span><br><span class="line"></span><br><span class="line">    tooManyConnections = trimStackTrace(<span class="keyword">new</span> TooManyConnectionsException(config.getMaxConnections()));</span><br><span class="line">    tooManyConnectionsPerHost = trimStackTrace(<span class="keyword">new</span> TooManyConnectionsPerHostException(config.getMaxConnectionsPerHost()));</span><br><span class="line">    maxTotalConnectionsEnabled = config.getMaxConnections() &gt; <span class="number">0</span>;</span><br><span class="line">    maxConnectionsPerHostEnabled = config.getMaxConnectionsPerHost() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxTotalConnectionsEnabled || maxConnectionsPerHostEnabled) &#123;</span><br><span class="line">        <span class="comment">//管理已经被实例化的channel</span></span><br><span class="line">        openChannels = <span class="keyword">new</span> DefaultChannelGroup(<span class="string">"asyncHttpClient"</span>, GlobalEventExecutor.INSTANCE) &#123;</span><br><span class="line">            <span class="comment">//重写删除方法，因为删除channel时，需要释放信号量</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">boolean</span> removed = <span class="keyword">super</span>.remove(o);</span><br><span class="line">                <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">                    <span class="comment">//释放总连接池的信号量</span></span><br><span class="line">                    <span class="keyword">if</span> (maxTotalConnectionsEnabled)</span><br><span class="line">                        freeChannels.release();</span><br><span class="line">                    <span class="comment">//释放路由连接池的信号量</span></span><br><span class="line">                    <span class="keyword">if</span> (maxConnectionsPerHostEnabled) &#123;</span><br><span class="line">                        Object partitionKey = channelId2PartitionKey.remove(Channel<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">o</span>))</span>;</span><br><span class="line">                        <span class="keyword">if</span> (partitionKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            Semaphore hostFreeChannels = freeChannelsPerHost.get(partitionKey);</span><br><span class="line">                            <span class="keyword">if</span> (hostFreeChannels != <span class="keyword">null</span>)</span><br><span class="line">                                hostFreeChannels.release();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> removed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//信号量数为最大连接数</span></span><br><span class="line">        freeChannels = <span class="keyword">new</span> Semaphore(config.getMaxConnections());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        openChannels = <span class="keyword">new</span> DefaultChannelGroup(<span class="string">"asyncHttpClient"</span>, GlobalEventExecutor.INSTANCE);</span><br><span class="line">        freeChannels = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handshakeTimeout = config.getHandshakeTimeout();</span><br><span class="line"></span><br><span class="line">    ThreadFactory threadFactory = config.getThreadFactory() != <span class="keyword">null</span> ? config.getThreadFactory() : <span class="keyword">new</span> DefaultThreadFactory(config.getThreadPoolName());</span><br><span class="line">    allowReleaseEventLoopGroup = config.getEventLoopGroup() == <span class="keyword">null</span>;</span><br><span class="line">    ChannelFactory&lt;? extends Channel&gt; channelFactory;</span><br><span class="line">    <span class="keyword">if</span> (allowReleaseEventLoopGroup) &#123;</span><br><span class="line">        <span class="comment">//这个只能在linux下使用</span></span><br><span class="line">        <span class="keyword">if</span> (config.isUseNativeTransport()) &#123;</span><br><span class="line">            eventLoopGroup = newEpollEventLoopGroup(config.getIoThreadsCount(), threadFactory);</span><br><span class="line">            channelFactory = getEpollSocketChannelFactory();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//通常默认走这个！</span></span><br><span class="line">            eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(config.getIoThreadsCount(), <span class="comment">//瞧！IO线程数就是时间轮询的线程数</span></span><br><span class="line">              threadFactory);</span><br><span class="line">            channelFactory = NioSocketChannelFactory.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于http请求的bootstrap</span></span><br><span class="line">    httpBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);</span><br><span class="line">    <span class="comment">//用于WebSocket请求的bootstrap</span></span><br><span class="line">    wsBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);</span><br><span class="line"></span><br><span class="line">    httpBootstrap.option(ChannelOption.AUTO_READ, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化完<code>ChannelManager</code>后，就轮到请求发送器，这里先看看所需要的参数，具体执行的方法在后面说。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyRequestSender</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AsyncHttpClientConfig config;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ChannelManager channelManager;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Timer nettyTimer;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AsyncHttpClientState clientState;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> NettyRequestFactory requestFactory;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NettyRequestSender</span><span class="params">(AsyncHttpClientConfig config,//</span></span></span><br><span class="line"><span class="function"><span class="params">            ChannelManager channelManager,//</span></span></span><br><span class="line"><span class="function"><span class="params">            Timer nettyTimer,//</span></span></span><br><span class="line"><span class="function"><span class="params">            AsyncHttpClientState clientState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.config = config;</span><br><span class="line">      <span class="keyword">this</span>.channelManager = channelManager;</span><br><span class="line">      <span class="keyword">this</span>.nettyTimer = nettyTimer;</span><br><span class="line">      <span class="keyword">this</span>.clientState = clientState;</span><br><span class="line">      requestFactory = <span class="keyword">new</span> NettyRequestFactory(config);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回来看看<code>ChannelManager</code>构造方法中使用的工厂方法<code>newBootstrap(channelFactory, eventLoopGroup, config)</code>，这是支持整个ahc运作的代码，对于用Netty实现网络客户端来说，这个配置很有参考价值，所以也贴上来一起观赏！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Bootstrap <span class="title">newBootstrap</span><span class="params">(ChannelFactory&lt;? extends Channel&gt; channelFactory, EventLoopGroup eventLoopGroup, AsyncHttpClientConfig config)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap().channelFactory(channelFactory)</span><br><span class="line">            <span class="comment">//客户端只有worker线程池，ServerBootstrap则需要boss和worker</span></span><br><span class="line">            .group(eventLoopGroup)</span><br><span class="line">            <span class="comment">//设置内存分配器，我的理解是关于堆内存模型的，可用于对Netty的优化</span></span><br><span class="line">            .option(ChannelOption.ALLOCATOR, config.getAllocator() != <span class="keyword">null</span> ? config.getAllocator() : ByteBufAllocator.DEFAULT)</span><br><span class="line">            <span class="comment">//是否使用tcp的Nagle算法，文件传输可以选择使用</span></span><br><span class="line">            .option(ChannelOption.TCP_NODELAY, config.isTcpNoDelay())</span><br><span class="line">            <span class="comment">//重复使用本地地址端口</span></span><br><span class="line">            .option(ChannelOption.SO_REUSEADDR, config.isSoReuseAddress())<span class="comment">//</span></span><br><span class="line">            .option(ChannelOption.AUTO_CLOSE, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (config.getConnectTimeout() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config.getSoLinger() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//就是一个设置延迟关闭时间的参数，用于保证数据发送完成</span></span><br><span class="line">        bootstrap.option(ChannelOption.SO_LINGER, config.getSoLinger());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config.getSoSndBuf() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        bootstrap.option(ChannelOption.SO_SNDBUF, config.getSoSndBuf());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config.getSoRcvBuf() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        bootstrap.option(ChannelOption.SO_RCVBUF, config.getSoRcvBuf());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义配置</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;ChannelOption&lt;Object&gt;, Object&gt; entry : config.getChannelOptions().entrySet()) &#123;</span><br><span class="line">        bootstrap.option(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bootstrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面则是管道的配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureBootstraps</span><span class="params">(NettyRequestSender requestSender)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ahc自定义的ChannelInboundHandler，异步方式获取服务端返回的数据</span></span><br><span class="line">    <span class="comment">//我们自己获取数据后的核心业务逻辑，也在这里开始</span></span><br><span class="line">    <span class="keyword">final</span> AsyncHttpClientHandler httpHandler = <span class="keyword">new</span> HttpHandler(config, <span class="keyword">this</span>, requestSender);</span><br><span class="line">    wsHandler = <span class="keyword">new</span> WebSocketHandler(config, <span class="keyword">this</span>, requestSender);</span><br><span class="line">    <span class="keyword">final</span> NoopHandler pinnedEntry = <span class="keyword">new</span> NoopHandler();</span><br><span class="line"></span><br><span class="line">    httpBootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline pipeline = ch.pipeline()<span class="comment">//</span></span><br><span class="line">                    .addLast(PINNED_ENTRY, pinnedEntry)<span class="comment">//</span></span><br><span class="line">                    .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())<span class="comment">//</span></span><br><span class="line">                    .addLast(INFLATER_HANDLER, newHttpContentDecompressor())<span class="comment">//</span></span><br><span class="line">                    .addLast(CHUNKED_WRITER_HANDLER, <span class="keyword">new</span> ChunkedWriteHandler())<span class="comment">//</span></span><br><span class="line">                    .addLast(AHC_HTTP_HANDLER, httpHandler);</span><br><span class="line">            <span class="keyword">if</span> (config.getHttpAdditionalChannelInitializer() != <span class="keyword">null</span>)</span><br><span class="line">                config.getHttpAdditionalChannelInitializer().initChannel(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    wsBootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline pipeline = ch.pipeline()<span class="comment">//</span></span><br><span class="line">                    .addLast(PINNED_ENTRY, pinnedEntry)<span class="comment">//</span></span><br><span class="line">                    .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())<span class="comment">//</span></span><br><span class="line">                    .addLast(AHC_WS_HANDLER, wsHandler);</span><br><span class="line">            <span class="keyword">if</span> (config.getWsAdditionalChannelInitializer() != <span class="keyword">null</span>)</span><br><span class="line">                config.getWsAdditionalChannelInitializer().initChannel(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一切工作准备就绪，现在可以请求了！怎么构建请求就不打算讲了，可以自行阅读<code>RequestBuilderBase</code>类。执行<code>execute()</code>方法，正式开始请求，往下看<code>DefaultAsyncHttpClient.executeRequest()</code>怎么创建连接的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundRequestBuilder</span> <span class="keyword">extends</span> <span class="title">RequestBuilderBase</span>&lt;<span class="title">BoundRequestBuilder</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AsyncHttpClient client;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListenableFuture&lt;Response&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> client.executeRequest(build(), <span class="keyword">new</span> AsyncCompletionHandlerBase());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAsyncHttpClient</span> <span class="keyword">implements</span> <span class="title">AsyncHttpClient</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">executeRequest</span><span class="params">(Request request, AsyncHandler&lt;T&gt; handler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (config.getRequestFilters().isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">return</span> execute(request, handler);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不考虑设置请求过滤器的情况</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">execute</span><span class="params">(Request request, <span class="keyword">final</span> AsyncHandler&lt;T&gt; asyncHandler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//把请求参数，和读取数据后的回调一同塞给请求发送器</span></span><br><span class="line">          <span class="keyword">return</span> requestSender.sendRequest(request, asyncHandler, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          asyncHandler.onThrowable(e);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> ListenableFuture.CompletedFailure&lt;&gt;(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK～～上面列出<code>NettyRequestSender</code>需要什么参数，现在再来看看怎么做的？<br>下面的方法中，重点关注<code>sendRequestWithNewChannel</code>，它包括了如何新建channel、连接，抢占信号量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">sendRequest</span><span class="params">(<span class="keyword">final</span> Request request,//</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> AsyncHandler&lt;T&gt; asyncHandler,//</span></span></span><br><span class="line"><span class="function"><span class="params">            NettyResponseFuture&lt;T&gt; future,//</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> performingNextRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ProxyServer proxyServer = getProxyServer(config, request);</span><br><span class="line">    <span class="comment">//使用SSL代理或者ws</span></span><br><span class="line">    <span class="keyword">if</span> (proxyServer != <span class="keyword">null</span> &amp;&amp; (request.getUri().isSecured() || request.getUri().isWebSocket()) &amp;&amp; !isConnectDone(request, future))</span><br><span class="line">        <span class="comment">//暂时忽略另外两个创建连接的方式</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//我们的例子用的是GET，所以执行该方法</span></span><br><span class="line">        <span class="keyword">return</span> sendRequestWithCertainForceConnect(request, asyncHandler, future, performingNextRequest, proxyServer, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">sendRequestWithCertainForceConnect</span><span class="params">(//</span></span></span><br><span class="line"><span class="function"><span class="params">            Request request,//</span></span></span><br><span class="line"><span class="function"><span class="params">            AsyncHandler&lt;T&gt; asyncHandler,//</span></span></span><br><span class="line"><span class="function"><span class="params">            NettyResponseFuture&lt;T&gt; future,//注意，这时候传进来是<span class="keyword">null</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> performingNextRequest,//</span></span></span><br><span class="line"><span class="function"><span class="params">            ProxyServer proxyServer,//</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> forceConnect)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把所有请求信息保证在一个响应回调对象里</span></span><br><span class="line">    NettyResponseFuture&lt;T&gt; newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, forceConnect);</span><br><span class="line">    <span class="comment">//这里视图根据这个请求去拿去channel，过程有点漫长，回头再来解释</span></span><br><span class="line">    Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Channels.isChannelValid(channel))</span><br><span class="line">        <span class="keyword">return</span> sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, performingNextRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Channel <span class="title">getOpenChannel</span><span class="params">(NettyResponseFuture&lt;?&gt; future, Request request, ProxyServer proxyServer, AsyncHandler&lt;?&gt; asyncHandler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//future并没有channel，对于什么时候channel是可复用的，一直没搞明白，所以我基本默认每次都要新建一个channel</span></span><br><span class="line">    <span class="keyword">if</span> (future != <span class="keyword">null</span> &amp;&amp; future.isReuseChannel() &amp;&amp; Channels.isChannelValid(future.channel()))</span><br><span class="line">        <span class="keyword">return</span> future.channel();</span><br><span class="line">    <span class="comment">//视图在channelManager中找到可用对象</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> pollPooledChannel(request, proxyServer, asyncHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">sendRequestWithOpenChannel</span><span class="params">(Request request, ProxyServer proxy, NettyResponseFuture&lt;T&gt; future, AsyncHandler&lt;T&gt; asyncHandler, Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (asyncHandler <span class="keyword">instanceof</span> AsyncHandlerExtensions)</span><br><span class="line">        AsyncHandlerExtensions<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">asyncHandler</span>).<span class="title">onConnectionPooled</span>(<span class="title">channel</span>)</span>;</span><br><span class="line">    <span class="comment">//启动请求超时，在writeRequest中，会启动读取超时</span></span><br><span class="line">    TimeoutsHolder timeoutsHolder = scheduleRequestTimeout(future);</span><br><span class="line">    timeoutsHolder.initRemoteAddress((InetSocketAddress) channel.remoteAddress());</span><br><span class="line">    future.setChannelState(ChannelState.POOLED);</span><br><span class="line">    future.attachChannel(channel, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Channels.setAttribute(channel, future);</span><br><span class="line">    <span class="keyword">if</span> (Channels.isChannelValid(channel)) &#123;</span><br><span class="line">        writeRequest(future, channel);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handleUnexpectedClosedChannel(channel, future);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把这里当作一个请求连接的开始</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">sendRequestWithNewChannel</span><span class="params">(//</span></span></span><br><span class="line"><span class="function"><span class="params">            Request request,//</span></span></span><br><span class="line"><span class="function"><span class="params">            ProxyServer proxy,//</span></span></span><br><span class="line"><span class="function"><span class="params">            NettyResponseFuture&lt;T&gt; future,//</span></span></span><br><span class="line"><span class="function"><span class="params">            AsyncHandler&lt;T&gt; asyncHandler,//</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> performingNextRequest)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Realm realm = future.getRealm();</span><br><span class="line">    Realm proxyRealm = future.getProxyRealm();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//为做连接做准备</span></span><br><span class="line">    Bootstrap bootstrap = channelManager.getBootstrap(request.getUri(), proxy);</span><br><span class="line">    <span class="comment">//用于索取channel</span></span><br><span class="line">    Object partitionKey = future.getPartitionKey();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> acquireChannelLock = !performingNextRequest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//抢占信号量</span></span><br><span class="line">        <span class="keyword">if</span> (acquireChannelLock) &#123;</span><br><span class="line">            channelManager.acquireChannelLock(partitionKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        abort(<span class="keyword">null</span>, future, getCause(t));</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开启请求超时定时器</span></span><br><span class="line">    scheduleRequestTimeout(future);</span><br><span class="line">    <span class="comment">//域名解析</span></span><br><span class="line">    RequestHostnameResolver.INSTANCE.resolve(request, proxy, asyncHandler)<span class="comment">//</span></span><br><span class="line">            .addListener(<span class="keyword">new</span> SimpleFutureListener&lt;List&lt;InetSocketAddress&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">//域名解析后得到的IP地址列表</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(List&lt;InetSocketAddress&gt; addresses)</span> </span>&#123;</span><br><span class="line">                    NettyConnectListener&lt;T&gt; connectListener = <span class="keyword">new</span> NettyConnectListener&lt;&gt;(future, NettyRequestSender.<span class="keyword">this</span>, channelManager, acquireChannelLock, partitionKey);</span><br><span class="line">                    <span class="comment">//不要怀疑！这里开始连接了！！！</span></span><br><span class="line">                    NettyChannelConnector connector = <span class="keyword">new</span> NettyChannelConnector(request.getLocalAddress(), addresses, asyncHandler, clientState, config);</span><br><span class="line">                    <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">                        connector.connect(bootstrap, connectListener);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (acquireChannelLock) &#123;</span><br><span class="line">                        <span class="comment">//如果future已经完成，则释放信号量</span></span><br><span class="line">                        channelManager.releaseChannelLock(partitionKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//失败，释放信号</span></span><br><span class="line">                    <span class="keyword">if</span> (acquireChannelLock) &#123;</span><br><span class="line">                        channelManager.releaseChannelLock(partitionKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                    abort(<span class="keyword">null</span>, future, getCause(cause));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NettyChannelConnector</code>负责对远程IP创建连接，一旦连接成功，<code>NettyConnectListener</code>就会调用requestSender向服务端发送数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChannelConnector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">final</span> Bootstrap bootstrap, <span class="keyword">final</span> NettyConnectListener&lt;?&gt; connectListener)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取DNS后的IP地址</span></span><br><span class="line">      <span class="keyword">final</span> InetSocketAddress remoteAddress = remoteAddresses.get(i);</span><br><span class="line">      <span class="keyword">if</span> (asyncHandlerExtensions != <span class="keyword">null</span>)</span><br><span class="line">          asyncHandlerExtensions.onTcpConnectAttempt(remoteAddress);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          connect0(bootstrap, connectListener, remoteAddress);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (clientState.isClosed()) &#123;</span><br><span class="line">              connectListener.onFailure(<span class="keyword">null</span>, e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connect0</span><span class="params">(Bootstrap bootstrap, <span class="keyword">final</span> NettyConnectListener&lt;?&gt; connectListener, InetSocketAddress remoteAddress)</span> </span>&#123;</span><br><span class="line">      bootstrap.connect(remoteAddress, localAddress)<span class="comment">//</span></span><br><span class="line">              .addListener(<span class="keyword">new</span> SimpleChannelFutureListener() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">                      <span class="keyword">if</span> (asyncHandlerExtensions != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          asyncHandlerExtensions.onTcpConnectSuccess(remoteAddress, channel);</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="comment">//如果有设置连接的存活时间，则初始化channelId，在ChannelPool中自检有用到</span></span><br><span class="line">                      <span class="keyword">if</span> (connectionTtlEnabled) &#123;</span><br><span class="line">                          Channels.initChannelId(channel);</span><br><span class="line">                      &#125;</span><br><span class="line">                      connectListener.onSuccess(channel, remoteAddress);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Channel channel, Throwable t)</span> </span>&#123;</span><br><span class="line">                      <span class="keyword">if</span> (asyncHandlerExtensions != <span class="keyword">null</span>)</span><br><span class="line">                          asyncHandlerExtensions.onTcpConnectFailure(remoteAddress, t);</span><br><span class="line">                      <span class="comment">//如果连接失败，则尝试连接下一个IP</span></span><br><span class="line">                      <span class="keyword">boolean</span> retry = pickNextRemoteAddress();</span><br><span class="line">                      <span class="keyword">if</span> (retry)</span><br><span class="line">                          NettyChannelConnector.<span class="keyword">this</span>.connect(bootstrap, connectListener);</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                          connectListener.onFailure(channel, t);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接成功，就来到这里，拿到channel，准备向服务器发送数据！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyConnectListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Channel channel, InetSocketAddress remoteAddress)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      Channels.setInactiveToken(channel);</span><br><span class="line">      TimeoutsHolder timeoutsHolder = future.getTimeoutsHolder();</span><br><span class="line">      <span class="keyword">if</span> (futureIsAlreadyCancelled(channel)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Request request = future.getTargetRequest();</span><br><span class="line">      Uri uri = request.getUri();</span><br><span class="line">      timeoutsHolder.initRemoteAddress(remoteAddress);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (future.getProxyServer() == <span class="keyword">null</span> &amp;&amp; uri.isSecured()) &#123;</span><br><span class="line">        <span class="comment">//直接无视</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          writeRequest(channel);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeRequest</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (futureIsAlreadyCancelled(channel)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//在这设置属性，在读取服务器数据的httphandler里面有用到</span></span><br><span class="line">      Channels.setAttribute(channel, future);</span><br><span class="line">      <span class="comment">//注册到ChannelGroup中</span></span><br><span class="line">      channelManager.registerOpenChannel(channel, partitionKey);</span><br><span class="line">      <span class="comment">//设置为不复用channel</span></span><br><span class="line">      future.attachChannel(channel, <span class="keyword">false</span>);</span><br><span class="line">      <span class="comment">//发送请求数据</span></span><br><span class="line">      <span class="comment">//这个方法就不贴上来了，没什么意思</span></span><br><span class="line">      <span class="comment">//方法里最后将启动读取超时scheduleReadTimeout(future);意味将进入HttpHandler读取服务端数据</span></span><br><span class="line">      requestSender.writeRequest(future, channel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取数据一切顺利后，就会走下面这个私有方法，将channel送入channelpool里，等待生命的结束！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpHandler</span> <span class="keyword">extends</span> <span class="title">AsyncHttpClientHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishUpdate</span><span class="params">(<span class="keyword">final</span> NettyResponseFuture&lt;?&gt; future, Channel channel, <span class="keyword">boolean</span> expectOtherChunks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      future.cancelTimeouts();</span><br><span class="line">      <span class="keyword">boolean</span> keepAlive = future.isKeepAlive();</span><br><span class="line">      <span class="comment">//这里继续读取后面的数据块，最后channel被设置了回调，依然调用下面的tryToOfferChannelToPool方法</span></span><br><span class="line">      <span class="keyword">if</span> (expectOtherChunks &amp;&amp; keepAlive)</span><br><span class="line">          channelManager.drainChannelAndOffer(channel, future);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, future.getPartitionKey());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          future.done();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception t) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>tryToOfferChannelToPool</strong> 是<code>ChannelManager</code>的方法，主要将依然活跃的channel送入生命倒数器中，还记得connectionTtl么，这个参数在这就起作用了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryToOfferChannelToPool</span><span class="params">(Channel channel, AsyncHandler&lt;?&gt; asyncHandler, <span class="keyword">boolean</span> keepAlive, Object partitionKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//长连接，或者依然活跃的</span></span><br><span class="line">    <span class="keyword">if</span> (channel.isActive() &amp;&amp; keepAlive) &#123;</span><br><span class="line">        <span class="comment">//丢弃被设置的属性</span></span><br><span class="line">        Channels.setDiscard(channel);</span><br><span class="line">        <span class="keyword">if</span> (asyncHandler <span class="keyword">instanceof</span> AsyncHandlerExtensions)</span><br><span class="line">            AsyncHandlerExtensions<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">asyncHandler</span>).<span class="title">onConnectionOffer</span>(<span class="title">channel</span>)</span>;</span><br><span class="line">            <span class="comment">//尝试塞进pool里</span></span><br><span class="line">        <span class="keyword">if</span> (channelPool.offer(channel, partitionKey)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxConnectionsPerHostEnabled)</span><br><span class="line">                <span class="comment">//我没明白这个映射到底是干嘛用的</span></span><br><span class="line">                channelId2PartitionKey.putIfAbsent(channel, partitionKey);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//被pool驳回，就直接关闭掉！！</span></span><br><span class="line">            closeChannel(channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//已经死亡或者不是长连接，直接关闭！！</span></span><br><span class="line">        closeChannel(channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=#f28080>到这里，关于channel已经接近尾声了，细心的童鞋可能发现，信号量呢？！不用释放么？！其实在关闭channel的时候，已经释放了，这是因为 <strong>ChannelGroup</strong> 的作用，在将channel注册(add方法)到group的时候，已经在其上面加了关闭的监听器，一旦close就执行remove，实例化 <strong>ChannelGroup</strong> 时已经将<code>remove(channel)</code>重写，可以倒回去看是不是已经释放了信号量，也可以看看 <strong>ChannelGroup</strong> 源码是不是在<code>add</code>时候添加了监听器。</font></p>
<p>不过，这里只是接近尾声，没意味就结束了，还有存活的channel被塞到 <strong>ChannelPool</strong> 进行生命的倒计时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPool</span> <span class="keyword">implements</span> <span class="title">ChannelPool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Object, ConcurrentLinkedDeque&lt;IdleChannel&gt;&gt; partitions = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;ChannelId, ChannelCreation&gt; channelId2Creation;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean isClosed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Timer nettyTimer;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> connectionTtl;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> connectionTtlEnabled;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxIdleTime;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> maxIdleTimeEnabled;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> cleanerPeriod;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PoolLeaseStrategy poolLeaseStrategy;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultChannelPool</span><span class="params">(<span class="keyword">int</span> maxIdleTime,//</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> connectionTtl,//</span></span></span><br><span class="line"><span class="function"><span class="params">            PoolLeaseStrategy poolLeaseStrategy,//</span></span></span><br><span class="line"><span class="function"><span class="params">            Timer nettyTimer,//</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> cleanerPeriod)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.maxIdleTime = maxIdleTime;</span><br><span class="line">      <span class="keyword">this</span>.connectionTtl = connectionTtl;</span><br><span class="line">      connectionTtlEnabled = connectionTtl &gt; <span class="number">0</span>;</span><br><span class="line">      channelId2Creation = connectionTtlEnabled ? <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;() : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.nettyTimer = nettyTimer;</span><br><span class="line">      maxIdleTimeEnabled = maxIdleTime &gt; <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">this</span>.poolLeaseStrategy = poolLeaseStrategy;</span><br><span class="line">      <span class="comment">//在cleanerPeriod清理周期时间、connectionTtl连接存活时间、maxIdleTime最大空闲时间中选择最小的</span></span><br><span class="line">      <span class="keyword">this</span>.cleanerPeriod = Math.min(cleanerPeriod定时清理周期, Math.min(connectionTtlEnabled ? connectionTtl : Integer.MAX_VALUE, maxIdleTimeEnabled ? maxIdleTime : Integer.MAX_VALUE));</span><br><span class="line">      <span class="comment">//如果开启了连接存活时间，或者最大空闲时间，则实例化空闲channel检测</span></span><br><span class="line">      <span class="keyword">if</span> (connectionTtlEnabled || maxIdleTimeEnabled)</span><br><span class="line">          scheduleNewIdleChannelDetector(<span class="keyword">new</span> IdleChannelDetector());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleNewIdleChannelDetector</span><span class="params">(TimerTask task)</span> </span>&#123;</span><br><span class="line">      nettyTimer.newTimeout(task, cleanerPeriod, TimeUnit.MILLISECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IdleChannelDetector</span> <span class="keyword">implements</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">      <span class="comment">//挖出已经不满足条件的channel</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> List&lt;IdleChannel&gt; <span class="title">expiredChannels</span><span class="params">(ConcurrentLinkedDeque&lt;IdleChannel&gt; partition, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">          List&lt;IdleChannel&gt; idleTimeoutChannels = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">for</span> (IdleChannel idleChannel : partition) &#123;</span><br><span class="line">              <span class="comment">//空闲时间是否过期</span></span><br><span class="line">              <span class="keyword">boolean</span> isIdleTimeoutExpired = isIdleTimeoutExpired(idleChannel, now);</span><br><span class="line">              <span class="comment">//channel是否还活跃</span></span><br><span class="line">              <span class="keyword">boolean</span> isRemotelyClosed = isRemotelyClosed(idleChannel.channel);</span><br><span class="line">              <span class="comment">//存活时间是否过期</span></span><br><span class="line">              <span class="keyword">boolean</span> isTtlExpired = isTtlExpired(idleChannel.channel, now);</span><br><span class="line">              <span class="comment">//满足其中一个条件，加入即将被关闭的channel队列</span></span><br><span class="line">              <span class="keyword">if</span> (isIdleTimeoutExpired || isRemotelyClosed || isTtlExpired) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (idleTimeoutChannels == <span class="keyword">null</span>)</span><br><span class="line">                      idleTimeoutChannels = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">                  idleTimeoutChannels.add(idleChannel);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> idleTimeoutChannels != <span class="keyword">null</span> ? idleTimeoutChannels : Collections.&lt;IdleChannel&gt; emptyList();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//关闭expiredChannels筛选出来的队列，并返回一个已被close的channel队列</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> List&lt;IdleChannel&gt; <span class="title">closeChannels</span><span class="params">(List&lt;IdleChannel&gt; candidates)</span> </span>&#123;</span><br><span class="line">          List&lt;IdleChannel&gt; closedChannels = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candidates.size(); i++) &#123;</span><br><span class="line">              IdleChannel idleChannel = candidates.get(i);</span><br><span class="line">              <span class="comment">//如果未被占有，则直接close；如果中间出现有被占有的channel，实例化closedChannels，并将之前被close的channel塞进其中</span></span><br><span class="line">              <span class="keyword">if</span> (idleChannel.takeOwnership()) &#123;</span><br><span class="line">                  close(idleChannel.channel);</span><br><span class="line">                  <span class="keyword">if</span> (closedChannels != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      closedChannels.add(idleChannel);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="comment">//注意，这里只会被执行一次，closedChannels被实例化后不会再执行</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (closedChannels == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  closedChannels = <span class="keyword">new</span> ArrayList&lt;&gt;(candidates.size());</span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                      closedChannels.add(candidates.get(j));</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果closedChannels为null，代表已经关闭candidates所有channel，原封不动返回</span></span><br><span class="line">          <span class="comment">//如果closedChannels非null，代表被占用的channel没有close并继续存活在candidates，所以返回被close了的channel队列closedChannels</span></span><br><span class="line">          <span class="keyword">return</span> closedChannels != <span class="keyword">null</span> ? closedChannels : candidates;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (isClosed.get())</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">//检测器的启动时间</span></span><br><span class="line">          <span class="keyword">long</span> start = unpreciseMillisTime();</span><br><span class="line">          <span class="keyword">int</span> closedCount = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">int</span> totalCount = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">//遍历每个路由的被塞到ChannelPool的channel队列</span></span><br><span class="line">          <span class="keyword">for</span> (ConcurrentLinkedDeque&lt;IdleChannel&gt; partition : partitions.values()) &#123;</span><br><span class="line">              List&lt;IdleChannel&gt; closedChannels = closeChannels(expiredChannels(partition, start));</span><br><span class="line">              <span class="comment">//非空且开启了连接存活时间的channel且被close的channel，全部从channelId2Creation和partition中去除</span></span><br><span class="line">              <span class="keyword">if</span> (!closedChannels.isEmpty()) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (connectionTtlEnabled) &#123;</span><br><span class="line">                      <span class="keyword">for</span> (IdleChannel closedChannel : closedChannels)</span><br><span class="line">                          channelId2Creation.remove(channelId(closedChannel.channel));</span><br><span class="line">                  &#125;</span><br><span class="line">                  partition.removeAll(closedChannels);</span><br><span class="line">                  closedCount += closedChannels.size();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//退出并继续下一轮检测</span></span><br><span class="line">          scheduleNewIdleChannelDetector(timeout.task());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存放空闲channel</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IdleChannel</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Channel channel;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> start;</span><br><span class="line">      <span class="keyword">final</span> AtomicBoolean owned = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">      IdleChannel(Channel channel, <span class="keyword">long</span> start) &#123;</span><br><span class="line">          <span class="keyword">this</span>.channel = assertNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">          <span class="keyword">this</span>.start = start;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">takeOwnership</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> owned.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;...&#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//存放channel的创建时间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelCreation</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> creationTime;</span><br><span class="line">      <span class="keyword">final</span> Object partitionKey;</span><br><span class="line">      ChannelCreation(<span class="keyword">long</span> creationTime, Object partitionKey) &#123;</span><br><span class="line">          <span class="keyword">this</span>.creationTime = creationTime;</span><br><span class="line">          <span class="keyword">this</span>.partitionKey = partitionKey;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里才是channel的终结！！！</p>
<p>channel被终结了，但有些还存活的channel还在请求的路上，还有很重要的两点没说到，就是 <strong>请求超时</strong> 和 <strong>读取超时</strong>。<br>每个<code>NettyResponseFuture</code>都持有一个<code>TimeoutsHolder</code>来计算 <strong>requestTimeout</strong> 和 <strong>readTimeout</strong> 是否过期。在ResponseFuture获取连接后，以及获取成功向服务器发送数据后，都会分别启动请求超时和读取超时两个定时器。通过阅读源码，可以发现 <strong>requestTimeout</strong> 其实是包括了 <strong>readTimeout</strong>，如果请求剩余时间小于读取超时时间时，<code>startReadTimeout</code>是不会启动readTimeout定时器的。下面只贴上<code>TimeoutsHolder</code>的部分源码，<code>RequestTimeoutTimerTask</code>和<code>ReadTimeoutTimerTask</code>可以自行阅读。</p>
<p><font color=#f28080>对于这两个参数，需要说明一点就是，一旦超时过期，channel和future都会被close掉，如果读超设置比请超长则是无意义的，只会以requestTimeout为准。</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutsHolder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean cancelled = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Timer nettyTimer;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> NettyRequestSender requestSender;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> requestTimeoutMillisTime;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> readTimeoutValue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> NettyResponseFuture&lt;?&gt; nettyResponseFuture;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Timeout requestTimeout;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">volatile</span> Timeout readTimeout;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TimeoutsHolder</span><span class="params">(Timer nettyTimer, NettyResponseFuture&lt;?&gt; nettyResponseFuture, NettyRequestSender requestSender, AsyncHttpClientConfig config)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.nettyTimer = nettyTimer;</span><br><span class="line">      <span class="keyword">this</span>.nettyResponseFuture = nettyResponseFuture;</span><br><span class="line">      <span class="keyword">this</span>.requestSender = requestSender;</span><br><span class="line">      <span class="keyword">this</span>.readTimeoutValue = config.getReadTimeout();</span><br><span class="line">      <span class="keyword">int</span> requestTimeoutInMs = nettyResponseFuture.getTargetRequest().getRequestTimeout();</span><br><span class="line">      <span class="comment">//每个请求都可以独立设置请求超时时间</span></span><br><span class="line">      <span class="keyword">if</span> (requestTimeoutInMs == <span class="number">0</span>) &#123;</span><br><span class="line">          requestTimeoutInMs = config.getRequestTimeout();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (requestTimeoutInMs != -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//请求的到期时间，启动请求超时定时器</span></span><br><span class="line">          requestTimeoutMillisTime = unpreciseMillisTime() + requestTimeoutInMs;</span><br><span class="line">          requestTimeout = newTimeout(<span class="keyword">new</span> RequestTimeoutTimerTask(nettyResponseFuture, requestSender, <span class="keyword">this</span>, requestTimeoutInMs), requestTimeoutInMs);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          requestTimeoutMillisTime = -<span class="number">1L</span>;</span><br><span class="line">          requestTimeout = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startReadTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (readTimeoutValue != -<span class="number">1</span>) &#123;</span><br><span class="line">          startReadTimeout(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">startReadTimeout</span><span class="params">(ReadTimeoutTimerTask task)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//如果requestTimeout不为null，或者requestTimeout还没有过期并且读取超时时间&lt;请求剩余时间</span></span><br><span class="line">      <span class="keyword">if</span> (requestTimeout == <span class="keyword">null</span> || (!requestTimeout.isExpired() &amp;&amp; readTimeoutValue &lt; (requestTimeoutMillisTime - unpreciseMillisTime()))) &#123;</span><br><span class="line">          <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">              task = <span class="keyword">new</span> ReadTimeoutTimerTask(nettyResponseFuture, requestSender, <span class="keyword">this</span>, readTimeoutValue);</span><br><span class="line">          &#125;</span><br><span class="line">          Timeout readTimeout = newTimeout(task, readTimeoutValue);</span><br><span class="line">          <span class="keyword">this</span>.readTimeout = readTimeout;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">          task.clean();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后最后最后。。。</p>
<p>来总结一下ahc的连接池实现，很明显的一点整个过程都是对<code>Channel</code>的管理，而且对于连接的抢占则使用了<code>Semaphore</code>，这再方便不过了！！！对于信号量的释放，Netty的<code>ChannelGroup</code>有很大的功劳，它提供了最优雅的方式关闭channel并且释放信号量。除此之外，一堆的超时限制任务需要一个定时任务容器执行，Netty又提供了一个在面对大量任务依然稳坐泰山的<code>HashedWheelTimer</code>，有机会专门来说说这一个。还有就是<code>DefaultChannelPool</code>对存活时间的检测，实在是通俗易懂，而且基于前面说的几点，实现起来也相当方便。</p>
<p>如果遇到基于netty的网络编程开发，对于连接资源的管理ahc确实提供了一套不错的思路，不仅对客户端，服务端也是可以试一试的！</p>
</div><div class="tags"><a href="/tags/Netty/">Netty</a><a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><a href="/tags/NIO/">NIO</a></div><div class="post-nav"><a class="pre" href="/2018/02/27/20180227-%E3%80%90Java%E5%B9%B6%E5%8F%91%E3%80%91JUC-lock%E5%8C%85AbstractQueuedSynchronizer%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/">【Java并发】JUC.lock包AbstractQueuedSynchronizer的源码分析（一）</a><a class="next" href="/2017/01/29/20170129-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%E4%B8%8E%E6%83%B0%E6%80%A7/">初学Clojure—不可变性与惰性</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://zehonghuang.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-%E7%BC%96%E7%A8%8B/">C/C++编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Spring源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">java并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">java网络编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/rpc%E6%A1%86%E6%9E%B6/">rpc框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/">函数编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6/">分布式框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E6%96%87/">小文</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E8%AF%97/">小诗</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">开源框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">集合框架</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/clojure/" style="font-size: 15px;">clojure</a> <a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 15px;">教程</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">并发编程语言</a> <a href="/tags/java/" style="font-size: 15px;">java　</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/AOP/" style="font-size: 15px;">AOP</a> <a href="/tags/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/" style="font-size: 15px;">IOC控制反转</a> <a href="/tags/BeanFactory/" style="font-size: 15px;">BeanFactory</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">并发编程</a> <a href="/tags/%E5%90%8C%E6%AD%A5/" style="font-size: 15px;">同步</a> <a href="/tags/%E5%85%AC%E5%B9%B3%E9%94%81/" style="font-size: 15px;">公平锁</a> <a href="/tags/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/" style="font-size: 15px;">非公平锁</a> <a href="/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/" style="font-size: 15px;">可重入锁</a> <a href="/tags/%E8%AF%BB%E5%86%99%E9%94%81/" style="font-size: 15px;">读写锁</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/LinkedArray/" style="font-size: 15px;">LinkedArray</a> <a href="/tags/hashmap/" style="font-size: 15px;">hashmap</a> <a href="/tags/Hashtable/" style="font-size: 15px;">Hashtable</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/awk/" style="font-size: 15px;">awk</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/" style="font-size: 15px;">文本处理</a> <a href="/tags/LinkedHashMap/" style="font-size: 15px;">LinkedHashMap</a> <a href="/tags/%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6/" style="font-size: 15px;">异步框架</a> <a href="/tags/parseq/" style="font-size: 15px;">parseq</a> <a href="/tags/ReentrantLock/" style="font-size: 15px;">ReentrantLock</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E9%A5%A5%E6%B8%B4/" style="font-size: 15px;">线程饥渴</a> <a href="/tags/Dubbo/" style="font-size: 15px;">Dubbo</a> <a href="/tags/SPI/" style="font-size: 15px;">SPI</a> <a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 15px;">反射</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 15px;">源码分析</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" style="font-size: 15px;">负载均衡</a> <a href="/tags/LoadBalance/" style="font-size: 15px;">LoadBalance</a> <a href="/tags/Linux%E5%86%85%E6%A0%B8/" style="font-size: 15px;">Linux内核</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">网络编程</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/Linux%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">Linux编程</a> <a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/CAP%E7%90%86%E8%AE%BA/" style="font-size: 15px;">CAP理论</a> <a href="/tags/RAFT%E7%AE%97%E6%B3%95/" style="font-size: 15px;">RAFT算法</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/" style="font-size: 15px;">分布式一致性</a> <a href="/tags/BRAFT/" style="font-size: 15px;">BRAFT</a> <a href="/tags/JRaft/" style="font-size: 15px;">JRaft</a> <a href="/tags/%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95/" style="font-size: 15px;">选举算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/01/20200401-%E3%80%90JRaft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002%E3%80%91%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6/">【JRaft源码分析02】心跳机制以及日志复制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/20200328-%E3%80%90JRaft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9001%E3%80%91%E5%90%AF%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B/">【JRaft源码分析01】启用以及选举过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/21/20191221-%E3%80%90Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Redis%E7%9C%9F%E7%9A%84%E4%B8%8D%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%90%8E%E5%8F%B0IO%E6%9C%8D%E5%8A%A1-BIO/">【Redis源码分析】Redis真的不是单线程，后台IO服务(BIO)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/16/20191218-%E3%80%90Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Redis%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%EF%BC%81/">【Redis源码分析】Redis启动过程是这样的！</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/11/20191216-%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91new-Thread%E6%97%B6JVM%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/">【Java并发】new Thread时JVM做了什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/09/20190109-%E3%80%90%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%91NIO%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/">【网络编程】从Linux角度以及JVM源码，深入NIO的细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/23/20181123-%E3%80%90Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91BeanFactory%E4%BD%93%E7%B3%BB%E7%9A%84%E4%BD%9C%E7%94%A8/">【Spring源码分析】BeanFactory体系的作用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/06/20180906-%E3%80%90Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E5%9B%9B%E7%A7%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">【Dubbo源码分析】四种负载均衡</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/02/20180902-%E3%80%90Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91SPI%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%B0%86URL%E4%B8%8E%E5%8F%AF%E6%8F%92%E6%8B%94%E6%8B%93%E5%B1%95%E8%9E%8D%E5%90%88%E5%88%B0%E6%9E%81%E8%87%B4/">【Dubbo源码分析】SPI机制，将URL与可插拔拓展融合到极致</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/02/20180702%20-%E3%80%90Java%E5%B9%B6%E5%8F%91%E3%80%91JUC%E2%80%94ReentrantReadWriteLock%E6%9C%89%E5%9D%91%EF%BC%8C%E5%B0%8F%E5%BF%83%E8%AF%BB%E9%94%81%EF%BC%81/">【Java并发】JUC—ReentrantReadWriteLock有坑，小心读锁！</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">作为客体的类库.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>