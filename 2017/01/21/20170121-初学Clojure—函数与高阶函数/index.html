<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="哦：:"><title>初学Clojure—函数与高阶函数 | 作为客体的类库</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">初学Clojure—函数与高阶函数</h1><a id="logo" href="/.">作为客体的类库</a><p class="description">万智坑的码农小书虫，爱文学，爱哲学，蓝黑混白控，积极悲观主义者，初级非道德主义者。偶尔写写小诗，搞搞情调～</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">初学Clojure—函数与高阶函数</h1><div class="post-meta">Jan 21, 2017<span> | </span><span class="category"><a href="/categories/函数编程/">函数编程</a></span></div><div class="post-content"><p>本来这应该放在递归之前的，不过没什么影响，反而对闭包的理解有帮助。把函数作为第一等公民的clojure，自然会给函数提供吊炸天的功能，使其变得吊炸天，写出更吊炸天的闭包！例如串行调用的组合函数、偏函数和柯里化、以及高阶函数等等。</p>
<hr>
<ul>
<li><h3 id="函数的结果传给下一个函数"><a href="#函数的结果传给下一个函数" class="headerlink" title="函数的结果传给下一个函数"></a><font color="#0099ff">函数的结果传给下一个函数</font></h3></li>
</ul>
<p>有时候我们一个数据，需要依次传给一个函数处理后，传递给另外一个函数继续处理，多次传递形成函数链。</p>
<p>假如在一堆没有换行符的字符串中找某个人名以及他的年龄，可能需要这样的函数链。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;为了方便，假如只找第一个</span></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> find-name&amp;age [names] (<span class="name"><span class="builtin-name">vec</span></span> (<span class="name">.split</span></span><br><span class="line">                                   (<span class="name"><span class="builtin-name">first</span></span></span><br><span class="line">                                     (<span class="name">re-seq</span> #<span class="string">"\w*-\d*"</span> names))</span><br><span class="line">                                   <span class="string">"-"</span>)))</span><br><span class="line">(<span class="name">find-name&amp;age</span> <span class="string">"tom-42tim-24jim-12"</span>)<span class="comment">;=[tom 42]</span></span><br><span class="line"><span class="comment">;上面find-name&amp;age [names]实在写得难看，一条链下来的函数多得要死不说，单单圆括号就实在让人生畏。</span></span><br></pre></td></tr></table></figure></p>
<p>clojure为我们提供了一个可以省去那么多没必要圆括号的函数-<code>comp</code>！！<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;comp从右到左依次接受上一个函数的返回值，最后一个函数则接受comp外的实参</span></span><br><span class="line">((<span class="name"><span class="builtin-name">comp</span></span> vec #(<span class="name">.split</span> % <span class="string">"-"</span>) first re-seq) #<span class="string">"\w*-\d*"</span> <span class="string">"tom-42tim-24jim-12"</span>)<span class="comment">;=[tom 42]</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><h3 id="实在不想每次都传那么多个参数！"><a href="#实在不想每次都传那么多个参数！" class="headerlink" title="实在不想每次都传那么多个参数！"></a><font color="#0099ff">实在不想每次都传那么多个参数！</font></h3></li>
</ul>
<p>假如你的代码里总是需要<code>(+ 101 1 2 ? ? ?)</code>这样的函数的，偏函数可以让你传入某些固定的实参并返回一个需要传入剩余参数的新函数。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;传入101 1 2三个实参</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> my_+ (<span class="name"><span class="builtin-name">partial</span></span> + <span class="number">101</span> <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line"><span class="comment">;传入剩余参数</span></span><br><span class="line">(<span class="name">my_+</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)<span class="comment">;=114</span></span><br></pre></td></tr></table></figure></p>
<p>说到偏函数，自然会想到柯里化，然而。.<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> rematch [rex]</span><br><span class="line">  #(<span class="name">re-seq</span> rex %))</span><br><span class="line"><span class="comment">;括号没法省略，柯里化？算了吧！可以用变参就用变参吧！</span></span><br><span class="line">((<span class="name">rematch</span> #<span class="string">"\w*-\d*"</span>) <span class="string">"tom-42tim-24jim-12"</span>)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><h3 id="传入或返回一个函数"><a href="#传入或返回一个函数" class="headerlink" title="传入或返回一个函数"></a><font color="#0099ff">传入或返回一个函数</font></h3></li>
</ul>
<p>函数作为实参传入另外一个函数，后者则是一个高阶函数。clojure提供了许多高阶函数，例如<code>apply</code>、<code>map</code>、<code>filter</code>等。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">map</span></span> + [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>] [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>])<span class="comment">;=(2 4 6)</span></span><br><span class="line">(<span class="name"><span class="builtin-name">apply</span></span> + [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>])<span class="comment">;=10</span></span><br><span class="line"><span class="comment">;匿名函数是高阶函数的一个重要组成部分，临时作为实参，尤其作为返回值。</span></span><br><span class="line">(<span class="name"><span class="builtin-name">map</span></span> #(<span class="name"><span class="builtin-name">name</span></span> %) [<span class="symbol">:a</span> <span class="symbol">:b</span> <span class="symbol">:c</span>])<span class="comment">;=("a" "b" "c")</span></span><br></pre></td></tr></table></figure></p>
<p>上面的一个例子<code>rematch [rex]</code>就是一个把函数作为返回值的高阶函数。</p>
<ul>
<li><h3 id="绝妙的闭包"><a href="#绝妙的闭包" class="headerlink" title="绝妙的闭包"></a><font color="#0099ff">绝妙的闭包</font></h3></li>
</ul>
<p>在之前出现过的例子，有不少已经体现了闭包这个概念。</p>
<p>闭包什么意思呢？简单且不严谨的说，就是返回一个函数，然后这个函数可随意访问定义它的上下文的局部量。<code>A()</code>定义并返回<code>B()</code>，且<code>B()</code>可以返回<code>A()</code>中声明的局部量，那么调用<code>A()</code>时，得到一个闭包函数。偏函数和柯里化是一种闭包。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;函数中定义并返回一个匿名函数</span></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> rematch2 [content]</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [rex]</span><br><span class="line">    <span class="comment">;匿名函数可以随意返回上下文(即rematch2内)的局部量content</span></span><br><span class="line">    (<span class="name">re-seq</span> rex (<span class="name"><span class="builtin-name">str</span></span> content <span class="string">"///0099ff"</span>))))</span><br><span class="line">((<span class="name">rematch2</span> <span class="string">"tom-42tim-24jim-12"</span>) #<span class="string">"\d+"</span>)</span><br></pre></td></tr></table></figure></p>
</div><div class="tags"><a href="/tags/clojure/">clojure</a><a href="/tags/教程/">教程</a><a href="/tags/并发编程语言/">并发编程语言</a></div><div class="post-nav"><a class="pre" href="/2017/01/23/20170123-初学Clojure—集合与数据结构/">初学Clojure—集合与数据结构</a><a class="next" href="/2017/01/19/20170119-初学Clojure—循环与尾递归/">初学Clojure—循环与尾递归</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://zehonghuang.github.io"></form></div><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="http://zehonghuang.github.io"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring源码分析/">Spring源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java并发编程/">java并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java网络编程/">java网络编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/rpc框架/">rpc框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/函数编程/">函数编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/小文/">小文</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/小诗/">小诗</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开源框架/">开源框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/集合框架/">集合框架</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/clojure/" style="font-size: 15px;">clojure</a> <a href="/tags/教程/" style="font-size: 15px;">教程</a> <a href="/tags/并发编程语言/" style="font-size: 15px;">并发编程语言</a> <a href="/tags/java/" style="font-size: 15px;">java　</a> <a href="/tags/并发编程/" style="font-size: 15px;">并发编程</a> <a href="/tags/同步/" style="font-size: 15px;">同步</a> <a href="/tags/公平锁/" style="font-size: 15px;">公平锁</a> <a href="/tags/非公平锁/" style="font-size: 15px;">非公平锁</a> <a href="/tags/可重入锁/" style="font-size: 15px;">可重入锁</a> <a href="/tags/读写锁/" style="font-size: 15px;">读写锁</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/AOP/" style="font-size: 15px;">AOP</a> <a href="/tags/IOC控制反转/" style="font-size: 15px;">IOC控制反转</a> <a href="/tags/BeanFactory/" style="font-size: 15px;">BeanFactory</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/hashmap/" style="font-size: 15px;">hashmap</a> <a href="/tags/LinkedArray/" style="font-size: 15px;">LinkedArray</a> <a href="/tags/Hashtable/" style="font-size: 15px;">Hashtable</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/awk/" style="font-size: 15px;">awk</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/文本处理/" style="font-size: 15px;">文本处理</a> <a href="/tags/异步框架/" style="font-size: 15px;">异步框架</a> <a href="/tags/parseq/" style="font-size: 15px;">parseq</a> <a href="/tags/LinkedHashMap/" style="font-size: 15px;">LinkedHashMap</a> <a href="/tags/Dubbo/" style="font-size: 15px;">Dubbo</a> <a href="/tags/负载均衡/" style="font-size: 15px;">负载均衡</a> <a href="/tags/LoadBalance/" style="font-size: 15px;">LoadBalance</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/线程饥渴/" style="font-size: 15px;">线程饥渴</a> <a href="/tags/ReentrantLock/" style="font-size: 15px;">ReentrantLock</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/SPI/" style="font-size: 15px;">SPI</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/Linux编程/" style="font-size: 15px;">Linux编程</a> <a href="/tags/Linux内核/" style="font-size: 15px;">Linux内核</a> <a href="/tags/网络编程/" style="font-size: 15px;">网络编程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/12/16/20191216-【并发编程】new-Thread时JVM做了什么？/">【Java并发】new Thread时JVM做了什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/09/20190109-【网络编程】NIO的深入解析/">【网络编程】从Linux角度以及JVM源码，深入NIO的细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/23/20181123-【Spring源码分析】BeanFactory体系的作用/">【Spring源码分析】BeanFactory体系的作用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/06/20180906-【Dubbo源码分析】四种负载均衡/">【Dubbo源码分析】四种负载均衡</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/02/20180902-【Dubbo源码分析】SPI机制，将URL与可插拔拓展融合到极致/">【Dubbo源码分析】SPI机制，将URL与可插拔拓展融合到极致</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/02/20180702 -【Java并发】JUC—ReentrantReadWriteLock有坑，小心读锁！/">【Java并发】JUC—ReentrantReadWriteLock有坑，小心读锁！</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/20180227-【Java并发】JUC-lock包AbstractQueuedSynchronizer的源码分析（一）/">【Java并发】JUC.lock包AbstractQueuedSynchronizer的源码分析（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/03/20170403-asynchttpclient源码分析-基于Netty的连接池实现/">asynchttpclient源码分析-基于Netty的连接池实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/29/20170129-初学Clojure—不可变性与惰性/">初学Clojure—不可变性与惰性</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/23/20170123-初学Clojure—集合与数据结构/">初学Clojure—集合与数据结构</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">作为客体的类库.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>