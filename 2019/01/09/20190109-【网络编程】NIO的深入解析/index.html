<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="哦：:"><title>【网络编程】从Linux角度以及JVM源码，深入NIO的细节 | 作为客体的类库</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【网络编程】从Linux角度以及JVM源码，深入NIO的细节</h1><a id="logo" href="/.">作为客体的类库</a><p class="description">万智坑的码农小书虫，爱文学，爱哲学，蓝黑混白控，积极悲观主义者，初级非道德主义者。偶尔写写小诗，搞搞情调～</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">【网络编程】从Linux角度以及JVM源码，深入NIO的细节</h1><div class="post-meta">Jan 9, 2019<span> | </span><span class="category"><a href="/categories/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">java网络编程</a></span></div><div class="post-content"><p>最近一段时间都在啃Linux内核， 也给了自己机会再度深入理解Java的NIO实现，希望能获得更多东西，尝试理解以前未能理解的，会涉及少量OpenJDK源码。</p>
<hr>
<p>因为NIO本身的实现很多牵扯到操作系统，所以需要先稍微过一下，有理解不对的地方，请指出。</p>
<h3 id="涉及的Linux知识"><a href="#涉及的Linux知识" class="headerlink" title="涉及的Linux知识"></a>涉及的Linux知识</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>对于Linux来说，一切皆为文件，设备文件、IO文件还是普通文件，都可以通过一个叫做文件描述符（FileDescriptor）的东西来进行操作，其涉及的数据结构可以自行了解VFS。</p>
<h5 id="设备阻塞与非阻塞"><a href="#设备阻塞与非阻塞" class="headerlink" title="设备阻塞与非阻塞"></a>设备阻塞与非阻塞</h5><p>任意对设备的操作都是默认为阻塞的，如果没有或有不可操作的资源，会被添加到<code>wait_queue_head_t</code>中进行等待，直到被<code>semaphore</code>通知允许执行。此时可以通过<code>fcntl()</code>函数将文件描述符设置为非阻塞，若没有或有不可操作的资源，立即返回错误信息。</p>
<h4 id="JVM内存结构-amp-虚拟地址空间"><a href="#JVM内存结构-amp-虚拟地址空间" class="headerlink" title="JVM内存结构 &amp; 虚拟地址空间"></a>JVM内存结构 &amp; 虚拟地址空间</h4><p>众所周知，Linux下的每一进程都有自己的虚拟内存地址，而JVM也是一个进程，且JVM有自己的内存结构。既然如此，两者之间必有对应关系，OracleJDK7提供了NMT，用<code>jcmd pid VM.native_memory detail</code>可以查看各类区域的reserved，被committed的内存大小及其地址区间，再通过<code>pmap -p</code>可以看到进程内存信息。</p>
<p>肉眼对比地址区间可以发现，JVM heap是通过mmap分配内存的，位于进程的映射区内，而进程堆区可以被malloc进行分配，对应关系如图。<br><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/jvm%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80.png" alt="jvm内存虚拟地址"></p>
<h4 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h4><p>先回顾一下几个相关函数，JVM相关实现可以看Net.c源码，这里不做赘述。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// domain : AF_UNIX|AF_LOCAL 本地传输，AF_INET|AF_INET6  ipv4/6传输</span></span><br><span class="line"><span class="comment">// type : SOCK_STREAM -&gt; TCP, SOCK_DGRAM -&gt; UDP</span></span><br><span class="line"><span class="comment">// protocol : 0 系统默认</span></span><br><span class="line"><span class="comment">// return : socket fd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">//sockfd : socket retuen fd</span></span><br><span class="line"><span class="comment">//addr : sockaddr_in&#123;sin_family=AF_INET -&gt; ipv4,s_addr -&gt; ip地址,sin_port -&gt; 端口号&#125;</span></span><br><span class="line"><span class="comment">//addrlen : sockaddr的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* addr, <span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">//backlog : 最大连接数， syn queue + accpet queue 的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">//同bind()的参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sd, struct sockaddr *server, <span class="keyword">int</span> addr_len)</span></span>;</span><br></pre></td></tr></table></figure>
<p>另，socketIO可以使用<code>read &amp; write</code>，和<code>recv &amp; send</code>两种函数，后者多了一个参数flags。</p>
<p>注，阻塞非阻塞模式，以下函数返回值有所区别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;<span class="comment">//pwrite(), writev()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;<span class="comment">//pread(), readv()</span></span><br><span class="line"><span class="comment">//flags：这里没打算展开讲，自行google</span></span><br><span class="line"><span class="comment">//MSG_DONTROUTE 本地网络，不需查找路由</span></span><br><span class="line"><span class="comment">//MSG_OOB TCP URG紧急指针，多用于心跳</span></span><br><span class="line"><span class="comment">//MSG_PEEK  只读不取，数据保留在缓冲区</span></span><br><span class="line"><span class="comment">//MSG_WAITALL 等待到满足指定条件才返回，在此之前会一直阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">void</span> *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">void</span> *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>NIO在不同操作系统提供了不同实现，win-select，linux-epoll以及mac-kqueue，本文忽略windows平台，只说linux &amp; mac下的实现。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>不太想讲epoll跟select的区别，网上多的是，不过唯一要说epoll本身是fd，很多功能都基于此，也不需要select一样重复实例化，下面的kqueue也是一样。</p>
<p>首先是epoll是个文件，所以有可能被其他epoll/select/poll监听，所以可能会出现循环或反向路径，内核实现极其复杂冗长，有兴趣可以啃下<code>ep_loop_check</code>和<code>reverse_path_check</code>，我图论学得不好，看不下去。<br>需要说明fd、event、epfd的关系，epfd &lt;n/n&gt; fd &lt;n/n&gt; event，均是多对多的关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">  <span class="keyword">void</span> *ptr; <span class="comment">//如果需要，可以携带自定义数据</span></span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">//被监听的事件</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;</span><br><span class="line">  <span class="comment">//EPOLLOUT：TL，缓冲池为空</span></span><br><span class="line">  <span class="comment">//EPOLLIN：TL，缓冲池为满</span></span><br><span class="line">  <span class="comment">//EPOLLET：EL，有所变化</span></span><br><span class="line">  <span class="comment">//还有其他，不一一列出了</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//size : 可监听的最大数目，后来2.6.8开始，此参数无效</span></span><br><span class="line"><span class="comment">//return : epoll fd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="comment">//op : EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL 分别是新增修改删除fd</span></span><br><span class="line"><span class="comment">//fd : 被监听的事件</span></span><br><span class="line"><span class="comment">//event : 上面的struct</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">//events : 就绪事件的数组</span></span><br><span class="line"><span class="comment">//maxevents : 能被处理的最大事件数</span></span><br><span class="line"><span class="comment">//timeout : 0 非阻塞，-1 阻塞，&gt;0 等待超时</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，epoll的边沿模式(EL)和水平模式(TL)，</p>
<p><code>EL</code>只在中断信号来临时反馈，所以<code>buffer cache</code>的数据未处理完，没有新数据到来是不会通知就绪的。<br><code>TL</code>则是会查看<code>buffer cache</code>是否还有数据，只要没有被处理完，会继续通知就绪。</p>
<p>一个关于这两种模式的问题，就EL模式是否必须把fd设置为O_NONBLOCK。我不是很理解<a href="http://man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="noopener">Linux手册</a>中对EL的描述，为什么要和EL扯上关系，若是因为读写阻塞导致后续任务饥饿，那在TL是一样的后果。要我说，既然用了epoll，那就直接把fd设置为O_NONBLOCK得了，就没那么多事。</p>
<p>对此我强烈建议写过一次linux下的网络编程，加强理解，这里不写示例了。</p>
<h4 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a>kqueue</h4><p>全网关于kqueue的文章少之又少，特别是中文，描述得比较详细的只有这篇<a href="https://blog.csdn.net/mumumuwudi/article/details/47145801" target="_blank" rel="noopener">《FreeBSD Kqueue的实现原理》</a>，外文的就是发明者的论文和<a href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2&manpath=FreeBSD+5.0-current" target="_blank" rel="noopener">FreeBSD手册</a>了。kqueue的数据结构我并没有完全搞懂，懒得啃FreeBSD的实现（解压出来的源码有1.05g 手动微笑）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个kqueue fd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kqueue</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//用于注册、等待阻塞</span></span><br><span class="line"><span class="comment">//changelist : 监听列表</span></span><br><span class="line"><span class="comment">//nchanges : 监听数目</span></span><br><span class="line"><span class="comment">//eventlist : 就绪列表</span></span><br><span class="line"><span class="comment">//nevents : 就绪事件数目</span></span><br><span class="line"><span class="comment">//timeout : 0 非阻塞，-1 阻塞，&gt;0 等待超时</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kevent</span><span class="params">(<span class="keyword">int</span> kq, <span class="keyword">const</span> struct kevent *changelist, <span class="keyword">int</span> nchanges, struct kevent *eventlist, <span class="keyword">int</span> nevents, <span class="keyword">const</span> struct timespec *timeout)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kevent</span> &#123;</span></span><br><span class="line">  <span class="comment">//ident : 通常是个fd</span></span><br><span class="line">  <span class="keyword">uintpt_t</span> ident;</span><br><span class="line">  <span class="comment">//filter :</span></span><br><span class="line">  short filter; <span class="comment">// filter for event</span></span><br><span class="line">  u_short flags; <span class="comment">// action flags for kq</span></span><br><span class="line">  u_int fflags; <span class="comment">// filter flag value</span></span><br><span class="line">  <span class="keyword">intptr_t</span> data; <span class="comment">// filter data value</span></span><br><span class="line">  <span class="keyword">void</span> *udata; <span class="comment">// opaque identifier</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EV_SET(&amp;kev, ident, filter, flags, fflags, data, udata);</span><br></pre></td></tr></table></figure>

<h3 id="NIO源码"><a href="#NIO源码" class="headerlink" title="NIO源码"></a>NIO源码</h3><h4 id="先来一个NIO网络通讯的示例"><a href="#先来一个NIO网络通讯的示例" class="headerlink" title="先来一个NIO网络通讯的示例"></a>先来一个NIO网络通讯的示例</h4><p>Server，<code>IOException</code>是要做处理的，我懒得写。<a href="https://github.com/zehonghuang/github_blog_bak/blob/master/source/file/ServerDemo.java" target="_blank" rel="noopener">示例代码</a></p>
<p>Client，<code>read()</code>同 Server。<a href="https://github.com/zehonghuang/github_blog_bak/blob/master/source/file/ClientDemo.java" target="_blank" rel="noopener">示例代码</a></p>
<h4 id="多路复用们的包装类"><a href="#多路复用们的包装类" class="headerlink" title="多路复用们的包装类"></a>多路复用们的包装类</h4><p>我很想按照demo的代码顺序讲，但感觉NIO的实现几乎围绕着<code>SelectorImpl</code>写的，所以还是先来讲讲起子类与多路复用的包装类们。</p>
<h4 id="EPollSelectorImpl-amp-EPollSelectorWapper"><a href="#EPollSelectorImpl-amp-EPollSelectorWapper" class="headerlink" title="EPollSelectorImpl &amp; EPollSelectorWapper"></a><code>EPollSelectorImpl</code> &amp; <code>EPollSelectorWapper</code></h4><p>后者就是Linux中epoll编程的包装类，在对应的<code>EPollArrayWrapper.c</code>中可以看出调用的都是上面说到的函数，实现类特意注册了一个管道用于唤醒<code>epoll_wait</code>。</p>
<p>每种实现都是通过<code>selector.select();</code>进行轮询，其实现的终极入口在<code>SelectorImpl.doSelect(timeout)</code>，对于epoll来说，究极实现在<code>EPollArrayWrapper.poll(timeout)</code>，最后调用的则是<code>epoll_wait</code>，下面代码都是围绕着轮询实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EPollSelectorImpl</span> <span class="keyword">extends</span> <span class="title">SelectorImpl</span> </span>&#123;</span><br><span class="line">  <span class="comment">//用于中断epoll阻塞的pipe文件描述符，fd0:入口 fd1:出口</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> fd0;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> fd1;</span><br><span class="line">  <span class="comment">//epoll声明的JNI包装类</span></span><br><span class="line">  EPollArrayWrapper pollWrapper;</span><br><span class="line">  <span class="comment">//fd -&gt; selectionKey</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer,SelectionKeyImpl&gt; fdToKey;</span><br><span class="line">  <span class="comment">//关闭selector，将会把所有文件描述符全部close并置为-1，implClose()可见</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object interruptLock = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> interruptTriggered = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  EPollSelectorImpl(SelectorProvider sp) &#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">    <span class="comment">//删除被cancel的selectionKey</span></span><br><span class="line">    processDeregisterQueue();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      begin();</span><br><span class="line">      pollWrapper.poll(timeout);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除阻塞中被其他线程cancel的selectionKey</span></span><br><span class="line">    processDeregisterQueue();</span><br><span class="line">    <span class="keyword">int</span> numKeysUpdated = updateSelectedKeys();</span><br><span class="line">    <span class="comment">//处理中断</span></span><br><span class="line">    <span class="keyword">if</span> (pollWrapper.interrupted()) &#123;</span><br><span class="line">      <span class="comment">//清除pipe事件的响应，并恢复中断状态</span></span><br><span class="line">      pollWrapper.putEventOps(pollWrapper.interruptedIndex(), <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">synchronized</span> (interruptLock) &#123;</span><br><span class="line">        pollWrapper.clearInterrupted();</span><br><span class="line">        <span class="comment">//读取管道数据</span></span><br><span class="line">        IOUtil.drain(fd0);</span><br><span class="line">        interruptTriggered = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EPollArrayWrapper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> epfd;</span><br><span class="line">  <span class="comment">//用于对epoll_event *events数组的增删查改</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AllocatedNativeObject pollArray;</span><br><span class="line">  <span class="comment">//*events地址</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> pollArrayAddress;</span><br><span class="line">  <span class="comment">//对应上面fd1</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> outgoingInterruptFD;</span><br><span class="line">  <span class="comment">//对应上面fd0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> incomingInterruptFD;</span><br><span class="line">  <span class="comment">//*events中断事件的下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> interruptedIndex;</span><br><span class="line"></span><br><span class="line">  EPollArrayWrapper() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//创建epoll fd</span></span><br><span class="line">    epfd = epollCreate();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    updateRegistrations(); <span class="comment">//更新注册的event</span></span><br><span class="line">    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;updated; i++) &#123;</span><br><span class="line">      <span class="comment">//管道事件唤醒epoll，结束等待</span></span><br><span class="line">      <span class="keyword">if</span> (getDescriptor(i) == incomingInterruptFD) &#123;</span><br><span class="line">        interruptedIndex = i;</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> updated;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interrupt(outgoingInterruptFD);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//本地方法名: Java_sun_nio_ch_EPollArrayWrapper_interrupt，会向管道传递数字「1」表中断</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EPollArrayWrapper的JNI代码，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESTARTABLE(_cmd, _result) do &#123; \</span></span><br><span class="line">  <span class="keyword">do</span> &#123; \</span><br><span class="line">    _result = _cmd; \</span><br><span class="line">    <span class="comment">//如果被系统中断而结束轮询，会继续下一次epoll_wait</span></span><br><span class="line">  &#125; <span class="keyword">while</span>((_result == <span class="number">-1</span>) &amp;&amp; (errno == EINTR)); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_sun_nio_ch_EPollArrayWrapper_epollWait(JNIEnv *env, jobject <span class="keyword">this</span>,</span><br><span class="line">                                            jlong address, jint numfds,</span><br><span class="line">                                            jlong timeout, jint epfd)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span> = <span class="title">jlong_to_ptr</span>(<span class="title">address</span>);</span><span class="comment">//获取指针</span></span><br><span class="line">  <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123; <span class="comment">//无限阻塞 or 非阻塞</span></span><br><span class="line">    RESTARTABLE((*epoll_wait_func)(epfd, events, numfds, timeout), res);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;            <span class="comment">//系统中断后，会继续下一次epoll_wait</span></span><br><span class="line">    res = iepoll(epfd, events, numfds, timeout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">iepoll(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> numfds, jlong timeout)</span><br><span class="line">&#123;</span><br><span class="line">  jlong start, now;</span><br><span class="line">  <span class="keyword">int</span> remaining = timeout;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">t</span>;</span></span><br><span class="line">  <span class="keyword">int</span> diff;</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;t, <span class="literal">NULL</span>);</span><br><span class="line">  start = t.tv_sec * <span class="number">1000</span> + t.tv_usec / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> res = epoll_wait(epfd, events, numfds, timeout);</span><br><span class="line">    <span class="comment">//同RESTARTABLE，被中断后重新计算剩余超时时间并继续轮询</span></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span> &amp;&amp; errno == EINTR) &#123;</span><br><span class="line">      <span class="keyword">if</span> (remaining &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        gettimeofday(&amp;t, <span class="literal">NULL</span>);</span><br><span class="line">        now = t.tv_sec * <span class="number">1000</span> + t.tv_usec / <span class="number">1000</span>;</span><br><span class="line">        diff = now - start;</span><br><span class="line">        remaining -= diff;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span> || remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start = now;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KqueueSelectorImpl-amp-KqueueSelectorWapper"><a href="#KqueueSelectorImpl-amp-KqueueSelectorWapper" class="headerlink" title="KqueueSelectorImpl &amp; KqueueSelectorWapper"></a><code>KqueueSelectorImpl</code> &amp; <code>KqueueSelectorWapper</code></h4><p>我挺纠结是否要说kqueue，毕竟除了本身的声明过程，其他几乎与上述的epoll一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KQueueSelectorImpl</span> <span class="keyword">extends</span> <span class="title">SelectorImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> entries = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">    processDeregisterQueue();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      begin();</span><br><span class="line">      entries = kqueueWrapper.poll(timeout);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      end();</span><br><span class="line">    &#125;</span><br><span class="line">    processDeregisterQueue();</span><br><span class="line">    <span class="comment">//这里更新selectedKey的位置不同，但其中逻辑与epoll是一样的</span></span><br><span class="line">    <span class="keyword">return</span> updateSelectedKeys(entries);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KQueueArrayWrapper</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">    updateRegistrations();</span><br><span class="line">    <span class="keyword">int</span> updated = kevent0(kq, keventArrayAddress, NUM_KEVENTS, timeout);</span><br><span class="line">    <span class="keyword">return</span> updated;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">kevent0</span><span class="params">(<span class="keyword">int</span> kq, <span class="keyword">long</span> keventAddress, <span class="keyword">int</span> keventCount,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">long</span> timeout)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要说不同，也就最后<code>kevent0</code>的轮询，不像epoll收到中断后会继续轮询，这里是直接return 0，由用户代码继续下一次轮询。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_sun_nio_ch_KQueueArrayWrapper_kevent0(JNIEnv *env, jobject <span class="keyword">this</span>, jint kq,</span><br><span class="line">                                           jlong kevAddr, jint kevCount,</span><br><span class="line">                                           jlong timeout)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (timeout &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    ts.tv_sec = timeout / <span class="number">1000</span>;</span><br><span class="line">    ts.tv_nsec = (timeout % <span class="number">1000</span>) * <span class="number">1000000</span>;</span><br><span class="line">    tsp = &amp;ts;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    tsp = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result = kevent(kq, <span class="literal">NULL</span>, <span class="number">0</span>, kevs, kevCount, tsp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      JNU_ThrowIOExceptionWithLastError(env, <span class="string">"KQueueArrayWrapper: kqueue failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此，多路复用在JVM的实现到这为止。</p>
<h4 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h4><p>讲道理，这个图看起来复杂，其实功能接口很分明，阅读难度并不大。</p>
<p><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/Channel%E4%BD%93%E7%B3%BB.png" alt="Channel体系"></p>
<h4 id="接口类型及其作用"><a href="#接口类型及其作用" class="headerlink" title="接口类型及其作用"></a>接口类型及其作用</h4><p><code>Channel</code>顶级接口，实际只提供一个<code>close()</code>。</p>
<p><code>InterruptibleChannel</code>注释写了用于异步关闭or中断，大概说的是<code>AbstractInterruptibleChannel.begin()</code>的回调，中断后调用<code>implCloseChannel()</code>。</p>
<p><code>SelectableChannel</code>这个就是多路复用提供的部分实现API。</p>
<p><code>NetworkChannel</code>网络IO，绑定、设置socket选项等。</p>
<p><code>ScatteringByteChannel</code> &amp; <code>GatheringByteChannel</code>就是BufferByte读写了。</p>
<p><code>SeekableByteChannel</code>知道<code>lseek()</code>就明白是跟文件IO相关的了。</p>
<h4 id="网络IO相关实现及其分析"><a href="#网络IO相关实现及其分析" class="headerlink" title="网络IO相关实现及其分析"></a>网络IO相关实现及其分析</h4><p>这里我需要先说明一下<code>configureBlocking(boolean)</code>方法，这实际是调用了上述说到<code>fcntl()</code>，可以看下<code>IOUtil.configureBlocking(FileDescriptor fd, boolean blocking);</code>的JNI源码，所以下述socket fd都是非阻塞的，有<code>空循环</code>很正常。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IOUtil.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">configureBlocking(<span class="keyword">int</span> fd, jboolean blocking)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> flags = fcntl(fd, F_GETFL);</span><br><span class="line">  <span class="keyword">int</span> newflags = blocking ? (flags &amp; ~O_NONBLOCK) : (flags | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (flags == newflags) ? <span class="number">0</span> : fcntl(fd, F_SETFL, newflags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过有必要说明该方法的使用注意事项，一旦fd(即channel)被注册后，是不能重新设置为阻塞的。如果在注册前或不需要注册，是可以使用阻塞模式的fd进行读写操作的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSelectableChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">SelectableChannel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isOpen())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">      <span class="keyword">if</span> (blocking == block)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      <span class="comment">//ValidKeys是查找该fd是否有注册的key，如果有且设置为阻塞，直接抛异常。</span></span><br><span class="line">      <span class="keyword">if</span> (block &amp;&amp; haveValidKeys())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br><span class="line">      implConfigureBlocking(block);</span><br><span class="line">      blocking = block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面已经提及<code>AbstractSelectableChannel.configureBlocking</code>这么小而重要的方法，有一个与其息息相关的方法就是register了。需要说的是，epfd(或kq)和被监听的fd是可以多对多的，所以每个channel都需要被维护一个selectionKey[]记录被哪些epfd监听。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Object att)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isOpen())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">    <span class="comment">//随意传一个int是非法的</span></span><br><span class="line">    <span class="keyword">if</span> ((ops &amp; ~validOps()) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如上面所说，阻塞不能被注册的</span></span><br><span class="line">    <span class="keyword">if</span> (blocking)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br><span class="line">    <span class="comment">//从SelectionKey[]中查找是被注册过</span></span><br><span class="line">    SelectionKey k = findKey(sel);</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//实际调用epoll_ctl + EPOLL_CTL_MOD</span></span><br><span class="line">      k.interestOps(ops);</span><br><span class="line">      k.attach(att);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOpen())</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">        <span class="comment">//就是epoll_ctl + EPOLL_CTL_ADD</span></span><br><span class="line">        k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att);</span><br><span class="line">        addKey(k);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看看<code>ServerSocketChannel.open()</code>发射出去的实例<code>SocketChannelImpl</code>，示例中<code>ssc.bind(new InetSocketAddress(16767))</code>已经包含了<code>bind</code>&amp;<code>listen</code>两个函数，这里也把<code>accpet()</code>给说了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerSocketChannelImpl</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">ServerSocketChannel</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">SelChImpl</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">//未初始化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_UNINITIALIZED = -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//正在使用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_INUSE = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//socket被kill</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_KILLED = <span class="number">1</span>;</span><br><span class="line">  ServerSocketChannelImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    <span class="comment">// Net包含一切与socket编程有关的JNI</span></span><br><span class="line">    <span class="keyword">this</span>.fd =  Net.serverSocket(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// fd的真实地址</span></span><br><span class="line">    <span class="keyword">this</span>.fdVal = IOUtil.fdVal(fd);</span><br><span class="line">    <span class="keyword">this</span>.state = ST_INUSE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ServerSocketChannel <span class="title">bind</span><span class="params">(SocketAddress local, <span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      InetSocketAddress isa = (local == <span class="keyword">null</span>) ? <span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>) :</span><br><span class="line">          Net.checkAddress(local);</span><br><span class="line">      SecurityManager sm = System.getSecurityManager();</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="comment">//SDP相关的钩子，没看懂</span></span><br><span class="line">      NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());</span><br><span class="line">      <span class="comment">//实际调用的是net_util_md.c的NET_InetAddressToSockaddr 和NET_Bind</span></span><br><span class="line">      Net.bind(fd, isa.getAddress(), isa.getPort());</span><br><span class="line">      Net.listen(fd, backlog &lt; <span class="number">1</span> ? <span class="number">50</span> : backlog);</span><br><span class="line">      <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        localAddress = Net.localAddress(fd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SocketChannel <span class="title">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      SocketChannel sc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//connection fd，用于socket读写</span></span><br><span class="line">      FileDescriptor newfd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">      <span class="comment">//客户端地址</span></span><br><span class="line">      InetSocketAddress[] isaa = <span class="keyword">new</span> InetSocketAddress[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        begin();</span><br><span class="line">        <span class="keyword">if</span> (!isOpen())</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        thread = NativeThread.current();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          n = accept(<span class="keyword">this</span>.fd, newfd, isaa);</span><br><span class="line">          <span class="comment">//遇到EINTR，忽略且继续监听</span></span><br><span class="line">          <span class="keyword">if</span> ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        thread = <span class="number">0</span>;</span><br><span class="line">        end(n &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">assert</span> IOStatus.check(n);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//默认connection fd阻塞，后面需要非阻塞读写则重新设为O_NONBLOCK</span></span><br><span class="line">      IOUtil.configureBlocking(newfd, <span class="keyword">true</span>);</span><br><span class="line">      InetSocketAddress isa = isaa[<span class="number">0</span>];</span><br><span class="line">      sc = <span class="keyword">new</span> SocketChannelImpl(provider(), newfd, isa);</span><br><span class="line">      SecurityManager sm = System.getSecurityManager();</span><br><span class="line">      <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sc;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Net.c算是把Linux的socket编程都写了一遍了，部分是ipv6&amp;udp的设置，我个人不是很了解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Net.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_sun_nio_ch_Net_socket0(JNIEnv *env, jclass cl, jboolean preferIPv6,</span><br><span class="line">                            jboolean stream, jboolean reuse, jboolean ignored)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> type = (stream ? SOCK_STREAM : SOCK_DGRAM);</span><br><span class="line">  <span class="comment">//参数参考上述内容</span></span><br><span class="line">  fd = socket(domain, type, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> handleSocketError(env, errno);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//默认ipv4与ipv6能监听同一端口</span></span><br><span class="line">  setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (<span class="keyword">char</span>*)&amp;arg, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果是UDP协议（以下省略部分代码，可以阅读openjdk9的完整代码）</span></span><br><span class="line">  <span class="comment">//不支持IP_MULTICAST_ALL，这个是linux2.6的非标准选项，被人喷了一脸血</span></span><br><span class="line">  <span class="comment">//int level = (domain == AF_INET6) ? IPPROTO_IPV6 : IPPROTO_IP;</span></span><br><span class="line">  setsockopt(fd, level, IP_MULTICAST_ALL, (<span class="keyword">char</span>*)&amp;arg, <span class="keyword">sizeof</span>(arg));</span><br><span class="line">  <span class="comment">//支持IPv6组播</span></span><br><span class="line">  setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &amp;arg, <span class="keyword">sizeof</span>(arg));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//server是允许reuseadd的，client不允许</span></span><br><span class="line">  setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">char</span>*)&amp;arg, <span class="keyword">sizeof</span>(arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ServerSocketChannelImpl.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> JNIEXPORT jint JNICALL</span><br><span class="line"> Java_sun_nio_ch_ServerSocketChannelImpl_accept0(JNIEnv *env, jobject <span class="keyword">this</span>,</span><br><span class="line">                                                 jobject ssfdo, jobject newfdo,</span><br><span class="line">                                                 jobjectArray isaa)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="comment">//出现ECONNABORTED则忽略，继续accept，用户代码不需要对RST做出处理。</span></span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">     <span class="keyword">socklen_t</span> sa_len = alloc_len;</span><br><span class="line">     newfd = accept(ssfd, sa, &amp;sa_len);</span><br><span class="line">     <span class="keyword">if</span> (newfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (errno != ECONNABORTED) &#123;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (newfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">free</span>((<span class="keyword">void</span> *)sa);</span><br><span class="line">     <span class="comment">//IOS_** 同等IOStatus.java中的常量</span></span><br><span class="line">     <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">       <span class="keyword">return</span> IOS_UNAVAILABLE;</span><br><span class="line">     <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">       <span class="keyword">return</span> IOS_INTERRUPTED;</span><br><span class="line">     JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Accept failed"</span>);</span><br><span class="line">     <span class="keyword">return</span> IOS_THROWN;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>客户端的连接就很简单了，并不难，方法看似很长重点也就那么几行，JNI的代码就不贴了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(SocketAddress sa)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    InetAddress ia = isa.getAddress();</span><br><span class="line">    <span class="keyword">if</span> (ia.isAnyLocalAddress())</span><br><span class="line">      ia = InetAddress.getLocalHost();</span><br><span class="line">    n = Net.connect(fd,</span><br><span class="line">                    ia,</span><br><span class="line">                    isa.getPort());</span><br><span class="line">    <span class="comment">//同样忽略RST错误</span></span><br><span class="line">    <span class="keyword">if</span> ((n == IOStatus.INTERRUPTED)</span><br><span class="line">          &amp;&amp; isOpen())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h4><p>留个位置</p>
<h4 id="ByteBuffer体系"><a href="#ByteBuffer体系" class="headerlink" title="ByteBuffer体系"></a>ByteBuffer体系</h4><p>从继承关系来看，其实并不复杂，数据结构也很简单，但对于<code>malloc</code>和<code>allocateDirect</code>分配的空间在进程虚拟内存所处的位置却很值得拿出来探讨一番，因为涉及NIO是否真实现了<code>零拷贝</code>。</p>
<p><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/ByteBuffer.png" alt="ByteBuffer"></p>
<h5 id="Buffer的指针"><a href="#Buffer的指针" class="headerlink" title="Buffer的指针"></a>Buffer的指针</h5><p>就是个对数组操作的容器，内部的指针也很容易理解，直接上图上源码，不多做解释。</p>
<p><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/bytebuffer%E6%8C%87%E9%92%88.png" alt="Buffer的指针"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">  <span class="comment">//标记读取or写入位置</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//已读已写的位置</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//最大极限</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line">  <span class="comment">//容器容量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">  <span class="comment">//重设位置</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newPosition &gt; limit) || (newPosition &lt; <span class="number">0</span>))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    position = newPosition;</span><br><span class="line">    <span class="comment">//标记位超过新位置，重置为-1</span></span><br><span class="line">    <span class="keyword">if</span> (mark &gt; position) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//与position(int)方法同理</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class="number">0</span>))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    limit = newLimit;</span><br><span class="line">    <span class="comment">//如果位置超出新限制，则重合pos和limit</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt; limit) position = limit;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; limit) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h4><p>都是一些读读写写的操作，不做讲述了。</p>
<h4 id="HeapByteBuffer"><a href="#HeapByteBuffer" class="headerlink" title="HeapByteBuffer"></a>HeapByteBuffer</h4><p>其实就是个byte[]，这个确实没什么好讲的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapByteBuffer</span> <span class="keyword">extends</span> <span class="title">ByteBuffer</span> </span>&#123;</span><br><span class="line">  HeapByteBuffer(<span class="keyword">int</span> cap, <span class="keyword">int</span> lim) &#123;</span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, lim, cap, <span class="keyword">new</span> <span class="keyword">byte</span>[cap], <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h4><p>正如类名所示direct，分配了java heap以外的「直接」内存，空间大小由JVM参数<code>-XX:MaxDirectMemorySize</code>控制，默认64m。我一开始认为jvm应该会根据这个参数在进程里面分配相对于的vm_area_struct，与heap相似的管理方式。直到我看到下面<code>DirectByteBuffer</code>的构造方法，吃了一鲸，并不是我想象中那样，而是DirectMemory分配的控制是交给java控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectByteBuffer</span> <span class="keyword">extends</span> <span class="title">MappedByteBuffer</span> <span class="keyword">implements</span> <span class="title">DirectBuffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="comment">//是否对齐页面，一般设置为false，-XX:+PageAlignDirectMemory控制</span></span><br><span class="line">    <span class="comment">//如果对齐，最后的address是个页面上边框的地址，有利于页面查找效率</span></span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//这里会尝试分配空间，假如空间不足会执行Cleaner做清理后再次尝试分配</span></span><br><span class="line">    <span class="comment">//上面失败后，会进入自旋9次，若成功则返回，失败抛出OOM</span></span><br><span class="line">    <span class="comment">//关于这个方法可以参考JVM大佬寒泉子的http://lovestblog.cn/blog/2015/05/12/direct-buffer/</span></span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//看JNI代码可以看到jvm声明了自己的方法os::malloc进行内存分配</span></span><br><span class="line">      base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">      Bits.unreserveMemory(size, cap);</span><br><span class="line">      <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将内存全部置零</span></span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">// Round up to page boundary</span></span><br><span class="line">      address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地方我一直很让我纠结，这个「直接」内存是分配在进程的堆区还是在映射区（忽略malloc()大于128k使用mmap()），自己又实在不想浪费心力过分研读JVM源码。如果正用了malloc，DirectByteBuffer并非所谓实现Linux零拷贝。</p>
<p>如果是在进程堆区，最后还是要拷贝至内核空间，参考FileChannel的map()，JNI毫不吝啬直接调用mmap()，所以看到os::malloc我很疑惑是否仅仅直接交给glibc进行内存分配。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory(JNIEnv *env, jobject unsafe, jlong size))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_AllocateMemory"</span>);</span><br><span class="line">  <span class="keyword">size_t</span> sz = (<span class="keyword">size_t</span>)size;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (sz == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sz = round_to(sz, HeapWordSize);</span><br><span class="line">  <span class="keyword">void</span>* x = os::<span class="built_in">malloc</span>(sz, mtInternal);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//Copy::fill_to_words((HeapWord*)x, sz / HeapWordSize);</span></span><br><span class="line">  <span class="keyword">return</span> addr_to_java(x);</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/java/">java</a><a href="/tags/NIO/">NIO</a><a href="/tags/C-s/">C++s</a><a href="/tags/Linux%E5%86%85%E6%A0%B8/">Linux内核</a><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></div><div class="post-nav"><a class="pre" href="/2019/12/11/20191216-%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91new-Thread%E6%97%B6JVM%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/">【Java并发】new Thread时JVM做了什么？</a><a class="next" href="/2018/11/23/20181123-%E3%80%90Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91BeanFactory%E4%BD%93%E7%B3%BB%E7%9A%84%E4%BD%9C%E7%94%A8/">【Spring源码分析】BeanFactory体系的作用</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://zehonghuang.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Spring源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">java并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">java网络编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/rpc%E6%A1%86%E6%9E%B6/">rpc框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/">函数编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E6%96%87/">小文</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E8%AF%97/">小诗</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">开源框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">集合框架</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/clojure/" style="font-size: 15px;">clojure</a> <a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 15px;">教程</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">并发编程语言</a> <a href="/tags/java/" style="font-size: 15px;">java　</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/AOP/" style="font-size: 15px;">AOP</a> <a href="/tags/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/" style="font-size: 15px;">IOC控制反转</a> <a href="/tags/BeanFactory/" style="font-size: 15px;">BeanFactory</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">并发编程</a> <a href="/tags/%E5%90%8C%E6%AD%A5/" style="font-size: 15px;">同步</a> <a href="/tags/%E5%85%AC%E5%B9%B3%E9%94%81/" style="font-size: 15px;">公平锁</a> <a href="/tags/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/" style="font-size: 15px;">非公平锁</a> <a href="/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/" style="font-size: 15px;">可重入锁</a> <a href="/tags/%E8%AF%BB%E5%86%99%E9%94%81/" style="font-size: 15px;">读写锁</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/LinkedArray/" style="font-size: 15px;">LinkedArray</a> <a href="/tags/hashmap/" style="font-size: 15px;">hashmap</a> <a href="/tags/Hashtable/" style="font-size: 15px;">Hashtable</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/awk/" style="font-size: 15px;">awk</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/" style="font-size: 15px;">文本处理</a> <a href="/tags/LinkedHashMap/" style="font-size: 15px;">LinkedHashMap</a> <a href="/tags/%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6/" style="font-size: 15px;">异步框架</a> <a href="/tags/parseq/" style="font-size: 15px;">parseq</a> <a href="/tags/ReentrantLock/" style="font-size: 15px;">ReentrantLock</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E9%A5%A5%E6%B8%B4/" style="font-size: 15px;">线程饥渴</a> <a href="/tags/Dubbo/" style="font-size: 15px;">Dubbo</a> <a href="/tags/SPI/" style="font-size: 15px;">SPI</a> <a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 15px;">反射</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 15px;">源码分析</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" style="font-size: 15px;">负载均衡</a> <a href="/tags/LoadBalance/" style="font-size: 15px;">LoadBalance</a> <a href="/tags/C-s/" style="font-size: 15px;">C++s</a> <a href="/tags/Linux%E5%86%85%E6%A0%B8/" style="font-size: 15px;">Linux内核</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">网络编程</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/Linux%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">Linux编程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/12/11/20191216-%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91new-Thread%E6%97%B6JVM%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/">【Java并发】new Thread时JVM做了什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/09/20190109-%E3%80%90%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%91NIO%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/">【网络编程】从Linux角度以及JVM源码，深入NIO的细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/23/20181123-%E3%80%90Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91BeanFactory%E4%BD%93%E7%B3%BB%E7%9A%84%E4%BD%9C%E7%94%A8/">【Spring源码分析】BeanFactory体系的作用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/06/20180906-%E3%80%90Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E5%9B%9B%E7%A7%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">【Dubbo源码分析】四种负载均衡</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/02/20180902-%E3%80%90Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91SPI%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%B0%86URL%E4%B8%8E%E5%8F%AF%E6%8F%92%E6%8B%94%E6%8B%93%E5%B1%95%E8%9E%8D%E5%90%88%E5%88%B0%E6%9E%81%E8%87%B4/">【Dubbo源码分析】SPI机制，将URL与可插拔拓展融合到极致</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/02/20180702%20-%E3%80%90Java%E5%B9%B6%E5%8F%91%E3%80%91JUC%E2%80%94ReentrantReadWriteLock%E6%9C%89%E5%9D%91%EF%BC%8C%E5%B0%8F%E5%BF%83%E8%AF%BB%E9%94%81%EF%BC%81/">【Java并发】JUC—ReentrantReadWriteLock有坑，小心读锁！</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/20180227-%E3%80%90Java%E5%B9%B6%E5%8F%91%E3%80%91JUC-lock%E5%8C%85AbstractQueuedSynchronizer%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/">【Java并发】JUC.lock包AbstractQueuedSynchronizer的源码分析（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/03/20170403-asynchttpclient%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%9F%BA%E4%BA%8ENetty%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/">asynchttpclient源码分析-基于Netty的连接池实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/29/20170129-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%E4%B8%8E%E6%83%B0%E6%80%A7/">初学Clojure—不可变性与惰性</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/23/20170123-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">初学Clojure—集合与数据结构</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">作为客体的类库.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>