<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="哦：:"><title>【JRaft源码分析02】心跳机制以及日志复制 | 作为客体的类库</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'bf29959b0b96ba2e38c33997f1c76ee8';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><meta name="generator" content="Hexo 4.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【JRaft源码分析02】心跳机制以及日志复制</h1><a id="logo" href="/.">作为客体的类库</a><p class="description">JAVA与C/C++，专注中间件&amp;基础架构，欢迎技术交流，微信：hongframe</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">【JRaft源码分析02】心跳机制以及日志复制</h1><div class="post-meta">Apr 1, 2020<span> | </span><span class="category"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6/">分布式框架</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2020/04/01/20200401-【JRaft源码分析02】心跳机制以及日志复制/" href="/2020/04/01/20200401-%E3%80%90JRaft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002%E3%80%91%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6/#disqus_thread"></a><div class="post-content"><p>日志复制是所有分布式共识算法最重要也是最复杂的部分，需要考虑各种各样安全性，比如机器挂了持久化没做、网络分区导致term&amp;logindex不一致、成员变化带来两个任期相同的leader、异步网络出现日志乱序等等。</p>
<p>很多个细节，我边看源码边照着论文理解，一个异常判断反复推敲它的作用，想象发生的场景。这是源码级熟悉raft的好处，多多少少能身临其境，获取更多的实战校验。</p>
<p>后面至少还有两篇，成员变化和日志压缩。</p>
<hr>
<p>花了点时间做张较为直观的简化流程图，红色箭头是日志复制的过程。还是挺复杂的，包括不限于Node、LogManager、Replicator、BallotBox、StateMachine之间的调用，其实还有快照，以后再讲。</p>
<p>本文会分为三部分讲，写请求日志落盘、日志复制、commit执行StateMachine。<br><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/jraft%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="日志复制状态机"></p>
<p>开始前，有几个全局变量需要说明一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下一个要发送的LogIndexId，Leader上任初始化为lastLogIndex + 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span>                    nextIndex;</span><br><span class="line"><span class="comment">//每次日志复制都把多个LogEntity封装进Inflight，一次发送</span></span><br><span class="line"><span class="keyword">private</span> Inflight                         rpcInFly;  <span class="comment">//这里记录最近要的一个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayDeque&lt;Inflight&gt;       inflights              = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"><span class="comment">//Raft不允许乱序日志复制，所以需要这两个字段限制某个inflight是否对应某个request和response</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>                              reqSeq                 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>                              requiredNextSeq        = <span class="number">0</span>;    <span class="comment">//限制顺序</span></span><br></pre></td></tr></table></figure>

<h3 id="1、什么时候写入日志的？"><a href="#1、什么时候写入日志的？" class="headerlink" title="1、什么时候写入日志的？"></a>1、什么时候写入日志的？</h3><p><a href="https://github.com/zehonghuang/sofa-jraft/tree/master/jraft-example" target="_blank" rel="noopener">jraft-example</a>里有<code>CounterServer</code>这个示例，<code>IncrementAndGetRequestProcessor</code>专门处理写入请求，可见调用了<code>com.alipay.sofa.jraft.example.counter.CounterServiceImpl#applyOperation</code>，然后是<code>com.alipay.sofa.jraft.Node#apply</code>，写入请求处理从<code>NodeImpl.apply</code>开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(<span class="keyword">final</span> Task task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.shutdownLatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Utils.runClosureInThread(task.getDone(), <span class="keyword">new</span> Status(RaftError.ENODESHUTDOWN, <span class="string">"Node is shutting down."</span>));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Node is shutting down"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> LogEntry entry = <span class="keyword">new</span> LogEntry();</span><br><span class="line">    entry.setData(task.getData()); <span class="comment">// 封装具体操作对象，ByteBuffer</span></span><br><span class="line">    <span class="keyword">int</span> retryTimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> EventTranslator&lt;LogEntryAndClosure&gt; translator = (event, sequence) -&gt; &#123;</span><br><span class="line">            event.reset();</span><br><span class="line">            event.done = task.getDone();</span><br><span class="line">            event.entry = entry;</span><br><span class="line">            event.expectedTerm = task.getExpectedTerm();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.applyQueue.tryPublishEvent(translator)) &#123;<span class="comment">//JRaft在处理请求也是采用了完全异步，apply直接把任务丢到applyQueue</span></span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">//在内部类LogEntryAndClosureHandler处理任务</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                retryTimes++;</span><br><span class="line">                <span class="keyword">if</span> (retryTimes &gt; MAX_APPLY_RETRY_TIMES) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;<span class="comment">//applyQueue超载</span></span><br><span class="line">                &#125;</span><br><span class="line">                ThreadHelper.onSpinWait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">        Utils.runClosureInThread(task.getDone(), <span class="keyword">new</span> Status(RaftError.EPERM, <span class="string">"Node is down."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class LogEntryAndClosureHandler</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;LogEntryAndClosure&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;(NodeImpl.<span class="keyword">this</span>.raftOptions.getApplyBatch());</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(<span class="keyword">final</span> LogEntryAndClosure event, <span class="keyword">final</span> <span class="keyword">long</span> sequence, <span class="keyword">final</span> <span class="keyword">boolean</span> endOfBatch)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//shutdownLatch balabala...</span></span><br><span class="line">    <span class="keyword">this</span>.tasks.add(event); <span class="comment">//32条消息以上成批处理，endOfBatch表示是否最后一个</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.tasks.size() &gt;= NodeImpl.<span class="keyword">this</span>.raftOptions.getApplyBatch() || endOfBatch) &#123;</span><br><span class="line">        executeApplyingTasks(<span class="keyword">this</span>.tasks);<span class="comment">// 开始执行task，先生成并写入日志</span></span><br><span class="line">        <span class="keyword">this</span>.tasks.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeApplyingTasks</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntryAndClosure&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = tasks.size();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state != State.STATE_LEADER) &#123;</span><br><span class="line">            <span class="comment">// 这段可以自行看源码，直接调用tasks.get(i).done.run()，返回给client</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> List&lt;LogEntry&gt; entries = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> LogEntryAndClosure task = tasks.get(i);</span><br><span class="line">            <span class="keyword">if</span> (task.expectedTerm != -<span class="number">1</span> &amp;&amp; task.expectedTerm != <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">                <span class="keyword">if</span> (task.done != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//Task指定expectedTerm不一致也是不行的，一般默认-1，因为用户代码是获取不到currTerm的</span></span><br><span class="line">                    Utils.runClosureInThread(task.done, st);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.ballotBox.appendPendingTask(<span class="keyword">this</span>.conf.getConf(),</span><br><span class="line">                <span class="keyword">this</span>.conf.isStable() ? <span class="keyword">null</span> : <span class="keyword">this</span>.conf.getOldConf(), task.done)) &#123;</span><br><span class="line">                <span class="comment">//这里是追加该任务的选票箱，后面再说</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// set task entry info before adding to list.</span></span><br><span class="line">            task.entry.getId().setTerm(<span class="keyword">this</span>.currTerm);</span><br><span class="line">            task.entry.setType(EnumOutter.EntryType.ENTRY_TYPE_DATA);</span><br><span class="line">            entries.add(task.entry);</span><br><span class="line">        &#125;<span class="comment">//这里将操作写入日志</span></span><br><span class="line">        <span class="comment">//落盘后调用LeaderStableClosure，给自己投一票</span></span><br><span class="line">        <span class="keyword">this</span>.logManager.appendEntries(entries, <span class="keyword">new</span> LeaderStableClosure(entries));</span><br><span class="line">        <span class="comment">// update conf.first</span></span><br><span class="line">        checkAndSetConfiguration(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一篇就说到jraft很多核心逻辑都实现在EventHandler子类里，上面的处理请求和下面的日志刷盘、复制也是一样。</p>
<h3 id="2、有多少个Follower就有多少个Replicator"><a href="#2、有多少个Follower就有多少个Replicator" class="headerlink" title="2、有多少个Follower就有多少个Replicator"></a>2、有多少个Follower就有多少个Replicator</h3><p><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/1564467683208-a49fc0e7-b538-4340-b4d6-9e1698f0e221.png" alt="Replicator"></p>
<p>在Node赢得选举时，调用执行<code>NodeImpl.becomeLeader()</code>就通过replicatorGroup为每个Follower分配一个Replicator。每一个都有独立的定时器发送heartbeat、logEntity、installSnapshot，所有Replicator并发执行。</p>
<h4 id="2-1-启动Replicator"><a href="#2-1-启动Replicator" class="headerlink" title="2.1 启动Replicator"></a>2.1 启动Replicator</h4><p>start的调用可以在<code>ReplicatorGroupImpl.addReplicator</code>看到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadId <span class="title">start</span><span class="params">(<span class="keyword">final</span> ReplicatorOptions opts, <span class="keyword">final</span> RaftOptions raftOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opts.getLogManager() == <span class="keyword">null</span> || opts.getBallotBox() == <span class="keyword">null</span> || opts.getNode() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid ReplicatorOptions."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Replicator r = <span class="keyword">new</span> Replicator(opts, raftOptions);</span><br><span class="line">    <span class="keyword">if</span> (!r.rpcService.connect(opts.getPeerId().getEndpoint())) &#123;</span><br><span class="line">        <span class="comment">//建立与Follower的连接哈</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register replicator metric set.</span></span><br><span class="line">    <span class="keyword">final</span> MetricRegistry metricRegistry = opts.getNode().getNodeMetrics().getMetricRegistry();</span><br><span class="line">    <span class="keyword">if</span> (metricRegistry != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> String replicatorMetricName = getReplicatorMetricName(opts);</span><br><span class="line">            <span class="keyword">if</span> (!metricRegistry.getNames().contains(replicatorMetricName)) &#123;</span><br><span class="line">                metricRegistry.register(replicatorMetricName, <span class="keyword">new</span> ReplicatorMetricSet(opts, r));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start replication</span></span><br><span class="line">    r.id = <span class="keyword">new</span> ThreadId(r, r);<span class="comment">//ThreadId本质上就是个锁</span></span><br><span class="line">    r.id.lock();</span><br><span class="line">    notifyReplicatorStatusListener(r, ReplicatorEvent.CREATED);<span class="comment">//监听器ReplicatorStateListener.onCreated|onError|onDestroyed</span></span><br><span class="line">    r.catchUpClosure = <span class="keyword">null</span>;</span><br><span class="line">    r.lastRpcSendTimestamp = Utils.monotonicMs();</span><br><span class="line">    r.startHeartbeatTimer(Utils.nowMs());<span class="comment">//正式启动heartbeat timer</span></span><br><span class="line">    <span class="comment">//这里应该是为了把becomeLeader()-&gt;this.confCtx.flush更新的配置日志同步出去，并unlock</span></span><br><span class="line">    r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> r.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2、发送心跳包"><a href="#2-2、发送心跳包" class="headerlink" title="2.2、发送心跳包"></a>2.2、发送心跳包</h4><p><code>Replicator</code>作为一个<code>ThreadId</code>，需要继承内部类<code>Thread.OnError</code>，心跳被作为一种超时异常处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeartbeatTimer</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> startMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> dueTime = startMs + <span class="keyword">this</span>.options.getDynamicHeartBeatTimeoutMs();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.heartbeatTimer = <span class="keyword">this</span>.timerManager.schedule(() -&gt; onTimeout(<span class="keyword">this</span>.id), dueTime - Utils.nowMs(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">        onTimeout(<span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onTimeout</span><span class="params">(<span class="keyword">final</span> ThreadId id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span>) &#123;</span><br><span class="line">        id.setError(RaftError.ETIMEDOUT.getNumber());<span class="comment">//调用r.onError()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;&#125;<span class="comment">//LOG</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> ThreadId id, <span class="keyword">final</span> Object data, <span class="keyword">final</span> <span class="keyword">int</span> errorCode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (errorCode == RaftError.ETIMEDOUT.getNumber()) &#123;</span><br><span class="line">            id.unlock();</span><br><span class="line">            Utils.runInThread(() -&gt; sendHeartbeat(id));</span><br><span class="line">    &#125;<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>raft算法把心跳包也作为AppendEntries行为，也就是Follower将它视为日志消息，但可以不做处理直接返回。上面<code>sendHeartbeat</code>调用的是与id对应的<code>sendEmptyEntries</code>。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendEmptyEntries</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isHeartbeat,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> RpcResponseClosure&lt;AppendEntriesResponse&gt; heartBeatClosure)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AppendEntriesRequest.Builder rb = AppendEntriesRequest.newBuilder();</span><br><span class="line">    <span class="keyword">if</span> (!fillCommonFields(rb, <span class="keyword">this</span>.nextIndex - <span class="number">1</span>, isHeartbeat)) &#123;<span class="comment">//填充term、groupId、lastCommittedIndex</span></span><br><span class="line">        <span class="comment">//心跳不需要installSnapshot，暂时不管</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> monotonicSendTimeMs = Utils.monotonicMs();<span class="comment">//最近一次发送时间</span></span><br><span class="line">        <span class="keyword">final</span> AppendEntriesRequest request = rb.build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isHeartbeat) &#123;</span><br><span class="line">            <span class="keyword">this</span>.heartbeatCounter++;</span><br><span class="line">            RpcResponseClosure&lt;AppendEntriesResponse&gt; heartbeatDone;</span><br><span class="line">            <span class="keyword">if</span> (heartBeatClosure != <span class="keyword">null</span>) &#123;</span><br><span class="line">                heartbeatDone = heartBeatClosure;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                heartbeatDone = <span class="keyword">new</span> RpcResponseClosureAdapter&lt;AppendEntriesResponse&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Status status)</span> </span>&#123;</span><br><span class="line">                        onHeartbeatReturned(Replicator.<span class="keyword">this</span>.id, status, request, getResponse(), monotonicSendTimeMs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.heartbeatInFly = <span class="keyword">this</span>.rpcService.appendEntries(<span class="keyword">this</span>.options.getPeerId().getEndpoint(), request,</span><br><span class="line">                <span class="keyword">this</span>.options.getElectionTimeoutMs() / <span class="number">2</span>, heartbeatDone);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送探测请求，后面说</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.id.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 回过头看Follower的<code>NodeImpl.handleAppendEntriesRequest</code>是如何处理heartbeat的。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">handleAppendEntriesRequest</span><span class="params">(<span class="keyword">final</span> AppendEntriesRequest request, <span class="keyword">final</span> RpcRequestClosure done)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startMs = Utils.monotonicMs();</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> entriesCount = request.getEntriesCount();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送heartbeat的Leader已经过时了</span></span><br><span class="line">        <span class="keyword">if</span> (request.getTerm() &lt; <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">            <span class="keyword">return</span> AppendEntriesResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                .setSuccess(<span class="keyword">false</span>) <span class="comment">//</span></span><br><span class="line">                .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">//</span></span><br><span class="line">                .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查heartbeat是否来自新上任Leader，如果是，则调用stepDown并重新设置new leader</span></span><br><span class="line">        checkStepDown(request.getTerm(), serverId);<span class="comment">//serverId.parse(request.getServerId())</span></span><br><span class="line">        <span class="keyword">if</span> (!serverId.equals(<span class="keyword">this</span>.leaderId)) &#123;</span><br><span class="line">            <span class="comment">//在成员变化时有可能出现两个同样任期的Leader，只需要term+1就可让两个leader下线，重新选举</span></span><br><span class="line">            stepDown(request.getTerm() + <span class="number">1</span>, <span class="keyword">false</span>, <span class="keyword">new</span> Status(RaftError.ELEADERCONFLICT,</span><br><span class="line">                <span class="string">"More than one leader in the same term."</span>));</span><br><span class="line">            <span class="keyword">return</span> AppendEntriesResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                .setSuccess(<span class="keyword">false</span>) <span class="comment">//</span></span><br><span class="line">                .setTerm(request.getTerm() + <span class="number">1</span>) <span class="comment">//</span></span><br><span class="line">                .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        updateLastLeaderTimestamp(Utils.monotonicMs());<span class="comment">//心跳成功更新时间</span></span><br><span class="line">        <span class="comment">//安装或加载快照会让follower阻塞日志复制，防止快照覆盖新的commit</span></span><br><span class="line">        <span class="keyword">if</span> (entriesCount &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.snapshotExecutor != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.snapshotExecutor.isInstallingSnapshot()) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcResponseFactory.newResponse(RaftError.EBUSY, <span class="string">"Node %s:%s is installing snapshot."</span>,</span><br><span class="line">                <span class="keyword">this</span>.groupId, <span class="keyword">this</span>.serverId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里证明follower日志落后于Leader</span></span><br><span class="line"><span class="comment">         * 因为走到这里只有request.getTerm() = this.currTerm</span></span><br><span class="line"><span class="comment">         * 所以localPrevLogTerm &lt;= this.currTerm</span></span><br><span class="line"><span class="comment">         * 如果prevLogIndex &gt; lastLogIndex, 说明localPrevLogTerm=0，RocksDB未把日志刷盘，机器挂了，丢失最近一部分数据</span></span><br><span class="line"><span class="comment">         * 如果prevLogIndex &lt; lastLogIndex，说明localPrevLogTerm!=0 &amp;&amp; localPrevLogTerm &lt; prevLogTerm，日志属于过期Leader，需要保证强一致性，每行日志的term&amp;logIndex必须一致</span></span><br><span class="line"><span class="comment">         * 第二种情况，会在长期网络分区后出现</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> prevLogIndex = request.getPrevLogIndex();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> prevLogTerm = request.getPrevLogTerm();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> localPrevLogTerm = <span class="keyword">this</span>.logManager.getTerm(prevLogIndex);</span><br><span class="line">        <span class="keyword">if</span> (localPrevLogTerm != prevLogTerm) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> lastLogIndex = <span class="keyword">this</span>.logManager.getLastLogIndex();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> AppendEntriesResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                .setSuccess(<span class="keyword">false</span>) <span class="comment">//</span></span><br><span class="line">                .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">//</span></span><br><span class="line">                .setLastLogIndex(lastLogIndex) <span class="comment">//</span></span><br><span class="line">                .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entriesCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// heartbeat</span></span><br><span class="line">            <span class="keyword">final</span> AppendEntriesResponse.Builder respBuilder = AppendEntriesResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                .setSuccess(<span class="keyword">true</span>) <span class="comment">//</span></span><br><span class="line">                .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">//</span></span><br><span class="line">                .setLastLogIndex(<span class="keyword">this</span>.logManager.getLastLogIndex());</span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">            <span class="comment">// see the comments at FollowerStableClosure#run()</span></span><br><span class="line">            <span class="keyword">this</span>.ballotBox.setLastCommittedIndex(Math.min(request.getCommittedIndex(), prevLogIndex));</span><br><span class="line">            <span class="keyword">return</span> respBuilder.build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里有balabala，跟日志复制有关的一堆代码下面再说</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 可以看到follower对心跳也做了一波处理。第一步，先校验对方或自己是否是合格Leader，否就让对方或自己下线；第二步，第一步正常就证明对方是一个合格的Leader以及自己是合格的Follower，那么校验双方的日志是否一致；前面一切正常了，再更新lastCommittedIndex，后面的日志同步会用到。</p>
<p> 来看看Leader收到heartbeat回复后怎么处理.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onHeartbeatReturned</span><span class="params">(<span class="keyword">final</span> ThreadId id, <span class="keyword">final</span> Status status, <span class="keyword">final</span> AppendEntriesRequest request, <span class="keyword">final</span> AppendEntriesResponse response, <span class="keyword">final</span> <span class="keyword">long</span> rpcSendTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTimeMs = Utils.nowMs();</span><br><span class="line">    Replicator r;</span><br><span class="line">    <span class="keyword">if</span> ((r = (Replicator) id.lock()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//网络通讯异常</span></span><br><span class="line">        <span class="keyword">if</span> (!status.isOk()) &#123;</span><br><span class="line">            r.state = State.Probe;</span><br><span class="line">            notifyReplicatorStatusListener(r, ReplicatorEvent.ERROR, status);</span><br><span class="line">            <span class="keyword">if</span> (++r.consecutiveErrorTimes % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            r.startHeartbeatTimer(startTimeMs);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r.consecutiveErrorTimes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (response.getTerm() &gt; r.options.getTerm()) &#123;</span><br><span class="line">            <span class="keyword">final</span> NodeImpl node = r.options.getNode();</span><br><span class="line">            r.notifyOnCaughtUp(RaftError.EPERM.getNumber(), <span class="keyword">true</span>);<span class="comment">//新节点追赶上集群，以后成员变化会说到</span></span><br><span class="line">            r.destroy();<span class="comment">//Leader不接受任期比自己大，increaseTermTo下线</span></span><br><span class="line">            node.increaseTermTo(response.getTerm(), <span class="keyword">new</span> Status(RaftError.EHIGHERTERMRESPONSE,</span><br><span class="line">                <span class="string">"Leader receives higher term heartbeat_response from peer:%s"</span>, r.options.getPeerId()));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!response.getSuccess() &amp;&amp; response.hasLastLogIndex()) &#123;</span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            r.sendEmptyEntries(<span class="keyword">false</span>);<span class="comment">//日志有异常，做AppendEntries的探测请求，对应上面Follower日志校验的逻辑</span></span><br><span class="line">            r.startHeartbeatTimer(startTimeMs);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rpcSendTime &gt; r.lastRpcSendTimestamp) &#123;</span><br><span class="line">            <span class="comment">//如果Leader频繁写入，那么更新last send time多数在onAppendEntriesReturned</span></span><br><span class="line">            r.lastRpcSendTimestamp = rpcSendTime;</span><br><span class="line">        &#125;</span><br><span class="line">        r.startHeartbeatTimer(startTimeMs);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            id.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>心跳包的代码基本就这些，heartbeat为了不重复发送选择定时而非周期Timer，直到收到响应后再次计时发送。</p>
<h4 id="2-3、AppendEntries要开始了么？"><a href="#2-3、AppendEntries要开始了么？" class="headerlink" title="2.3、AppendEntries要开始了么？"></a>2.3、AppendEntries要开始了么？</h4><p>日志复制可以说是绕得一批，我刚开始想当然，后来发现不是那样，很是疯狂。完全理清后，画个图比较直观。<br><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E5%BE%AA%E7%8E%AF2.png" alt="日志复制请求响应循环"></p>
<p>日志复制是一个请求响应自循环，最开始有<code>start()</code>调用<code>sendEmptyEntries(false)</code>做一次探测请求后正式启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendEmptyEntries</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isHeartbeat)</span> </span>&#123;</span><br><span class="line">    sendEmptyEntries(isHeartbeat, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendEmptyEntries</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isHeartbeat,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> RpcResponseClosure&lt;AppendEntriesResponse&gt; heartBeatClosure)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AppendEntriesRequest.Builder rb = AppendEntriesRequest.newBuilder();</span><br><span class="line">    <span class="keyword">if</span> (!fillCommonFields(rb, <span class="keyword">this</span>.nextIndex - <span class="number">1</span>, isHeartbeat)) &#123;</span><br><span class="line">        <span class="comment">// id is unlock in installSnapshot</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> monotonicSendTimeMs = Utils.monotonicMs();</span><br><span class="line">        <span class="keyword">final</span> AppendEntriesRequest request = rb.build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isHeartbeat) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Sending a probe request.</span></span><br><span class="line">            <span class="keyword">this</span>.statInfo.runningState = RunningState.APPENDING_ENTRIES;</span><br><span class="line">            <span class="keyword">this</span>.statInfo.firstLogIndex = <span class="keyword">this</span>.nextIndex;</span><br><span class="line">            <span class="keyword">this</span>.statInfo.lastLogIndex = <span class="keyword">this</span>.nextIndex - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.appendEntriesCounter++;</span><br><span class="line">            <span class="keyword">this</span>.state = State.Probe;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> stateVersion = <span class="keyword">this</span>.version;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> seq = getAndIncrementReqSeq();<span class="comment">//currseq=seq; seq++; return currseq;</span></span><br><span class="line">            <span class="keyword">final</span> Future&lt;Message&gt; rpcFuture = <span class="keyword">this</span>.rpcService.appendEntries(<span class="keyword">this</span>.options.getPeerId().getEndpoint(),</span><br><span class="line">                request, -<span class="number">1</span>, <span class="keyword">new</span> RpcResponseClosureAdapter&lt;AppendEntriesResponse&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Status status)</span> </span>&#123;</span><br><span class="line">                        onRpcReturned(Replicator.<span class="keyword">this</span>.id, RequestType.AppendEntries, status, request,</span><br><span class="line">                            getResponse(), seq, stateVersion, monotonicSendTimeMs);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            addInflight(RequestType.AppendEntries, <span class="keyword">this</span>.nextIndex, <span class="number">0</span>, <span class="number">0</span>, seq, rpcFuture);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.id.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>探测请求没什么好说的，值得注意的是onHeartbeatReturned是有可能触发该探测的。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onRpcReturned</span><span class="params">(<span class="keyword">final</span> ThreadId id, <span class="keyword">final</span> RequestType reqType, <span class="keyword">final</span> Status status, <span class="keyword">final</span> Message request,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">final</span> Message response, <span class="keyword">final</span> <span class="keyword">int</span> seq, <span class="keyword">final</span> <span class="keyword">int</span> stateVersion, <span class="keyword">final</span> <span class="keyword">long</span> rpcSendTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTimeMs = Utils.nowMs();</span><br><span class="line">    Replicator r;</span><br><span class="line">    <span class="keyword">if</span> ((r = (Replicator) id.lock()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stateVersion != r.version) &#123;</span><br><span class="line">        id.unlock();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要花点时间解释这个根据seq优先队列的用处</span></span><br><span class="line">    <span class="comment">//首先要知道raft强调日志必须顺序一致的，任何并发调用onRpcReturned都可能打乱复制顺序</span></span><br><span class="line">    <span class="comment">//假设现在this.reqSeq=3, requiredNextSeq=2，我们正在等待的reqSeq=2的响应由于种种原因还没到来</span></span><br><span class="line">    <span class="comment">//此时某次心跳onHeartbeatReturned触发了sendEmptyEntries(false)，将reqSeq改为4，也就说seq=3，而且该探测请求很快被响应且调用该方法</span></span><br><span class="line">    <span class="comment">//后来先到的response会被先hold到pendingResponses</span></span><br><span class="line">    <span class="keyword">final</span> PriorityQueue&lt;RpcResponse&gt; holdingQueue = r.pendingResponses;</span><br><span class="line">    holdingQueue.add(<span class="keyword">new</span> RpcResponse(reqType, seq, status, request, response, rpcSendTime));</span><br><span class="line">    <span class="comment">//某个优先级更高的请求还没被回复，需要做一次探测请求</span></span><br><span class="line">    <span class="keyword">if</span> (holdingQueue.size() &gt; r.raftOptions.getMaxReplicatorInflightMsgs()) &#123;</span><br><span class="line">        r.resetInflights();</span><br><span class="line">        r.state = State.Probe;</span><br><span class="line">        r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> continueSendEntries = <span class="keyword">false</span>;<span class="comment">//是否要继续上图虚线框内的Loop</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> processed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!holdingQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">final</span> RpcResponse queuedPipelinedResponse = holdingQueue.peek();<span class="comment">//优先级最高的响应</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据requiredNextSeq，还有更高优先级的响应未到，仍需等待</span></span><br><span class="line">            <span class="keyword">if</span> (queuedPipelinedResponse.seq != r.requiredNextSeq) &#123;</span><br><span class="line">                <span class="keyword">if</span> (processed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//前面还有processed已经成功处理，可能会调用sendEntries()，所以break即可</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//优先级最高的请求会被响应，所以直接返回unlock</span></span><br><span class="line">                    continueSendEntries = <span class="keyword">false</span>;</span><br><span class="line">                    id.unlock();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            holdingQueue.remove();</span><br><span class="line">            processed++;</span><br><span class="line">            <span class="keyword">final</span> Inflight inflight = r.pollInflight();</span><br><span class="line">            <span class="keyword">if</span> (inflight == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// The previous in-flight requests were cleared</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//我这里没想明白什么情况会出现queuedPipelinedResponse.seq==r.requiredNextSeq且!=inflight.seq</span></span><br><span class="line">            <span class="keyword">if</span> (inflight.seq != queuedPipelinedResponse.seq) &#123;</span><br><span class="line">                <span class="comment">// reset state</span></span><br><span class="line">                r.resetInflights();</span><br><span class="line">                r.state = State.Probe;</span><br><span class="line">                continueSendEntries = <span class="keyword">false</span>;</span><br><span class="line">                r.block(Utils.nowMs(), RaftError.EREQUEST.getNumber());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (queuedPipelinedResponse.requestType) &#123;</span><br><span class="line">                    <span class="keyword">case</span> AppendEntries:</span><br><span class="line">                        continueSendEntries = onAppendEntriesReturned(id, inflight, queuedPipelinedResponse.status,</span><br><span class="line">                            (AppendEntriesRequest) queuedPipelinedResponse.request,</span><br><span class="line">                            (AppendEntriesResponse) queuedPipelinedResponse.response, rpcSendTime, startTimeMs, r);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Snapshot:</span><br><span class="line">                        continueSendEntries = onInstallSnapshotReturned(id, r, queuedPipelinedResponse.status,</span><br><span class="line">                            (InstallSnapshotRequest) queuedPipelinedResponse.request,</span><br><span class="line">                            (InstallSnapshotResponse) queuedPipelinedResponse.response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (continueSendEntries) &#123;</span><br><span class="line">                    <span class="comment">// Success, increase the response sequence.</span></span><br><span class="line">                    r.getAndIncrementRequiredNextSeq();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// The id is already unlocked in onAppendEntriesReturned/onInstallSnapshotReturned, we SHOULD break out.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (continueSendEntries) &#123;</span><br><span class="line">            <span class="comment">// unlock in sendEntries.</span></span><br><span class="line">            r.sendEntries();<span class="comment">//继续日志复制循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>onRpcReturned</code>的主要功能在严格控制Leader处理请求-响应的顺序，避免乱序提交带来的数据不一致。</p>
<p>顺序校验后，轮到<code>onAppendEntriesReturned</code>了，它主要两个功能。<br>一个是校验<code>Replicator.nextIndex-1</code>与Follower.lastLogIndex是否一致，若否，则矫正；第二个，对已经复制成功的LogEntity反馈给<code>BallotBox</code>，quorum–。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">onAppendEntriesReturned</span><span class="params">(<span class="keyword">final</span> ThreadId id, <span class="keyword">final</span> Inflight inflight, <span class="keyword">final</span> Status status,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">final</span> AppendEntriesRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">final</span> AppendEntriesResponse response, <span class="keyword">final</span> <span class="keyword">long</span> rpcSendTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">final</span> <span class="keyword">long</span> startTimeMs, <span class="keyword">final</span> Replicator r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里我也没想明白满足(queuedPipelinedResponse.seq==r.requiredNextSeq &amp;&amp; queuedPipelinedResponse.seq==inflight.seq)，什么场景会出现不相等</span></span><br><span class="line">    <span class="keyword">if</span> (inflight.startIndex != request.getPrevLogIndex() + <span class="number">1</span>) &#123;</span><br><span class="line">        r.resetInflights();</span><br><span class="line">        r.state = State.Probe;</span><br><span class="line">        <span class="comment">// unlock id in sendEmptyEntries</span></span><br><span class="line">        r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!status.isOk()) &#123;   <span class="comment">//follower挂了，快速失败，且阻塞一小段时间，停止日志复制</span></span><br><span class="line">        notifyReplicatorStatusListener(r, ReplicatorEvent.ERROR, status);</span><br><span class="line">        <span class="keyword">if</span> (++r.consecutiveErrorTimes % <span class="number">10</span> == <span class="number">0</span>) &#123;&#125;</span><br><span class="line">        r.resetInflights();</span><br><span class="line">        r.state = State.Probe;</span><br><span class="line">        <span class="comment">// unlock in in block</span></span><br><span class="line">        r.block(startTimeMs, status.getCode());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r.consecutiveErrorTimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!response.getSuccess()) &#123;<span class="comment">//这个也不说了</span></span><br><span class="line">        <span class="keyword">if</span> (response.getTerm() &gt; r.options.getTerm()) &#123;</span><br><span class="line">            <span class="keyword">final</span> NodeImpl node = r.options.getNode();</span><br><span class="line">            r.notifyOnCaughtUp(RaftError.EPERM.getNumber(), <span class="keyword">true</span>);</span><br><span class="line">            r.destroy();</span><br><span class="line">            node.increaseTermTo(response.getTerm(), <span class="keyword">new</span> Status(RaftError.EHIGHERTERMRESPONSE,</span><br><span class="line">                <span class="string">"Leader receives higher term heartbeat_response from peer:%s"</span>, r.options.getPeerId()));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//能走到这一步，说明任期没问题，但LogIndex有出入</span></span><br><span class="line">        <span class="keyword">if</span> (rpcSendTime &gt; r.lastRpcSendTimestamp) &#123;</span><br><span class="line">            r.lastRpcSendTimestamp = rpcSendTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除所有准备发送的LogEntity</span></span><br><span class="line">        r.resetInflights();</span><br><span class="line">        <span class="comment">// 在[2.2、发送心跳包]那里handleAppendEntriesRequest有一大段注释，对应着看</span></span><br><span class="line">        <span class="keyword">if</span> (response.getLastLogIndex() + <span class="number">1</span> &lt; r.nextIndex) &#123;</span><br><span class="line">            <span class="comment">// The peer contains less logs than leader</span></span><br><span class="line">            r.nextIndex = response.getLastLogIndex() + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//逐一往回追溯，直到有term&amp;LogIndex对应上的nextIndex</span></span><br><span class="line">            <span class="keyword">if</span> (r.nextIndex &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                r.nextIndex--; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// LOG.error</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dummy_id is unlock in _send_heartbeat</span></span><br><span class="line">        r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// success，有可能Leader重新选举又赢了</span></span><br><span class="line">    <span class="keyword">if</span> (response.getTerm() != r.options.getTerm()) &#123;</span><br><span class="line">        r.resetInflights();</span><br><span class="line">        r.state = State.Probe;</span><br><span class="line">        id.unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rpcSendTime &gt; r.lastRpcSendTimestamp) &#123;</span><br><span class="line">        r.lastRpcSendTimestamp = rpcSendTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> entriesSize = request.getEntriesCount();</span><br><span class="line">    <span class="keyword">if</span> (entriesSize &gt; <span class="number">0</span>) &#123; <span class="comment">//这是一次复制请求的响应</span></span><br><span class="line">        <span class="keyword">if</span> (r.options.getReplicatorType().isFollower()) &#123;</span><br><span class="line">            r.options.getBallotBox().commitAt(r.nextIndex, r.nextIndex + entriesSize - <span class="number">1</span>, r.options.getPeerId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The request is probe request, change the state into Replicate.</span></span><br><span class="line">        r.state = State.Replicate;</span><br><span class="line">    &#125;</span><br><span class="line">    r.nextIndex += entriesSize;<span class="comment">//增加已经复制的偏移量</span></span><br><span class="line">    r.hasSucceeded = <span class="keyword">true</span>;</span><br><span class="line">    r.notifyOnCaughtUp(RaftError.SUCCESS.getNumber(), <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// dummy_id is unlock in _send_entries</span></span><br><span class="line">    <span class="keyword">if</span> (r.timeoutNowIndex &gt; <span class="number">0</span> &amp;&amp; r.timeoutNowIndex &lt; r.nextIndex) &#123;</span><br><span class="line">        r.sendTimeoutNow(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//继续日志复制循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发送日志就不说什么了，思路很清晰，整个过程如上图，是个自循环。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> prevSendIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> nextSendingIndex = getNextSendIndex();<span class="comment">//获取未被发送LogIndex</span></span><br><span class="line">            <span class="keyword">if</span> (nextSendingIndex &gt; prevSendIndex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sendEntries(nextSendingIndex)) &#123;</span><br><span class="line">                    prevSendIndex = nextSendingIndex;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    doUnlock = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.id.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">sendEntries</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> nextSendingIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AppendEntriesRequest.Builder rb = AppendEntriesRequest.newBuilder();</span><br><span class="line">    <span class="keyword">if</span> (!fillCommonFields(rb, nextSendingIndex - <span class="number">1</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// unlock id in installSnapshot</span></span><br><span class="line">        installSnapshot();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteBufferCollector dataBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxEntriesSize = <span class="keyword">this</span>.raftOptions.getMaxEntriesSize();</span><br><span class="line">    <span class="keyword">final</span> RecyclableByteBufferList byteBufList = RecyclableByteBufferList.newInstance();<span class="comment">//一个ThreadLocalList</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxEntriesSize; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> RaftOutter.EntryMeta.Builder emb = RaftOutter.EntryMeta.newBuilder();</span><br><span class="line">            <span class="comment">//(byteBufList长度超过maxBodySize || nextSendingIndex+i找不到新日志) 返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!prepareEntry(nextSendingIndex, i, emb, byteBufList)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rb.addEntries(emb.build());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rb.getEntriesCount() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//进行过快照，日志已被删除，即刻安装快照</span></span><br><span class="line">            <span class="keyword">if</span> (nextSendingIndex &lt; <span class="keyword">this</span>.options.getLogManager().getFirstLogIndex()) &#123;</span><br><span class="line">                installSnapshot();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有更多日志了，等待LogManagerImpl#appendEntries的通知</span></span><br><span class="line">            waitMoreEntries(nextSendingIndex);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (byteBufList.getCapacity() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dataBuf = ByteBufferCollector.allocateByRecyclers(byteBufList.getCapacity());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> ByteBuffer b : byteBufList) &#123;</span><br><span class="line">                dataBuf.put(b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> ByteBuffer buf = dataBuf.getBuffer();</span><br><span class="line">            buf.flip();</span><br><span class="line">            rb.setData(ZeroByteStringHelper.wrap(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        RecycleUtil.recycle(byteBufList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AppendEntriesRequest request = rb.build();</span><br><span class="line">    <span class="keyword">this</span>.statInfo.runningState = RunningState.APPENDING_ENTRIES;</span><br><span class="line">    <span class="keyword">this</span>.statInfo.firstLogIndex = rb.getPrevLogIndex() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.statInfo.lastLogIndex = rb.getPrevLogIndex() + rb.getEntriesCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Recyclable recyclable = dataBuf;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> v = <span class="keyword">this</span>.version;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> monotonicSendTimeMs = Utils.monotonicMs();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> seq = getAndIncrementReqSeq();</span><br><span class="line">    <span class="keyword">final</span> Future&lt;Message&gt; rpcFuture = <span class="keyword">this</span>.rpcService.appendEntries(<span class="keyword">this</span>.options.getPeerId().getEndpoint(),</span><br><span class="line">        request, -<span class="number">1</span>, <span class="keyword">new</span> RpcResponseClosureAdapter&lt;AppendEntriesResponse&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Status status)</span> </span>&#123;</span><br><span class="line">                RecycleUtil.recycle(recyclable);</span><br><span class="line">                onRpcReturned(Replicator.<span class="keyword">this</span>.id, RequestType.AppendEntries, status, request, getResponse(), seq,</span><br><span class="line">                    v, monotonicSendTimeMs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    addInflight(RequestType.AppendEntries, nextSendingIndex, request.getEntriesCount(), request.getData().size(),</span><br><span class="line">        seq, rpcFuture);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 最后再来看Follower怎么处理AppendEntriesRequest，如果前面校验过了的话，就开始执行下面部分代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">handleAppendEntriesRequest</span><span class="params">(<span class="keyword">final</span> AppendEntriesRequest request, <span class="keyword">final</span> RpcRequestClosure done)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startMs = Utils.monotonicMs();</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> entriesCount = request.getEntriesCount();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//balabala，前面已经说过了</span></span><br><span class="line">        <span class="comment">// Parse request</span></span><br><span class="line">        <span class="keyword">long</span> index = prevLogIndex;</span><br><span class="line">        <span class="keyword">final</span> List&lt;LogEntry&gt; entries = <span class="keyword">new</span> ArrayList&lt;&gt;(entriesCount);</span><br><span class="line">        ByteBuffer allData = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (request.hasData()) &#123;</span><br><span class="line">            allData = request.getData().asReadOnlyByteBuffer();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> List&lt;RaftOutter.EntryMeta&gt; entriesList = request.getEntriesList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entriesCount; i++) &#123;</span><br><span class="line">            index++;<span class="comment">//LogIndex 偏移量，即系logId = Follower.lastCommittedIndex + index</span></span><br><span class="line">            <span class="keyword">final</span> RaftOutter.EntryMeta entry = entriesList.get(i);</span><br><span class="line">            <span class="keyword">final</span> LogEntry logEntry = logEntryFromMeta(index, allData, entry);<span class="comment">//根据entryLen偏移量截取allData</span></span><br><span class="line">            <span class="keyword">if</span> (logEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Validate checksum</span></span><br><span class="line">                <span class="comment">// return error</span></span><br><span class="line">                entries.add(logEntry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//落盘后调用FollowerStableClosure，给Leader一个响应，request.lastCommittedIndex大于自己，就依序执行状态机提交数据</span></span><br><span class="line">        <span class="keyword">final</span> FollowerStableClosure closure = <span class="keyword">new</span> FollowerStableClosure(request, AppendEntriesResponse.newBuilder()</span><br><span class="line">            .setTerm(<span class="keyword">this</span>.currTerm), <span class="keyword">this</span>, done, <span class="keyword">this</span>.currTerm);</span><br><span class="line">        <span class="keyword">this</span>.logManager.appendEntries(entries, closure);</span><br><span class="line">        <span class="comment">// update configuration after _log_manager updated its memory status</span></span><br><span class="line">        checkAndSetConfiguration(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、何时提交？commit到底有多折腾？"><a href="#3、何时提交？commit到底有多折腾？" class="headerlink" title="3、何时提交？commit到底有多折腾？"></a>3、何时提交？commit到底有多折腾？</h3><p>Leader和Follower提交流程大致如下，最后都会分别执行StateMachine写入client发送的数据，下面LogManager、LogStorage以后单独讲。</p>
<p><img src="https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/commit%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="commit执行状态机"></p>
<p>我们直接来看Leader调用的<code>BallBox.commitAt()</code>吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">commitAt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> firstLogIndex, <span class="keyword">final</span> <span class="keyword">long</span> lastLogIndex, <span class="keyword">final</span> PeerId peer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO  use lock-free algorithm here?</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> stamp = <span class="keyword">this</span>.stampedLock.writeLock();</span><br><span class="line">    <span class="keyword">long</span> lastCommittedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//选举成功后默认lastLogIndex+1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.pendingIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastLogIndex &lt; <span class="keyword">this</span>.pendingIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lastLogIndex &gt;= <span class="keyword">this</span>.pendingIndex + <span class="keyword">this</span>.pendingMetaQueue.size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> startAt = Math.max(<span class="keyword">this</span>.pendingIndex, firstLogIndex);</span><br><span class="line">        Ballot.PosHint hint = <span class="keyword">new</span> Ballot.PosHint();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> logIndex = startAt; logIndex &lt;= lastLogIndex; logIndex++) &#123;</span><br><span class="line">            <span class="keyword">final</span> Ballot bl = <span class="keyword">this</span>.pendingMetaQueue.get((<span class="keyword">int</span>) (logIndex - <span class="keyword">this</span>.pendingIndex));<span class="comment">//队列偏移量</span></span><br><span class="line">            hint = bl.grant(peer, hint);</span><br><span class="line">            <span class="keyword">if</span> (bl.isGranted()) &#123;</span><br><span class="line">                lastCommittedIndex = logIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastCommittedIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//没有任何提交的日志</span></span><br><span class="line">        &#125;<span class="comment">//这一段我没能理解</span></span><br><span class="line">        <span class="comment">// When removing a peer off the raft group which contains even number of</span></span><br><span class="line">        <span class="comment">// peers, the quorum would decrease by 1, e.g. 3 of 4 changes to 2 of 3. In</span></span><br><span class="line">        <span class="comment">// this case, the log after removal may be committed before some previous</span></span><br><span class="line">        <span class="comment">// logs, since we use the new configuration to deal the quorum of the</span></span><br><span class="line">        <span class="comment">// removal request, we think it's safe to commit all the uncommitted</span></span><br><span class="line">        <span class="comment">// previous logs, which is not well proved right now</span></span><br><span class="line">        <span class="keyword">this</span>.pendingMetaQueue.removeFromFirst((<span class="keyword">int</span>) (lastCommittedIndex - <span class="keyword">this</span>.pendingIndex) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.pendingIndex = lastCommittedIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.lastCommittedIndex = lastCommittedIndex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.stampedLock.unlockWrite(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.waiter.onCommitted(lastCommittedIndex);<span class="comment">//执行状态机</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Follower就更简单了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setLastCommittedIndex</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> lastCommittedIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> stamp = <span class="keyword">this</span>.stampedLock.writeLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//只有leader才会初始化pendingIndex</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.pendingIndex != <span class="number">0</span> || !<span class="keyword">this</span>.pendingMetaQueue.isEmpty()) &#123;</span><br><span class="line">            Requires.requireTrue(lastCommittedIndex &lt; <span class="keyword">this</span>.pendingIndex,</span><br><span class="line">                <span class="string">"Node changes to leader, pendingIndex=%d, param lastCommittedIndex=%d"</span>, <span class="keyword">this</span>.pendingIndex,</span><br><span class="line">                lastCommittedIndex);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastCommittedIndex &lt; <span class="keyword">this</span>.lastCommittedIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastCommittedIndex &gt; <span class="keyword">this</span>.lastCommittedIndex) &#123;</span><br><span class="line">            <span class="keyword">this</span>.lastCommittedIndex = lastCommittedIndex;</span><br><span class="line">            <span class="keyword">this</span>.stampedLock.unlockWrite(stamp);</span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.waiter.onCommitted(lastCommittedIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stampedLock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行状态机那一块其实没什么好讲的，属于完全正常的流程，可自行阅读源码。</p>
</div><div class="tags"><a href="/tags/java/">java</a><a href="/tags/CAP%E7%90%86%E8%AE%BA/">CAP理论</a><a href="/tags/RAFT%E7%AE%97%E6%B3%95/">RAFT算法</a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/">分布式一致性</a><a href="/tags/BRAFT/">BRAFT</a><a href="/tags/JRaft/">JRaft</a><a href="/tags/%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95/">选举算法</a></div><div class="post-nav"><a class="pre" href="/2020/04/10/20200410-%E3%80%90JRaft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003%E3%80%91%E6%88%90%E5%91%98%E5%8F%98%E5%8C%96/">【JRaft源码分析03】成员变化</a><a class="next" href="/2020/03/21/20200328-%E3%80%90JRaft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9001%E3%80%91%E5%90%AF%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B/">【JRaft源码分析01】启用以及选举过程</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://zehonghuang.github.io/2020/04/01/20200401-【JRaft源码分析02】心跳机制以及日志复制/';
    this.page.identifier = '2020/04/01/20200401-【JRaft源码分析02】心跳机制以及日志复制/';
    this.page.title = '【JRaft源码分析02】心跳机制以及日志复制';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//huangzehong-me.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//huangzehong-me.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://huangzehong-me.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://zehonghuang.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-%E7%BC%96%E7%A8%8B/">C/C++编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Spring源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">java并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">java网络编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/rpc%E6%A1%86%E6%9E%B6/">rpc框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/">函数编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6/">分布式框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E6%96%87/">小文</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E8%AF%97/">小诗</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">开源框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">集合框架</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/clojure/" style="font-size: 15px;">clojure</a> <a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 15px;">教程</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">并发编程语言</a> <a href="/tags/java/" style="font-size: 15px;">java　</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/AOP/" style="font-size: 15px;">AOP</a> <a href="/tags/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/" style="font-size: 15px;">IOC控制反转</a> <a href="/tags/BeanFactory/" style="font-size: 15px;">BeanFactory</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">并发编程</a> <a href="/tags/%E5%90%8C%E6%AD%A5/" style="font-size: 15px;">同步</a> <a href="/tags/%E5%85%AC%E5%B9%B3%E9%94%81/" style="font-size: 15px;">公平锁</a> <a href="/tags/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/" style="font-size: 15px;">非公平锁</a> <a href="/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/" style="font-size: 15px;">可重入锁</a> <a href="/tags/%E8%AF%BB%E5%86%99%E9%94%81/" style="font-size: 15px;">读写锁</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/LinkedArray/" style="font-size: 15px;">LinkedArray</a> <a href="/tags/hashmap/" style="font-size: 15px;">hashmap</a> <a href="/tags/Hashtable/" style="font-size: 15px;">Hashtable</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/awk/" style="font-size: 15px;">awk</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/" style="font-size: 15px;">文本处理</a> <a href="/tags/LinkedHashMap/" style="font-size: 15px;">LinkedHashMap</a> <a href="/tags/%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6/" style="font-size: 15px;">异步框架</a> <a href="/tags/parseq/" style="font-size: 15px;">parseq</a> <a href="/tags/ReentrantLock/" style="font-size: 15px;">ReentrantLock</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E9%A5%A5%E6%B8%B4/" style="font-size: 15px;">线程饥渴</a> <a href="/tags/Dubbo/" style="font-size: 15px;">Dubbo</a> <a href="/tags/SPI/" style="font-size: 15px;">SPI</a> <a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 15px;">反射</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 15px;">源码分析</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" style="font-size: 15px;">负载均衡</a> <a href="/tags/LoadBalance/" style="font-size: 15px;">LoadBalance</a> <a href="/tags/Linux%E5%86%85%E6%A0%B8/" style="font-size: 15px;">Linux内核</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">网络编程</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/Linux%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">Linux编程</a> <a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/CAP%E7%90%86%E8%AE%BA/" style="font-size: 15px;">CAP理论</a> <a href="/tags/RAFT%E7%AE%97%E6%B3%95/" style="font-size: 15px;">RAFT算法</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/" style="font-size: 15px;">分布式一致性</a> <a href="/tags/BRAFT/" style="font-size: 15px;">BRAFT</a> <a href="/tags/JRaft/" style="font-size: 15px;">JRaft</a> <a href="/tags/%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95/" style="font-size: 15px;">选举算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/10/20200410-%E3%80%90JRaft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003%E3%80%91%E6%88%90%E5%91%98%E5%8F%98%E5%8C%96/">【JRaft源码分析03】成员变化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/01/20200401-%E3%80%90JRaft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002%E3%80%91%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6/">【JRaft源码分析02】心跳机制以及日志复制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/21/20200328-%E3%80%90JRaft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9001%E3%80%91%E5%90%AF%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B/">【JRaft源码分析01】启用以及选举过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/21/20191221-%E3%80%90Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Redis%E7%9C%9F%E7%9A%84%E4%B8%8D%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%90%8E%E5%8F%B0IO%E6%9C%8D%E5%8A%A1-BIO/">【Redis源码分析】Redis真的不是单线程，后台IO服务(BIO)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/16/20191218-%E3%80%90Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Redis%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%EF%BC%81/">【Redis源码分析】Redis启动过程是这样的！</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/11/20191216-%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91new-Thread%E6%97%B6JVM%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/">【Java并发】new Thread时JVM做了什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/09/20190109-%E3%80%90%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%91NIO%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/">【网络编程】从Linux角度以及JVM源码，深入NIO的细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/23/20181123-%E3%80%90Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91BeanFactory%E4%BD%93%E7%B3%BB%E7%9A%84%E4%BD%9C%E7%94%A8/">【Spring源码分析】BeanFactory体系的作用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/06/20180906-%E3%80%90Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E5%9B%9B%E7%A7%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">【Dubbo源码分析】四种负载均衡</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/02/20180902-%E3%80%90Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91SPI%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%B0%86URL%E4%B8%8E%E5%8F%AF%E6%8F%92%E6%8B%94%E6%8B%93%E5%B1%95%E8%9E%8D%E5%90%88%E5%88%B0%E6%9E%81%E8%87%B4/">【Dubbo源码分析】SPI机制，将URL与可插拔拓展融合到极致</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//huangzehong-me.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">作为客体的类库.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>